
#Область ПрограммныйИнтерфейс

#Область МетодыРаботыАвтозаполненияРеквизитовДокумента

// Устарела. Следует использовать функцию ОбщегоНазначения.ОписаниеТипаЧисло(Разрядность, РазрядностьДробнойЧасти = 0, ЗнакЧисла = Неопределено)
// Служебная функция, предназначенная для получения описания типов числа, заданной разрядности.
// 
// Параметры:
//  Разрядность - Число - разрядность числа
//  РазрядностьДробнойЧасти - Число - Разрядность дробной части.
//  Неотрицательный - Булево - если Истина, то числа только положительные, если Ложь, то любые.
//
// Возвращаемое значение:
//  ОписаниеТипов - для числа указанной разрядности.
//
Функция ПолучитьОписаниеТиповЧисла(Разрядность, РазрядностьДробнойЧасти, Неотрицательный = Ложь) Экспорт
	
	Если Неотрицательный Тогда
		Знак = ДопустимыйЗнак.Неотрицательный;
	Иначе
		Знак = ДопустимыйЗнак.Любой;
	КонецЕсли;
	
	Возврат ОбщегоНазначения.ОписаниеТипаЧисло(Разрядность, РазрядностьДробнойЧасти, Знак);

КонецФункции // ПолучитьОписаниеТиповЧисла()

// Служебная функция, предназначенная для получения описания типов даты
// 
// Параметры:
//  ЧастиДаты - ЧастиДаты - Системное перечисление ЧастиДаты.
// 
//  Возвращаемое значение:
//    ОписаниеТипов - 
Функция ПолучитьОписаниеТиповДаты(ЧастиДаты) Экспорт

	Возврат Новый ОписаниеТипов("Дата", , , Новый КвалификаторыДаты(ЧастиДаты));

КонецФункции // ПолучитьОписаниеТиповДаты()

// Дополняет одну таблицу значений строками другой таблицы значений
//
// Параметры:
//	Приемник - ТаблицаЗначений - произвольная коллекция, в которую добавляются строки
//	Источник - ТаблицаЗначений - произвольная коллекция, из которой берутся добавляемые строки
//	СоответствиеПолей - Соответствие - используется чтобы заполнить поля с разными названиями, 
//										ключ содержит имя поля приемника, значение содержит имя поля источника.
//	ЗначенияПоУмолчанию - Структура - значения, которые будут помещены во все добавленные строки,
//										ключ содержит имя поля приемника.
//
Процедура ДобавитьСтрокиВТаблицу(Приемник, Источник, СоответствиеПолей = Неопределено, ЗначенияПоУмолчанию = Неопределено) Экспорт

	Для каждого СтрокаИсточника Из Источник Цикл
		НоваяСтрока = Приемник.Добавить();
		ЗаполнитьЗначенияСвойств(НоваяСтрока, СтрокаИсточника);
		Если СоответствиеПолей <> Неопределено Тогда
			Для каждого КлючИЗначение Из СоответствиеПолей Цикл
				НоваяСтрока[КлючИЗначение.Ключ] = СтрокаИсточника[КлючИЗначение.Значение];
			КонецЦикла; 
		КонецЕсли; 
		Если ЗначенияПоУмолчанию <> Неопределено Тогда
			ЗаполнитьЗначенияСвойств(НоваяСтрока, ЗначенияПоУмолчанию);
		КонецЕсли;
	КонецЦикла;

КонецПроцедуры

// Заполняет колонку таблицы значений последовательными номерами
//
// Параметры:
//	Таблица - ТаблицаЗначений - Таблица значений, строки которой нужно пронумеровать
//	ИмяКолонкиНомераСтроки - Строка - Имя колонки таблицы значений, в которой будут указаны номера строк
//
Процедура ПронумероватьТаблицуЗначений(Таблица, ИмяКолонкиНомераСтроки) Экспорт

	Если Таблица.Колонки.Найти(ИмяКолонкиНомераСтроки) = Неопределено Тогда
		Таблица.Колонки.Добавить(ИмяКолонкиНомераСтроки, ПолучитьОписаниеТиповЧисла(15, 0));
	КонецЕсли;

	КоличествоСтрок = Таблица.Количество() - 1;
	Для НомерСтроки = 0 По КоличествоСтрок Цикл
		Таблица[НомерСтроки][ИмяКолонкиНомераСтроки] = НомерСтроки;
	КонецЦикла;

КонецПроцедуры

// Выгружает таблицу значений из ДанныеФормыКоллекция и ТабличнаяЧасть
//
// Параметры:
// 		ТаблицаИсточник - ДанныеФормыКоллекция, ТабличнаяЧасть - Таблица источник выгрузки
// 		Строки - Массив -
//             - Структура - Массив строк для выгрузки или структура отбора
// 		Колонки - Строка - Перечисленные через запятую имена колонок для выгрузки
// 		КолонкиПоЗначению - Структура Из КлючИЗначение - Структура колонок для добавление в результирующую таблицу:
// 										* Ключ - Строка - Имя новой колонки
// 										* Значение - Строка - Значение для подстановки по все строки новой колонки.
// 		НовыеИменаКолонок - Структура Из КлючИЗначение - Структура с данными о переименовании колонок в результирующей таблице:
// 										* Ключ - Строка - Текущее имя колонки
// 										* Значение - Строка - Новое имя колонки.
//
// Возвращаемое значение:
// 		ТаблицаЗначений - Таблица результат выгрузки из таблицы источника с добавленными и переименованными колонками.
//
Функция ВыгрузитьТаблицуЗначений(ТаблицаИсточник, Строки = Неопределено, Колонки = "НомерСтроки",
			Знач КолонкиПоЗначению = Неопределено, Знач НовыеИменаКолонок = Неопределено) Экспорт
	
	// Определение значений по умолчанию
	Если КолонкиПоЗначению = Неопределено Тогда
		КолонкиПоЗначению = Новый Структура;
	КонецЕсли;
	Если НовыеИменаКолонок = Неопределено Тогда
		НовыеИменаКолонок = Новый Структура;
	КонецЕсли;
	
	// Определить список выгружаемых колонок
	СтруктураДругихИменКолонок = Новый Структура;
	Для Каждого НовоеИмя Из НовыеИменаКолонок Цикл
		СтруктураДругихИменКолонок.Вставить(НовоеИмя.Значение, НовоеИмя.Ключ);
	КонецЦикла;
	ИменаКолонок = "";
	ИмяКолонки = "";
	СтруктураКолонок = Новый Структура(Колонки);
	Для Каждого Колонка Из СтруктураКолонок Цикл
		Если Не СтруктураДругихИменКолонок.Свойство(Колонка.Ключ, ИмяКолонки) Тогда
			ИмяКолонки = Колонка.Ключ;
		КонецЕсли;
		Если Не КолонкиПоЗначению.Свойство(ИмяКолонки) Тогда
			ИменаКолонок = ИменаКолонок + ", " + ИмяКолонки;
		КонецЕсли;
	КонецЦикла;
	
	// Выгрузить из таблицы источника
	Если ТипЗнч(ТаблицаИсточник) = Тип("ТаблицаЗначений") Тогда
		ТаблицаРезультата = ТаблицаИсточник.Скопировать(Строки, Сред(ИменаКолонок, 3));
	Иначе
		ТаблицаРезультата = ТаблицаИсточник.Выгрузить(Строки, Сред(ИменаКолонок, 3));
	КонецЕсли;
	
	// Добавить новые колонки в таблицу результата
	Если КолонкиПоЗначению <> Неопределено Тогда
		Для Каждого Колонка Из КолонкиПоЗначению Цикл
			МассивТипов = Новый Массив;
			МассивТипов.Добавить(ТипЗнч(Колонка.Значение));
			ТаблицаРезультата.Колонки.Добавить(Колонка.Ключ, Новый ОписаниеТипов(МассивТипов));
			ТаблицаРезультата.ЗаполнитьЗначения(Колонка.Значение, Колонка.Ключ);
		КонецЦикла;
	КонецЕсли;
	
	// Переименовать колонки в таблице результата
	Если НовыеИменаКолонок <> Неопределено Тогда
		Для Каждого Колонка Из НовыеИменаКолонок Цикл
			ТаблицаРезультата.Колонки[Колонка.Ключ].Имя = Колонка.Значение;
		КонецЦикла;
	КонецЕсли;
	
	Возврат ТаблицаРезультата;
	
КонецФункции // ВыгрузитьТаблицуЗначений()

// Заполняет идентификатор строк в таблице значений
//
// Параметры:
//  Таблица - ТаблицаЗначений - Таблица значений, строки которой нужно пронумеровать
//  ИмяКолонки - Строка	- Колонка таблицы значений, в которой будут заполнены идентификаторы.
//  ТипИдентификатора - Строка - Тип идентификатора ("Число", "УникальныйИдентификатор")
//
Процедура ДобавитьИдентификаторСтрокВТаблицу(Таблица, ИмяКолонки = "Идентификатор", ТипИдентификатора = "Число") Экспорт

	Если ТипИдентификатора = "Число" Тогда

		Если Таблица.Колонки.Найти(ИмяКолонки) = Неопределено Тогда
			Таблица.Колонки.Добавить(ИмяКолонки, Новый ОписаниеТипов("Число", Новый КвалификаторыЧисла(15, 0, ДопустимыйЗнак.Неотрицательный)));
		КонецЕсли;
		
		Для НомерСтроки = 0 По Таблица.Количество() - 1 Цикл
			Таблица[НомерСтроки][ИмяКолонки] = НомерСтроки + 1;
		КонецЦикла;
		
	ИначеЕсли ТипИдентификатора = "УникальныйИдентификатор" Тогда
		
		Если Таблица.Колонки.Найти(ИмяКолонки) = Неопределено Тогда
			Таблица.Колонки.Добавить(ИмяКолонки, Новый ОписаниеТипов("УникальныйИдентификатор"));
		КонецЕсли;
		
		Для НомерСтроки = 0 По Таблица.Количество() - 1 Цикл
			Таблица[НомерСтроки][ИмяКолонки] = Новый УникальныйИдентификатор;
		КонецЦикла;
		
	ИначеЕсли ТипИдентификатора = "Строка" Тогда
		
		Если Таблица.Колонки.Найти(ИмяКолонки) = Неопределено Тогда
			Таблица.Колонки.Добавить(ИмяКолонки, ОбщегоНазначения.ОписаниеТипаСтрока(36));
		КонецЕсли;
		
		Для НомерСтроки = 0 По Таблица.Количество() - 1 Цикл
			Таблица[НомерСтроки][ИмяКолонки] = Строка(Новый УникальныйИдентификатор);
		КонецЦикла;
		
	КонецЕсли;

КонецПроцедуры

// Процедура делает запись в журнал регистрации и сообщает пользователю, если это сообщение об ошибке 
// Параметры:
//   ПараметрыЖурнала - Структура - параметры записи в журнал регистрации:
//       		* ГруппаСобытий - Строка - префикс для имени события журнала регистрации
//       		* Метаданные - ОбъектМетаданных - метаданные для записи в журнал регистрации
//       		* Данные - Произвольный - данные для записи в журнал регистрации
//   УровеньЖурнала - УровеньЖурналаРегистрации - Уровень журнала регистрации
//   ИмяСобытия - Строка  - имя события (в журнал событие записывается в формате ГруппаСобытий.ИмяСобытия)
//   Комментарий - Строка - комментарий о событии
//   ИнформацияОбОшибке - ИнформацияОбОшибке -
//	                    - Строка - Информация об ошибке, которую так же необходимо задокументировать в комментарии журнала регистрации.
//
Процедура ЗаписатьВЖурналСообщитьПользователю(ПараметрыЖурнала, УровеньЖурнала, ИмяСобытия, Знач Комментарий = "", ИнформацияОбОшибке = Неопределено) Экспорт
	
	Если ТипЗнч(ИнформацияОбОшибке) = Тип("ИнформацияОбОшибке") Тогда
		Если Комментарий = "" Тогда
			ТестСообщенияПользователю = КраткоеПредставлениеОшибки(ИнформацияОбОшибке);
			Комментарий = ПодробноеПредставлениеОшибки(ИнформацияОбОшибке);
		Иначе
			ТестСообщенияПользователю = Комментарий + Символы.ПС + КраткоеПредставлениеОшибки(ИнформацияОбОшибке);
			Комментарий = Комментарий + Символы.ПС + ПодробноеПредставлениеОшибки(ИнформацияОбОшибке);
		КонецЕсли;
	Иначе
		Если ТипЗнч(ИнформацияОбОшибке) = Тип("Строка") 
			И Не ПустаяСтрока(ИнформацияОбОшибке) Тогда
			Комментарий = Комментарий + Символы.ПС + ИнформацияОбОшибке;
		КонецЕсли;
		ТестСообщенияПользователю = Комментарий;
	КонецЕсли;
	
	// Журнал регистрации 
	УстановитьПривилегированныйРежим(Истина);
	ЗаписьЖурналаРегистрации(
	    СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
			НСтр("ru = '%1';
				|en = '%1'", ОбщегоНазначения.КодОсновногоЯзыка()),
			ПараметрыЖурнала.ГруппаСобытий + ?(ИмяСобытия = "", "", "." + ИмяСобытия)),
		УровеньЖурнала, 
		ПараметрыЖурнала.Метаданные, 
		ПараметрыЖурнала.Данные, 
		Комментарий);
	УстановитьПривилегированныйРежим(Ложь);
	
	Если УровеньЖурнала = УровеньЖурналаРегистрации.Ошибка 
		Или УровеньЖурнала = УровеньЖурналаРегистрации.Предупреждение Тогда
		
		ОбщегоНазначенияКлиентСервер.СообщитьПользователю(СокрЛП(ТестСообщенияПользователю),ПараметрыЖурнала.Данные);
	КонецЕсли;
	
КонецПроцедуры

// Возвращает ключ данных для подстановки в сообщение пользователю
// Ключ данных нужен при групповой обработке объектов - если он установлен, то при нажатии пользователем на сообщение
// будет открываться форма объекта.
//
//	Параметры:
//		Объект - ДокументОбъект - 
//             - СправочникОбъект - 
//             - ПланВидовХарактеристикОбъект - Объект, для которого нужно получить ключ данных.
//	
//	Возвращаемое значение:
//		СправочникСсылка, ДокументСсылка, ПланВидовХарактеристикСсылка -
//
Функция КлючДанныхДляСообщенияПользователю(Объект) Экспорт
	
	КлючДанных = Неопределено;
	XMLТипЗнч = XMLТипЗнч(Объект); 
	
	Если XMLТипЗнч <> Неопределено Тогда
		ТипЗначенияСтрокой = XMLТипЗнч.ИмяТипа;
		Если СтрНайти(ТипЗначенияСтрокой, "Object.") > 0 Тогда
			КлючДанных = Объект.Ссылка;
		КонецЕсли;
	КонецЕсли;
	
	Возврат КлючДанных;
	
КонецФункции

// Вызывается из подписки ЗаполнитьРеквизитыОбъекта
// Проверяет заполненность реквизитов формы, связанных с функциональными опциями
// ИспользоватьНесколькоОрганизаций, ИспользоватьНесколькоСкладов, ИспользоватьНесколькоВалют.
//
//	Параметры:
//		Объект - ДокументОбъект -
//			   - СправочникОбъект - Заполняемый объект
//		ДанныеЗаполнения - Произвольный - Данные заполнения 
//		СтандартнаяОбработка - Булево - Признак стандартной обработки события
//	
//	Возвращаемое значение
//		Ссылка - ссылка на объект информационной базы.
//
Процедура ОбработкаЗаполнения(Объект, ДанныеЗаполнения, СтандартнаяОбработка) Экспорт
	
	Возврат;
	
КонецПроцедуры

// Заполняет уникальный идентификатор платежа
//
// Параметры:
// 	Объект - ДокументОбъект - Документ для заполнения уникального идентификатора платежа
//
// Возвращаемое значение:
// 	Строка -
Функция ПолучитьУникальныйИдентификаторПлатежа(Объект) Экспорт
	
	Префикс = ПолучитьПрефиксДляУИП(Объект.Ссылка);
	Дата = Формат(Объект.Дата, "ДФ=yyMM");
	Номер = СтрЗаменить(Объект.Номер, "-", "");
	Код = Строка(Префикс) + Строка(Дата) + Строка(Номер);
	УИН = ПолучитьУникальныйИдентификаторПлатежаСКонтрольнымРазрядом(Код);
	
	Возврат УИН;
	
КонецФункции

// Функция возвращает изменения документа, относительно записанного в базе
// 
// Параметры:
// 	Объект - ДокументОбъект - Документ, изменение которого необходимо проанализировать
// 	РеквизитыИсключения - Структура - Структура имен реквизитов, изменение которых проверять не требуется
// 	ТабличныеЧастиИсключения - Структура - Структура имен табличных частей, изменение которых проверять не требуется.
//
// Возвращаемое значение:
// 	Структура - Содержит изменения объекта:
// 				* Реквизиты - ТаблицаЗначений - Таблица измененных реквизитов:
//	                                              * Имя - Строка - 
//	                                              * НовоеЗначение - Произвольный -
//											      * СтароеЗначение - Произвольный - 
// 				* ТабличныеЧасти - Структура - Изменные табличные части
Функция ИзмененияДокумента(Объект, РеквизитыИсключения = Неопределено, ТабличныеЧастиИсключения = Неопределено) Экспорт
	
	Результат = Новый Структура;
	
	Если РеквизитыИсключения = Неопределено Тогда
		РеквизитыИсключения = Новый Структура;
	КонецЕсли;
	
	Если ТабличныеЧастиИсключения = Неопределено Тогда
		ТабличныеЧастиИсключения = Новый Структура;
	КонецЕсли;
	
	МетаданныеДокумента = Объект.Метаданные(); 
	
	ПолноеИмя = МетаданныеДокумента.ПолноеИмя();
	
	СтрокаНеограниченнойДлинны = Новый ОписаниеТипов("Строка", , , , Новый КвалификаторыСтроки(0));
	
	РеквизитыДокумента = Новый Структура;
	РеквизитыДокумента.Вставить("Дата");
	Для каждого Реквизит Из МетаданныеДокумента.Реквизиты Цикл
		Если СтрНайти(Реквизит.Имя, "Удалить") = 1 Тогда
			Продолжить;
		КонецЕсли;
		Если Реквизит.Тип = СтрокаНеограниченнойДлинны Тогда
			Продолжить;
		КонецЕсли;
		Если РеквизитыИсключения.Свойство(Реквизит.Имя) Тогда
			Продолжить;
		КонецЕсли;
		РеквизитыДокумента.Вставить(Реквизит.Имя);
	КонецЦикла;
	
	ТабличныеЧастиДокумента = Новый Структура;
	Для каждого ТабличнаяЧасть Из МетаданныеДокумента.ТабличныеЧасти Цикл
		Если СтрНайти(ТабличнаяЧасть.Имя, "Удалить") = 1 Тогда
			Продолжить;
		КонецЕсли;
		Если ТабличныеЧастиИсключения.Свойство(ТабличнаяЧасть.Имя) Тогда
			Продолжить;
		КонецЕсли;
		РеквизитыТабличнойЧасти = Новый Структура;
		Для каждого Реквизит Из ТабличнаяЧасть.Реквизиты Цикл
			ТипРеквизита =  Реквизит.Тип;
			Если ТипРеквизита = СтрокаНеограниченнойДлинны Тогда
				Продолжить;
			КонецЕсли; 
			РеквизитыТабличнойЧасти.Вставить(Реквизит.Имя);
		КонецЦикла;
		ТабличныеЧастиДокумента.Вставить(ТабличнаяЧасть.Имя, РеквизитыТабличнойЧасти);
	КонецЦикла;
	
	ТекстЗапроса= "ВЫБРАТЬ
		|	Таблица.Проведен КАК Проведен";
		ШаблонРеквизит = ",
		|	Таблица.%1 КАК %1";
	Для каждого Реквизит Из РеквизитыДокумента Цикл
		ТекстЗапроса = ТекстЗапроса + СтрШаблон(ШаблонРеквизит, Реквизит.Ключ); 
	КонецЦикла;
	
	ШаблонПоместить = "
	|ИЗ
	|	%1 КАК Таблица
	|ГДЕ
	|	Таблица.Ссылка = &Ссылка
	|";
	ТекстЗапроса = ТекстЗапроса + СтрШаблон(ШаблонПоместить, ПолноеИмя);
	
	Запрос = Новый Запрос;
	Запрос.Текст = ТекстЗапроса;
	Запрос.УстановитьПараметр("Ссылка", Объект.Ссылка); 
	
	Выборка = Запрос.Выполнить().Выбрать();
	Выборка.Следующий(); 
	
	ТаблицаИзмененныхРеквизитов = Новый ТаблицаЗначений;
	ТаблицаИзмененныхРеквизитов.Колонки.Добавить("Имя");
	ТаблицаИзмененныхРеквизитов.Колонки.Добавить("НовоеЗначение");
	ТаблицаИзмененныхРеквизитов.Колонки.Добавить("СтароеЗначение");
	Для каждого Реквизит Из РеквизитыДокумента Цикл
		Если Выборка[Реквизит.Ключ] <> Объект[Реквизит.Ключ] Тогда
			НоваяСтрока = ТаблицаИзмененныхРеквизитов.Добавить();
			НоваяСтрока.Имя = Реквизит.Ключ;
			НоваяСтрока.НовоеЗначение = Объект[Реквизит.Ключ];
			НоваяСтрока.СтароеЗначение = Выборка[Реквизит.Ключ];
		КонецЕсли;
	КонецЦикла;
	
	Если ТаблицаИзмененныхРеквизитов.Количество() > 0 Тогда
		Результат.Вставить("Реквизиты", ТаблицаИзмененныхРеквизитов);
	КонецЕсли;
	
	Для каждого ТабличнаяЧасть Из ТабличныеЧастиДокумента Цикл
		
		ТекстЗапроса = "ВЫБРАТЬ
		|	Таблица.НомерСтроки КАК НомерСтроки";
		ШаблонРеквизит = ",
		|	Таблица.%1 КАК %1";
		Для каждого Реквизит Из ТабличнаяЧасть.Значение Цикл
			ТекстЗапроса = ТекстЗапроса + СтрШаблон(ШаблонРеквизит, Реквизит.Ключ);
		КонецЦикла;
		
		ШаблонПоместить = "
		|ПОМЕСТИТЬ НоваяТаблица%1
		|ИЗ
		|	&%1 КАК Таблица
		|;
		|
		|////////////////////////////
		|";
		ТекстЗапроса = ТекстЗапроса + СтрШаблон(ШаблонПоместить, ТабличнаяЧасть.Ключ);
		
		ТекстОбъединенияНовая =
		"ВЫБРАТЬ
		|	Таблица.НомерСтроки КАК НомерСтроки";
		
		ТекстОбъединенияСтарая =
		"ВЫБРАТЬ
		|	-Таблица.НомерСтроки КАК НомерСтроки";
		
		ШаблонРеквизит = ",
		|	Таблица.%1 КАК %1";
		Для каждого Реквизит Из ТабличнаяЧасть.Значение Цикл
			ТекстОбъединенияНовая  = ТекстОбъединенияНовая + СтрШаблон(ШаблонРеквизит, Реквизит.Ключ);
			ТекстОбъединенияСтарая = ТекстОбъединенияСтарая + СтрШаблон(ШаблонРеквизит, Реквизит.Ключ);
		КонецЦикла;
		
		ШаблонИзНовая = "
		|ИЗ
		|	НоваяТаблица%1 КАК Таблица";
		ТекстОбъединенияНовая = ТекстОбъединенияНовая + СтрШаблон(ШаблонИзНовая, ТабличнаяЧасть.Ключ);
		
		ШаблонИзСтарая = "
		|ИЗ
		|	%1.%2 КАК Таблица
		|ГДЕ
		|	Таблица.Ссылка = &Ссылка";
		ТекстОбъединенияСтарая = ТекстОбъединенияСтарая + СтрШаблон(ШаблонИзСтарая, ПолноеИмя, ТабличнаяЧасть.Ключ);
		
		ТекстЗапроса = ТекстЗапроса + 
		"ВЫБРАТЬ
		|	СУММА(ВложенныйЗапрос.НомерСтроки) КАК НомерСтроки";
		ШаблонРеквизит = ",
		|	ВложенныйЗапрос.%1 КАК %1";
		Для каждого Реквизит Из ТабличнаяЧасть.Значение Цикл
			ТекстЗапроса  = ТекстЗапроса + СтрШаблон(ШаблонРеквизит, Реквизит.Ключ);
		КонецЦикла;
		ТекстЗапроса = ТекстЗапроса + "
		|ИЗ 
		|(" 
		+ Символы.ПС + ТекстОбъединенияНовая 
		+ Символы.ПС + " ОБЪЕДИНИТЬ ВСЕ "
		+ Символы.ПС + ТекстОбъединенияСтарая + ") КАК ВложенныйЗапрос
		|
		|СГРУППИРОВАТЬ ПО";
		
		ШаблонСгруппировать = "
		|	ВложенныйЗапрос.%1,";
		Для каждого Реквизит Из ТабличнаяЧасть.Значение Цикл
			ТекстЗапроса  = ТекстЗапроса + СтрШаблон(ШаблонСгруппировать, Реквизит.Ключ);
		КонецЦикла;
		ТекстЗапроса = ТекстЗапроса + "ИСТИНА
		|ИМЕЮЩИЕ 
		|	СУММА(ВложенныйЗапрос.НомерСтроки) <> 0";
		
		Запрос = Новый Запрос;
		Запрос.Текст = ТекстЗапроса;
		Запрос.УстановитьПараметр("Ссылка", Объект.Ссылка);
		Запрос.УстановитьПараметр(ТабличнаяЧасть.Ключ, Объект[ТабличнаяЧасть.Ключ]);
		
		РезультатЗапроса = Запрос.Выполнить();
		Если НЕ РезультатЗапроса.Пустой() Тогда
			Если НЕ Результат.Свойство("ТабличныеЧасти") Тогда
				Результат.Вставить("ТабличныеЧасти", Новый Структура);
			КонецЕсли;
			Результат.ТабличныеЧасти.Вставить(ТабличнаяЧасть.Ключ, РезультатЗапроса.Выгрузить());
		КонецЕсли;
		
	КонецЦикла;
	
	Возврат Результат;
	
КонецФункции

// Очищает реквизит "ИдентификаторДокумента" и колонки "ИдентификаторФинЗаписи", "ИдентификаторСтроки" в табличных частях документа.
//
// Параметры:
// 	Документ - ДокументОбъект - Документ с очищаемым идентификатором
// 	ИменаТЧ - Строка - Имена ТЧ, в которых нужно очистить идентификаторы, разделенные запятыми
// 	НайтиТЧПоМетаданным - Булево - Необходимость поиска состава обрабатываемых ТЧ по метаданным, если их список не передан в параметре ИменаТЧ
//
Процедура ОчиститьИдентификаторыДокумента(Документ, ИменаТЧ = "", НайтиТЧПоМетаданным = Ложь) Экспорт
	
	МетаданныеДокумента = Документ.Метаданные();
	
	Если НЕ ПустаяСтрока(ИменаТЧ) Тогда
		МассивТЧ = СтрРазделить(ИменаТЧ, ",", Ложь);
	ИначеЕсли НайтиТЧПоМетаданным Тогда
		МассивТЧ = Новый Массив();
		Для Каждого МетаданныеТЧ Из МетаданныеДокумента.ТабличныеЧасти Цикл
			Если МетаданныеТЧ.Реквизиты.Найти("ИдентификаторСтроки") <> Неопределено
			 Или МетаданныеТЧ.Реквизиты.Найти("ИдентификаторФинЗаписи") <> Неопределено Тогда
				МассивТЧ.Добавить(МетаданныеТЧ.Имя);
			КонецЕсли;
		КонецЦикла;
	Иначе
		МассивТЧ = Новый Массив();
	КонецЕсли;
	
	//Идентификатор документа
	Если МетаданныеДокумента.Реквизиты.Найти("ИдентификаторДокумента") <> Неопределено Тогда
		Документ.ИдентификаторДокумента = "";
	КонецЕсли;
	
	//Идентификаторы строк ТЧ
	Для Каждого ИмяТЧ Из МассивТЧ Цикл
		МетаданныеТЧ = МетаданныеДокумента.ТабличныеЧасти[ИмяТЧ];
		ИмяРеквизита = "ИдентификаторФинЗаписи";
		
		Если МетаданныеТЧ.Реквизиты.Найти(ИмяРеквизита) = Неопределено Тогда
			ИмяРеквизита = "ИдентификаторСтроки";
		КонецЕсли;

		ТабличнаяЧасть = Документ[ИмяТЧ];
		
		Для Каждого СтрокаТаблицы Из ТабличнаяЧасть Цикл
			СтрокаТаблицы[ИмяРеквизита] = "";
		КонецЦикла;
	КонецЦикла;
	
КонецПроцедуры

// Заполняет реквизит "ИдентификаторДокумента" и колонки "ИдентификаторФинЗаписи", "ИдентификаторСтроки" в табличных частях документа значениями уникальных идентификаторов.
//
// Параметры:
// 	Документ - ДокументОбъект - Записываемый новый документ с идентификатором
// 	ИменаТЧ - Строка - Имена ТЧ, в которых нужно заполнить идентификаторы, разделенные запятыми
// 	НайтиТЧПоМетаданным - Булево - Необходимость поиска состава обрабатываемых ТЧ по метаданным, если их список не передан в параметре ИменаТЧ
//
Процедура ЗаполнитьИдентификаторыДокумента(Документ, ИменаТЧ = "", НайтиТЧПоМетаданным = Ложь) Экспорт
	
	МетаданныеДокумента = Документ.Метаданные();
	
	Если НЕ ПустаяСтрока(ИменаТЧ) Тогда
		МассивТЧ = СтрРазделить(ИменаТЧ, ",", Ложь);
	ИначеЕсли НайтиТЧПоМетаданным Тогда
		МассивТЧ = Новый Массив();
		Для Каждого МетаданныеТЧ Из МетаданныеДокумента.ТабличныеЧасти Цикл
			Если МетаданныеТЧ.Реквизиты.Найти("ИдентификаторСтроки") <> Неопределено
			 Или МетаданныеТЧ.Реквизиты.Найти("ИдентификаторФинЗаписи") <> Неопределено Тогда
				МассивТЧ.Добавить(МетаданныеТЧ.Имя);
			КонецЕсли;
		КонецЦикла;
	Иначе
		МассивТЧ = Новый Массив();
	КонецЕсли;
	
	Уникальность = Новый Соответствие;
	
	//Идентификатор документа
	Если МетаданныеДокумента.Реквизиты.Найти("ИдентификаторДокумента") <> Неопределено Тогда
		Если Не ЗначениеЗаполнено(Документ.ИдентификаторДокумента) Тогда
			Документ.ИдентификаторДокумента = Строка(Новый УникальныйИдентификатор);
		КонецЕсли;
		Уникальность.Вставить(Документ.ИдентификаторДокумента, Документ.ИдентификаторДокумента);
	КонецЕсли;
	
	//Идентификаторы строк ТЧ
	Для Каждого ИмяТЧ Из МассивТЧ Цикл
		МетаданныеТЧ = МетаданныеДокумента.ТабличныеЧасти[ИмяТЧ];
		ИмяРеквизита = "ИдентификаторФинЗаписи";
		
		Если МетаданныеТЧ.Реквизиты.Найти(ИмяРеквизита) = Неопределено Тогда
			ИмяРеквизита = "ИдентификаторСтроки";
		КонецЕсли;

		ТабличнаяЧасть = Документ[ИмяТЧ];
		
		Для Каждого СтрокаТаблицы Из ТабличнаяЧасть Цикл
			Если Не ЗначениеЗаполнено(СтрокаТаблицы[ИмяРеквизита])
				Или Уникальность[СтрокаТаблицы[ИмяРеквизита]] <> Неопределено Тогда
				// Идентификатор в строке не заполнен ИЛИ идентификатор встречался ранее
				СтрокаТаблицы[ИмяРеквизита] = Строка(Новый УникальныйИдентификатор);
			КонецЕсли;
			Уникальность.Вставить(СтрокаТаблицы[ИмяРеквизита], СтрокаТаблицы[ИмяРеквизита]);
		КонецЦикла;
	КонецЦикла;
	
КонецПроцедуры

// Заполняет в переданной таблице значений колонку с переданным именем уникальными идентификаторами.
// Если колонки с таким именем не существует, то добавляет ее в таблицу значений.
//
// Параметры:
// 	ТаблЗначений - ТаблицаЗначений - обрабатываемая таблица значений
// 	ИмяКолонки - Строка - имя заполняемой колонки
//
Процедура ДобавитьИдентификаторыВТаблицуЗначений(ТаблЗначений, ИмяКолонки = "ИдентификаторФинЗаписи") Экспорт
	
	КолонкиТаблицы = ТаблЗначений.Колонки;
	
	Если КолонкиТаблицы.Найти(ИмяКолонки) = Неопределено Тогда
		КолонкиТаблицы.Добавить(ИмяКолонки, ОбщегоНазначения.ОписаниеТипаСтрока(36));
	КонецЕсли;
	
	Для Каждого СтрокаТаблицы Из ТаблЗначений Цикл
		СтрокаТаблицы[ИмяКолонки] = Строка(Новый УникальныйИдентификатор);
	КонецЦикла;
	
КонецПроцедуры

// Добавляет в указанную временную таблицу колонку с переданным именем с уникальными идентификаторами
//
// Параметры:
// 	ИмяТаблицы - Строка - Имя временной таблицы
// 	МенеджерВременныхТаблиц - МенеджерВременныхТаблиц - содержит изменяемую временную таблицу
// 	ИмяКолонки - Строка - Имя колонки с идентификатором, которую необходимо добавить
//
Процедура ДобавитьИдентификаторыВоВременнуюТаблицу(ИмяТаблицы, МенеджерВременныхТаблиц, ИмяКолонки = "ИдентификаторСтроки") Экспорт
	
	ПоляИсходнойВременнойТаблицы = Новый Массив;
	ПоляНовойВременнойТаблицы = Новый Массив;
	
	КолонкиВременнойТаблицы = МенеджерВременныхТаблиц.Таблицы[ИмяТаблицы].Колонки; // КолонкиВременнойТаблицыЗапроса - 
	Для каждого Колонка Из КолонкиВременнойТаблицы Цикл
		Если Колонка.Имя <> ИмяКолонки Тогда
			Поле = СтрШаблон("%1.%2 КАК %2", ИмяТаблицы, Колонка.Имя);
			ПоляИсходнойВременнойТаблицы.Добавить(Поле);
			ПоляНовойВременнойТаблицы.Добавить(Поле);
		КонецЕсли;
	КонецЦикла;
	
	Если КолонкиВременнойТаблицы.Найти("НомерЗаписи") = Неопределено Тогда
		ПоляИсходнойВременнойТаблицы.Добавить("АВТОНОМЕРЗАПИСИ() КАК НомерЗаписи");	
	КонецЕсли;
	
	ПоляНовойВременнойТаблицы.Добавить(СтрШаблон("ТаблицаИдентификаторов.Идентификатор КАК %1", ИмяКолонки));
	
	ТекстЗапроса = "
	|ВЫБРАТЬ
	|	&ПоляИсходнойВременнойТаблицы
	|ПОМЕСТИТЬ ИмяТаблицы_Подготовленная
	|ИЗ
	|	ИмяТаблицы КАК ИмяТаблицы
	|ИНДЕКСИРОВАТЬ ПО
	|	НомерЗаписи
	|;
	|
	|////////////////////////////////////////////////////////////////////////////////
	|УНИЧТОЖИТЬ ИмяТаблицы
	|;
	|
	|////////////////////////////////////////////////////////////////////////////////
	|ВЫБРАТЬ
	|	ИмяТаблицы_Подготовленная.НомерЗаписи КАК НомерЗаписи
	|ИЗ
	|	ИмяТаблицы_Подготовленная КАК ИмяТаблицы_Подготовленная
	|";
	
	Разделитель = ",
	|";
	
	ТекстЗапроса = СтрЗаменить(ТекстЗапроса, "ИмяТаблицы", ИмяТаблицы);
	ТекстЗапроса = СтрЗаменить(ТекстЗапроса, "&ПоляИсходнойВременнойТаблицы", СтрСоединить(ПоляИсходнойВременнойТаблицы, Разделитель));
			
	Запрос = Новый Запрос(ТекстЗапроса);
	Запрос.МенеджерВременныхТаблиц = МенеджерВременныхТаблиц;
	Результаты = Запрос.ВыполнитьПакет();
	
	ТаблицаИдентификаторов = Результаты[Результаты.ВГраница()].Выгрузить();
	ДобавитьИдентификаторыВТаблицуЗначений(ТаблицаИдентификаторов, "Идентификатор");
	
	ТекстЗапроса = "
	|ВЫБРАТЬ
	|	ТаблицаИдентификаторов.НомерЗаписи КАК НомерЗаписи,
	|	ТаблицаИдентификаторов.Идентификатор КАК Идентификатор
	|ПОМЕСТИТЬ ТаблицаИдентификаторов
	|ИЗ
	|	&ТаблицаИдентификаторов КАК ТаблицаИдентификаторов
	|ИНДЕКСИРОВАТЬ ПО
	|	НомерЗаписи
	|;
	|
	|////////////////////////////////////////////////////////////////////////////////
	|ВЫБРАТЬ
	|	&ПоляНовойВременнойТаблицы
	|ПОМЕСТИТЬ ИмяТаблицы
	|ИЗ
	|	ИмяТаблицы_Подготовленная КАК ИмяТаблицы
	|	ЛЕВОЕ СОЕДИНЕНИЕ
	|		ТаблицаИдентификаторов КАК ТаблицаИдентификаторов
	|	ПО
	|		ИмяТаблицы.НомерЗаписи = ТаблицаИдентификаторов.НомерЗаписи
	|;
	|
	|////////////////////////////////////////////////////////////////////////////////
	|УНИЧТОЖИТЬ ИмяТаблицы_Подготовленная
	|;
	|
	|//////////////////////////////////////////////////////////////////////////////// 
	|УНИЧТОЖИТЬ ТаблицаИдентификаторов
	|";
	
	ТекстЗапроса = СтрЗаменить(ТекстЗапроса, "ИмяТаблицы", ИмяТаблицы);
	ТекстЗапроса = СтрЗаменить(ТекстЗапроса, "&ПоляНовойВременнойТаблицы", СтрСоединить(ПоляНовойВременнойТаблицы, Разделитель));
			
	Запрос.Текст = ТекстЗапроса;
	Запрос.УстановитьПараметр("ТаблицаИдентификаторов", ТаблицаИдентификаторов);
	Запрос.Выполнить();
	
КонецПроцедуры

// Возвращает количество записей во временной таблице
// 
// Параметры:
// 	МенеджерВременныхТаблиц - МенеджерВременныхТаблиц - 
// 	ИмяВременнойТаблицы - Строка -
// 	
// Возвращаемое значение:
// 	Число - Количество записей
//
Функция РазмерВременнойТаблицы(МенеджерВременныхТаблиц, ИмяВременнойТаблицы) Экспорт

	Запрос = Новый Запрос;
	Запрос.МенеджерВременныхТаблиц = МенеджерВременныхТаблиц;

	Запрос.Текст = 
	"ВЫБРАТЬ
	|	КОЛИЧЕСТВО(*) КАК КоличествоСтрок
	|ИЗ
	|	&ИмяТаблицы КАК Т";
	Запрос.Текст = СтрЗаменить(Запрос.Текст, "&ИмяТаблицы", ИмяВременнойТаблицы);

	Выборка = Запрос.Выполнить().Выбрать();
	Выборка.Следующий();

	Возврат Выборка.КоличествоСтрок;

КонецФункции

#КонецОбласти

#Область ПроцедурыИФункцииДляПолученияПредставленияДанных

// Возвращает строковое представление документа для отображения в сообщениях.
//
// Параметры:
//	Ссылка - ДокументСсылка - Ссылка на документ
//	Номер - Строка - Номер документа
//	Дата - Дата - Дата документа
//
// Возвращаемое значение:
//	Строка - представление документа
Функция ПолучитьПредставлениеДокумента(Ссылка, Номер, Дата) Экспорт
	
	Возврат
		Ссылка.Метаданные().Синоним
		+ ?(ЗначениеЗаполнено(Номер), " " + Номер, "")
		+ ?(ЗначениеЗаполнено(Дата), " " + НСтр("ru = 'от';
												|en = 'dated'") + " " + Формат(Дата,"ДЛФ=D"), "");
	
КонецФункции

// Формирует представление результата поиска по строке.
// 
// Параметры:
//  Наименование - Строка - Наименование.
//  СтрокаПоиска - Строка - Строка поиска.
// 
// Возвращаемое значение:
//  ФорматированнаяСтрока - Представление результата поиска по строке.
//
Функция ПредставлениеРезультатаПоискаПоСтроке(Наименование, СтрокаПоиска) Экспорт

	ПозНачало = СтрНайти(ВРег(Наименование), ВРег(СтрокаПоиска));
	Если ПозНачало <> 0 Тогда
		
		ДлинаТекста = СтрДлина(СтрокаПоиска);
		ДлинаПредставления = СтрДлина(Наименование);
		
		ПредставлениеСсылки = 
			Новый ФорматированнаяСтрока(
				?(ПозНачало <> 1, Лев(Наименование, ПозНачало - 1), ""),
				Новый ФорматированнаяСтрока(Сред(Наименование, ПозНачало, ДлинаТекста), Новый Шрифт(,, Истина), ЦветаСтиля.ЦветТекстаЗаголовокОтчетаВТакси),
				?(ДлинаПредставления > (ПозНачало + ДлинаТекста - 1) , Сред(Наименование, ПозНачало + ДлинаТекста), ""));
				
									
	Иначе
		
		ПредставлениеСсылки = Наименование;
		
	КонецЕсли; 

	Возврат ПредставлениеСсылки;
	
КонецФункции

#КонецОбласти
#КонецОбласти

#Область ПрочиеПроцедурыИФункции

// Возвращает метаданные объекта по полному имени объекта метаданных. Не обрабатываются точки маршрутов бизнес-процессов.
//
// Параметры:
//  ПолноеИмя - Строка - Полное имя объекта метаданных, например, "Справочник.Организации".
//
// Возвращаемое значение:
//  ОбъектМетаданных -
// 
Функция МетаданныеОбъектаПоПолномуИмени(ПолноеИмя) Экспорт
	
	ЧастиИмени = СтроковыеФункцииКлиентСервер.РазложитьСтрокуВМассивПодстрок(ПолноеИмя, ".");
	
	КлассОМ = ЧастиИмени[0];
	ИмяОМ   = ЧастиИмени[1];
	
	Если      ВРег(КлассОМ) = "ПЛАНОБМЕНА" Тогда
		Возврат Метаданные.ПланыОбмена[ИмяОМ];
		
	ИначеЕсли ВРег(КлассОМ) = "СПРАВОЧНИК" Тогда
		Возврат Метаданные.Справочники[ИмяОМ];
		
	ИначеЕсли ВРег(КлассОМ) = "ДОКУМЕНТ" Тогда
		Возврат Метаданные.Документы[ИмяОМ];
		
	ИначеЕсли ВРег(КлассОМ) = "ЖУРНАЛДОКУМЕНТОВ" Тогда
		Возврат Метаданные.ЖурналыДокументов[ИмяОМ];
		
	ИначеЕсли ВРег(КлассОМ) = "ПЕРЕЧИСЛЕНИЕ" Тогда
		Возврат Метаданные.Перечисления[ИмяОМ];
		
	ИначеЕсли ВРег(КлассОМ) = "ОТЧЕТ" Тогда
		Возврат Метаданные.Отчеты[ИмяОМ];
		
	ИначеЕсли ВРег(КлассОМ) = "ОБРАБОТКА" Тогда
		Возврат Метаданные.Обработки[ИмяОМ];
		
	ИначеЕсли ВРег(КлассОМ) = "ПЛАНВИДОВХАРАКТЕРИСТИК" Тогда
		Возврат Метаданные.ПланыВидовХарактеристик[ИмяОМ];
		
	ИначеЕсли ВРег(КлассОМ) = "ПЛАНСЧЕТОВ" Тогда
		Возврат Метаданные.ПланыСчетов[ИмяОМ];
		
	ИначеЕсли ВРег(КлассОМ) = "ПЛАНВИДОВРАСЧЕТА" Тогда
		Возврат Метаданные.ПланЫВидовРасчета[ИмяОМ];
		
	ИначеЕсли ВРег(КлассОМ) = "РЕГИСТРСВЕДЕНИЙ" Тогда
		Возврат Метаданные.РегистрыСведений[ИмяОМ];
		
	ИначеЕсли ВРег(КлассОМ) = "РЕГИСТРНАКОПЛЕНИЯ" Тогда
		Возврат Метаданные.РегистрыНакопления[ИмяОМ];
		
	ИначеЕсли ВРег(КлассОМ) = "РЕГИСТРБУХГАЛТЕРИИ" Тогда
		Возврат Метаданные.РегистрыБухгалтерии[ИмяОМ];
		
	ИначеЕсли ВРег(КлассОМ) = "РЕГИСТРРАСЧЕТА" Тогда
		Возврат Метаданные.РегистрыРасчета[ИмяОМ];
		
	ИначеЕсли ВРег(КлассОМ) = "БИЗНЕСПРОЦЕСС" Тогда
		Возврат Метаданные.БизнесПроцессы[ИмяОМ];
		
	ИначеЕсли ВРег(КлассОМ) = "ЗАДАЧА" Тогда
		Возврат Метаданные.Задачи[ИмяОМ];
		
	ИначеЕсли ВРег(КлассОМ) = "КОНСТАНТА" Тогда
		Возврат Метаданные.Константы[ИмяОМ];
		
	ИначеЕсли ВРег(КлассОМ) = "ПОСЛЕДОВАТЕЛЬНОСТЬ" Тогда
		Возврат Метаданные.Последовательности[ИмяОМ];
		
	ИначеЕсли ВРег(КлассОМ) = "ОБЩИЙМОДУЛЬ" Тогда
		Возврат Метаданные.ОбщиеМодули[ИмяОМ];
		
	Иначе
		ВызватьИсключение СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
			НСтр("ru = 'Неизвестный тип объекта метаданных (%1)';
				|en = 'Unknown type of metadata object (%1)'"), КлассОМ);
	КонецЕсли;
	
КонецФункции

// Осуществляет проверку заполненности проверяемых реквизитов.
//
// Параметры:
// 		Объект - ДокументОбъект, СправочникОбъект - Проверяемый объект.
// 		МассивПроверяемыхРеквизитов - Массив Из Строка - Массив проверяемых реквизитов.
//
// Возвращаемое значение:
// 		Булево - Истина, если значение хотя бы одного реквизита не заполнено, иначе Ложь.
//
Функция ПроверитьЗаполнениеРеквизитовОбъекта(Объект, МассивПроверяемыхРеквизитов) Экспорт
	
	Перем ПроверяемыеРеквизитыТЧ;
	Отказ = Ложь;
	
	// Получение метаданных объекта
	МетаданныеОбъекта = Объект.Ссылка.Метаданные();
	
	// Создание структуры стандартных реквизитов
	СтандартныеРеквизиты = Новый Структура;
	Для Каждого Реквизит Из МетаданныеОбъекта.СтандартныеРеквизиты Цикл
		СтандартныеРеквизиты.Вставить(Реквизит.Имя, ?(ЗначениеЗаполнено(Реквизит.Представление()), Реквизит.Представление(), Реквизит.Имя));
	КонецЦикла;
	
	// Создание структуры для хранения имен табличных частей и проверяемых реквизитов в них.
	// 		Ключ -  Имя табличной части
	// 		Значение - Массив - Массив строк, реквизитов этой табличной части для проверки.
	ТабличныеЧасти = Новый Структура;
	
	// Создание шаблонов сообщений об ошибках не заполненных реквизитов и реквизитов табличных частей.
	ШаблонОшибкиРеквизита = НСтр("ru = 'Поле ""%ИмяРеквизита%"" не заполнено';
								|en = '""%ИмяРеквизита%"" is required'");
	ШаблонОшибкиТЧ = НСтр("ru = 'Не введено ни одной строки в список ""%ИмяРеквизита%""';
							|en = 'No line is entered into the ""%ИмяРеквизита%"" list'");
	ШаблонОшибкиРеквизитаТЧ = НСтр("ru = 'Не заполнена колонка ""%ИмяРеквизита%"" в строке %НомерСтроки% списка ""%ИмяТабличнойЧасти%""';
									|en = 'Column ""%ИмяРеквизита%"" in line %НомерСтроки% of the ""%ИмяТабличнойЧасти%"" list is not filled in'");
	
	// Проверка реквизитов объекта и заполнение структуры по реквизитам табличных частей.
	Для Каждого Реквизит Из МассивПроверяемыхРеквизитов Цикл
		
		ПозицияТочки = СтрНайти(Реквизит,".");
		
		Если ПозицияТочки > 0 Тогда // В случае если указан реквизит табличной части
			
			ДлинаСтроки       = СтрДлина(Реквизит);
			ИмяТабличнойЧасти = Лев(Реквизит, ПозицияТочки-1);
			ИмяРеквизита      = Прав(Реквизит, ДлинаСтроки - ПозицияТочки);
			
			// Сохранение проверяемого реквизита табличной части в структуру
			Если НЕ ТабличныеЧасти.Свойство(ИмяТабличнойЧасти, ПроверяемыеРеквизитыТЧ) Тогда
				ПроверяемыеРеквизитыТЧ = Новый Массив;
				ТабличныеЧасти.Вставить(ИмяТабличнойЧасти, ПроверяемыеРеквизитыТЧ);
			КонецЕсли;
			ПроверяемыеРеквизитыТЧ.Добавить(ИмяРеквизита);
			
		Иначе // В случае если указан реквизит объекта
			
			Если Не ЗначениеЗаполнено(Объект[Реквизит]) Тогда
				
				Если МетаданныеОбъекта.Реквизиты.Найти(Реквизит) <> Неопределено Тогда // Если указано имя реквизита
					ТекстОшибки = СтрЗаменить(ШаблонОшибкиРеквизита, "%ИмяРеквизита%",
						МетаданныеОбъекта.Реквизиты[Реквизит].Синоним);
				ИначеЕсли СтандартныеРеквизиты.Свойство(Реквизит) Тогда // Если указано имя стандартного реквизита
					ТекстОшибки = СтрЗаменить(ШаблонОшибкиРеквизита, "%ИмяРеквизита%",
						СтандартныеРеквизиты[Реквизит]);
				Иначе // Если указано имя табличной части
					ТекстОшибки = СтрЗаменить(ШаблонОшибкиТЧ, "%ИмяРеквизита%",
						МетаданныеОбъекта.ТабличныеЧасти[Реквизит].Синоним);
				КонецЕсли;
				
				ОбщегоНазначенияКлиентСервер.СообщитьПользователю(
					ТекстОшибки,
					Объект,
					Реквизит,
					,
					Отказ);
				
			КонецЕсли;
			
		КонецЕсли;
		
	КонецЦикла;
	
	// Проверка реквизитов в табличных частях
	Для Каждого ТабличнаяЧасть Из ТабличныеЧасти Цикл
		
		ИмяТабличнойЧасти = ТабличнаяЧасть.Ключ;
		ТабличнаяЧастьОбъекта = Объект[ТабличнаяЧасть.Ключ];
		МассивРеквизитов = ТабличнаяЧасть.Значение;
		
		// Цикл по всем строкам табличной части.
		Для НомерСтроки=0 По ТабличнаяЧастьОбъекта.Количество()-1 Цикл
			
			// Цикл по всем проверяемым реквизитам для текущей табличной части.
			Для НомерРеквизита=0 По МассивРеквизитов.Количество()-1 Цикл
				
				ИмяРеквизита = МассивРеквизитов[НомерРеквизита];
				
				Если Не ЗначениеЗаполнено(ТабличнаяЧастьОбъекта[НомерСтроки][ИмяРеквизита]) Тогда
					
					ТекстОшибки = СтрЗаменить(ШаблонОшибкиРеквизитаТЧ, "%ИмяРеквизита%", МетаданныеОбъекта.ТабличныеЧасти[ИмяТабличнойЧасти].Реквизиты[ИмяРеквизита].Синоним);
					ТекстОшибки = СтрЗаменить(ТекстОшибки, "%НомерСтроки%", Формат(НомерСтроки+1, "ЧГ=0"));
					ТекстОшибки = СтрЗаменить(ТекстОшибки, "%ИмяТабличнойЧасти%", МетаданныеОбъекта.ТабличныеЧасти[ИмяТабличнойЧасти].Синоним);
					
					ОбщегоНазначенияКлиентСервер.СообщитьПользователю(
						ТекстОшибки,
						Объект,
						ОбщегоНазначенияКлиентСервер.ПутьКТабличнойЧасти(ИмяТабличнойЧасти, НомерСтроки+1, ИмяРеквизита),
						,
						Отказ);
					
				КонецЕсли;
				
			КонецЦикла;
			
		КонецЦикла;
		
	КонецЦикла;
	
	МассивПроверяемыхРеквизитов.Очистить();
	
	Возврат Отказ;
	
КонецФункции // ПроверитьЗаполнениеРеквизитовОбъекта()

// Осуществляет проверку соответствия организации документа и хозяйственной операции.
//
// Параметры:
// 	ДокументОбъект - ДокументОбъект - Проверяемый объект
//	Отказ - Булево - Флаг отказа записи
//
Процедура ПроверитьПравильностьУказанияХозяйственнойОперации(ДокументОбъект, Отказ) Экспорт
	
	Если ДокументОбъект.Организация = Справочники.Организации.УправленческаяОрганизация
	   И (ДокументОбъект.ХозяйственнаяОперация = Перечисления.ХозяйственныеОперации.РеализацияКлиентуРеглУчет
	 ИЛИ ДокументОбъект.ХозяйственнаяОперация = Перечисления.ХозяйственныеОперации.ЗакупкаУПоставщикаРеглУчет) Тогда
	 
		Текст = СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
			НСтр("ru = 'В документе нельзя указывать операцию %1 и управленческую организацию';
				|en = 'You cannot specify operation %1 and management company in the document'"),
			ДокументОбъект.ХозяйственнаяОперация);
		ОбщегоНазначенияКлиентСервер.СообщитьПользователю(
			Текст,
			ДокументОбъект,
			"ХозяйственнаяОперация",
			,
			Отказ);
	 
	КонецЕсли;
	
КонецПроцедуры // ПроверитьПравильностьУказанияХозяйственнойОперации()

// Параметры проверки возможности ввода на основании.
//
// Возвращаемое значение:
//  Структура:
//  * Статус - ПеречислениеСсылка - Статус документ, на основании которого осуществляется ввод
//  * ЕстьОшибкиПроведен - Булево - Если Истина - документ, на основании которого осуществляется ввод, не проведен
//  * ЕстьОшибкиСтатус   - Булево - Если Истина - документ, на основании которого осуществляется ввод, имеет некорректный статус
//  * МассивДопустимыхСтатусов - Массив - Массив допустимых статусов
//  * СоглашениеДоступноВнешнемуПользователю - Булево - Если Истина, документ на основании которого осуществляется ввод имеет соглашение доступное внешнему пользователю.
//  * ПрерыватьВыполнение - Булево - Если Истина, то при наличии ошибки будет вызвано исключение, если Ложь, то просто выводится сообщение.
//
Функция ПараметрыПроверкиВозможностиВводаНаОсновании() Экспорт
	
	ПараметрыПроверки = Новый Структура;
	ПараметрыПроверки.Вставить("Статус", Неопределено);
	ПараметрыПроверки.Вставить("ЕстьОшибкиПроведен", Ложь);
	ПараметрыПроверки.Вставить("ЕстьОшибкиСтатус", Ложь);
	ПараметрыПроверки.Вставить("МассивДопустимыхСтатусов", Неопределено);
	ПараметрыПроверки.Вставить("СоглашениеДоступноВнешнемуПользователю", Неопределено);
	ПараметрыПроверки.Вставить("ПрерыватьВыполнение", Истина);
	
	Возврат ПараметрыПроверки;
	
КонецФункции

// Осуществляет проверку возможности ввода документа на основании распоряжения по хозяйственной операции.
//
// Параметры:
//	ДокументОснование	- ДокументСсылка - документ, на основании которого осуществляется ввод.
//	ИмяДокумента		- Строка - имя документа, для которого определяются допустимые операции.
//	ХозяйственнаяОперация- ПеречислениеСсылка.ХозяйственныеОперации	- хозяйственная операция документа, 
//											на основании которого осуществляется ввод.
//	ПредставлениеДокумента - Строка - 
//	                       - Неопределено - Представление документа в информационной базе.
//
Процедура ПроверитьВозможностьВводаНаОснованииПоОперации(ДокументОснование,
							ИмяДокумента,
							ХозяйственнаяОперация,
							ПредставлениеДокумента = Неопределено) Экспорт
	
	ОперацииДокумента = ДопустимыеХозяйственныеОперацииДокумента(ИмяДокумента);
	
	Если ОперацииДокумента.Найти(ХозяйственнаяОперация) = Неопределено Тогда
		СинонимДокумента = ?(ЗначениеЗаполнено(ПредставлениеДокумента),
					ПредставлениеДокумента,
					Метаданные.Документы[ИмяДокумента].Синоним);
		
		ТекстОшибки = НСтр("ru = 'Невозможно оформить документ ""%1"" на основании распоряжения %2 с операцией ""%3"".';
							|en = 'Cannot register the ""%1"" document based on the %2 reference with the ""%3"" operation.'");
		ТекстОшибки = СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(ТекстОшибки,
											СинонимДокумента,
											ДокументОснование,
											ХозяйственнаяОперация);
		
		ВызватьИсключение ТекстОшибки;
	КонецЕсли;
	
	
КонецПроцедуры

// Осуществляет проверку заполненности проверяемых реквизитов.
//
// Параметры:
// Документ                            - ДокументСсылка - Документ, на основании которого осуществляется ввод
// ЕстьОшибкиПроведен                  - Булево - Если Истина - документ, на основании которого осуществляется ввод, не проведен
// ЕстьОшибкиВернутьМногооборотнуюТару - Булево - Если Истина - по документу, на основании которого осуществляется ввод,
//                                                тара не возвратная.
//
Процедура ПроверитьВозможностьВводаНаОснованииВыкупаТары(Документ, ЕстьОшибкиПроведен, ЕстьОшибкиВернутьМногооборотнуюТару) Экспорт
	
	Если ЕстьОшибкиПроведен Тогда
		
		ТекстОшибки = НСтр("ru = 'Документ %Документ% не проведен. Ввод на основании непроведенного документа запрещен.';
							|en = 'Document %Документ% is not posted. Generation from unposted documents is not allowed.'");
		ТекстОшибки = СтрЗаменить(ТекстОшибки, "%Документ%", Документ);
	
		ВызватьИсключение ТекстОшибки;
		
	ИначеЕсли ЕстьОшибкиВернутьМногооборотнуюТару Тогда
		
		ТекстОшибки = НСтр("ru = 'В документе %Документ% не стоит признак возврата многооборотной тары. Ввод на основании запрещен.';
							|en = 'Document %Документ% contains no indication whether the reusable packaging has been returned. Generation from such base documents is not allowed.'");
		ТекстОшибки = СтрЗаменить(ТекстОшибки, "%Документ%", Документ);
	
		ВызватьИсключение ТекстОшибки;
		
	КонецЕсли;
	
КонецПроцедуры

// Осуществляет проверку заполненности проверяемых реквизитов.
//
// Параметры:
// ЕстьОшибкиТиповое  - Булево - Если Истина - соглашение, на основании которого осуществляется ввод - типовое
// ЭтоАгентскиеУслуги  - Булево - Если Истина - соглашение, на основании которого осуществляется ввод - соглашение по
//                                оказанию агентских услуг.
//
Процедура ПроверитьВозможностьВводаНаОснованииСоглашения(ЕстьОшибкиТиповое = Ложь, ЭтоАгентскиеУслуги = Ложь) Экспорт
	
	Если ЕстьОшибкиТиповое Тогда
		
		ТекстОшибки = НСтр("ru = 'Ввод на основании типового соглашения с клиентом запрещен.';
							|en = 'Cannot generate documents from a standard agreement with a customer.'");
	
		ВызватьИсключение ТекстОшибки;
		
	КонецЕсли;
	
	Если ЭтоАгентскиеУслуги Тогда
		
		ТекстОшибки = НСтр("ru = 'Ввод на основании типового соглашения по оказанию агентских услуг запрещен.';
							|en = 'Cannot generate documents from a standard agent service agreement.'");
	
		ВызватьИсключение ТекстОшибки;
		
	КонецЕсли;
	
КонецПроцедуры // ПроверитьВозможностьВводаНаОснованииСоглашения()

// Осуществляет проверку заполненности проверяемых реквизитов.
//
// Параметры:
// 	Партнер - СправочникСсылка.Партнеры - Партнер из сделки по продаже.
//
Процедура ПроверитьВозможностьВводаНаОснованииСделкиПоПродаже(Партнер) Экспорт
	
	Если Не ЗначениеЗаполнено(Партнер) Тогда
		
		ТекстОшибки = НСтр("ru = 'В сделке не указан клиент, ввод на основании запрещен.';
							|en = 'No customer is specified in the sales opportunity. Generation from such base document is not allowed.'");
	
		ВызватьИсключение ТекстОшибки;
		
	КонецЕсли;
	
КонецПроцедуры // ПроверитьВозможностьВводаНаОснованииСделкиПоПродаже()

// Устанавливает или сбрасывает флаг Согласован у справочника.
// Вызывается из процедуры ПередЗаписью документа.
//
// Параметры:
// 	СправочникОбъект - СправочникОбъект - Справочник, в котором необходимо изменить флаг Согласован
// 	СтатусНеСогласован - ПеречислениеСсылка - Статус документа, в котором флаг Согласован должен быть сброшен.
//
Процедура ИзменитьПризнакСогласованностиСправочника(СправочникОбъект, Знач СтатусНеСогласован = Неопределено) Экспорт
	
	// Справочник не имеет статуса
	Если СтатусНеСогласован = Неопределено Тогда
		
		Если Не СправочникОбъект.Согласован Тогда
			СправочникОбъект.Согласован = Истина;
		КонецЕсли;
		
	// Справочник имеет статус, в котором проведенный справочник не согласован
	Иначе
		
		Если СправочникОбъект.Статус = СтатусНеСогласован И СправочникОбъект.Согласован Тогда
			СправочникОбъект.Согласован = Ложь;
		ИначеЕсли СправочникОбъект.Статус <> СтатусНеСогласован И Не СправочникОбъект.Согласован Тогда
			СправочникОбъект.Согласован = Истина;
		КонецЕсли;
		
	КонецЕсли;
	
КонецПроцедуры // ИзменитьПризнакСогласованностиСправочника()

// Устанавливает или сбрасывает флаг Согласован у документа.
// Вызывается из процедуры ПередЗаписью документа.
//
// Параметры:
// 	ДокументОбъект - ДокументОбъект - Документ, в котором необходимо изменить флаг Согласован
// 	РежимЗаписи - РежимЗаписиДокумента - Режим записи документа
// 	СтатусНеСогласован - ПеречислениеСсылка -  Статус документа, в котором флаг Согласован должен быть сброшен.
//
Процедура ИзменитьПризнакСогласованностиДокумента(ДокументОбъект, Знач РежимЗаписи, Знач СтатусНеСогласован = Неопределено) Экспорт
	
	Если РежимЗаписи = РежимЗаписиДокумента.Запись
	 ИЛИ РежимЗаписи = РежимЗаписиДокумента.ОтменаПроведения Тогда
		
		Если ДокументОбъект.Согласован Тогда
			ДокументОбъект.Согласован = Ложь;
		КонецЕсли;
		
	ИначеЕсли РежимЗаписи = РежимЗаписиДокумента.Проведение Тогда
		
		// Документ не имеет статуса
		Если СтатусНеСогласован = Неопределено Тогда
		
			Если Не ДокументОбъект.Согласован Тогда
				ДокументОбъект.Согласован = Истина;
			КонецЕсли;
			
		// Документ имеет статус из массива, в которых проведенный документ не согласован
		ИначеЕсли ТипЗнч(СтатусНеСогласован) = Тип("Массив") Тогда
			
			Если ДокументОбъект.Согласован Тогда
				
				Для Каждого ТекСтатус Из СтатусНеСогласован Цикл
					
					Если ДокументОбъект.Статус = ТекСтатус Тогда
						
						ДокументОбъект.Согласован = Ложь;
						Прервать;
						
					КонецЕсли;
					
				КонецЦикла;
				
			Иначе
				
				ДокументСогласован = Истина;
				
				Для Каждого ТекСтатус Из СтатусНеСогласован Цикл
					
					Если ДокументОбъект.Статус = ТекСтатус Тогда
						ДокументСогласован = Ложь;
					КонецЕсли;
					
				КонецЦикла;
				
				Если ДокументСогласован Тогда
					ДокументОбъект.Согласован = Истина;
				КонецЕсли;
				
			КонецЕсли;
			
		// Документ имеет статус, в котором проведенный документ не согласован
		Иначе
			
			Если ДокументОбъект.Статус = СтатусНеСогласован И ДокументОбъект.Согласован Тогда
				ДокументОбъект.Согласован = Ложь;
			ИначеЕсли ДокументОбъект.Статус <> СтатусНеСогласован И Не ДокументОбъект.Согласован Тогда
				ДокументОбъект.Согласован = Истина;
			КонецЕсли;
			
		КонецЕсли;

	КонецЕсли;
	
КонецПроцедуры // ИзменитьПризнакСогласованностиДокумента()

// Настраивает подключаемое оборудование в форме, устанавливает флаг ИспользоватьПодключаемоеОборудование в форме.
// 
// Параметры:
//   Форма - ФормаКлиентскогоПриложения - Форма, в которой необходимо настроить подключаемое оборудование.
//   ПрефиксыЭлементовФормы - Строка - 
//	                        - Массив Из Строка - ПрефиксыЭлементовФормы
//
Процедура НастроитьПодключаемоеОборудование(Форма, ПрефиксыЭлементовФормы = "Товары") Экспорт
	
	Возврат;
	
КонецПроцедуры

// Проверяет, что включена ф.о "Использовать подключаемое оборудование", настроено ли оборудование и авторизовался пользователь.
// 
// Параметры:
// 	ТипыПодключенногоОборудования - ПеречислениеСсылка.ТипыПодключаемогоОборудования - 
//
// Возвращаемое значение:
// 	Булево - 
Функция ИспользоватьПодключаемоеОборудование(ТипыПодключенногоОборудования = Неопределено) Экспорт
	
	Возврат Ложь;
	
КонецФункции

// Возвращает список пользователей, имеющих роли, указанные в качестве параметра
//
// Параметры:
// 		МассивРолей - Массив из Строка - массив с именами ролей
// 		ПредставлениеТекущегоПользователя - Строка - представление текущего пользователя.
// 
//	Возвращаемое значение:
//		СписокЗначений Из СправочникСсылка.Пользователи -
//
Функция ПользователиСДоступнымиРолями(МассивРолей, ПредставлениеТекущегоПользователя = Неопределено) Экспорт
	
	Возврат Неопределено;
	
КонецФункции

// Возвращает список пользователей, имеющих право на изменение объекта метаданных
//
// Параметры:
// 		ОбъектМетаданных - ОбъектМетаданных - Объект метаданных, на которые проверяются права доступа
// 		ПредставлениеТекущегоПользователя - Строка - представление текущего пользователя.
// 
//	Возвращаемое значение:
//		СписокЗначений Из СправочникСсылка.Пользователи.
//
Функция ПолучитьСписокПользователейСПравомДобавления(ОбъектМетаданных, ПредставлениеТекущегоПользователя = Неопределено) Экспорт
	
	Возврат Неопределено;
		
КонецФункции

// Возвращает массив с уникальными значениями из колонки таблицы
//
// Параметры:
//  Таблица		 - ТаблицаЗначений -
//				 - ДанныеФормыСтруктура - 
//  ИмяКолонки	 - Строка -
// 
// Возвращаемое значение:
// 	Массив -
//
Функция УникальныеЗначенияИзКолонкиТаблицы(Таблица, ИмяКолонки) Экспорт
	
	Если ТипЗнч(Таблица) = Тип("ТаблицаЗначений") Тогда
		ОбрабатываемаяТаблица = Таблица.Скопировать(,ИмяКолонки);
	Иначе
		ОбрабатываемаяТаблица = Таблица.Выгрузить(,ИмяКолонки);
	КонецЕсли;
		
	ОбрабатываемаяТаблица.Свернуть(ИмяКолонки);
	Возврат ОбрабатываемаяТаблица.ВыгрузитьКолонку(0);
	
КонецФункции

// Удаляет указанные строки из таблицы значений.
// 
// Параметры:
//	Таблица - ТаблицаЗначений - обрабатываемая таблица
//	Строки  - Массив Из СтрокаТаблицыЗначений - Массив удаляемых строк
//
Процедура УдалитьСтрокиТаблицыЗначений(Таблица, Строки) Экспорт
	
	Для Каждого СтрокаТаблицы Из Строки Цикл
		Таблица.Удалить(СтрокаТаблицы);
	КонецЦикла;
	
КонецПроцедуры

// Удаляет строки из таблицы значений с учетом переданного отбора.
// 
// Параметры:
//	Таблица 			  - ТаблицаЗначений - обрабатываемая таблица
//	СтруктураПоиска 	  - Структура - структура поиска строк, см. описание метода НайтиСтроки таблицы значений
//	УдалятьПопавшиеВОтбор - Булево - если указать Ложь, то будут удалены все строки, не входящие в отбор.
//
Процедура НайтиИУдалитьСтрокиТаблицыЗначений(Таблица, СтруктураПоиска, УдалятьПопавшиеВОтбор = Истина) Экспорт
	
	Строки = Таблица.НайтиСтроки(СтруктураПоиска);
	
	Если НЕ УдалятьПопавшиеВОтбор Тогда
		
		Если Строки.Количество() = Таблица.Количество() Тогда
			Возврат; // нечего удалять
		ИначеЕсли Строки.Количество() = 0 Тогда
			Таблица.Очистить();
		Иначе
			
			УдаляемыеСтроки = Новый Массив;
			
			Для Каждого СтрокаТаблицы Из Таблица Цикл
				
				Если Строки.Найти(СтрокаТаблицы) = Неопределено Тогда
					УдаляемыеСтроки.Добавить(СтрокаТаблицы); // строка не входит в переданный отбор
				КонецЕсли;
				
			КонецЦикла;
			
			УдалитьСтрокиТаблицыЗначений(Таблица, УдаляемыеСтроки);
			
		КонецЕсли;
		
	Иначе
		
		Если Строки.Количество() = 0 Тогда
			Возврат; // нечего удалять
		ИначеЕсли Строки.Количество() = Таблица.Количество() Тогда
			Таблица.Очистить();
		Иначе
			УдалитьСтрокиТаблицыЗначений(Таблица, Строки);
		КонецЕсли;
		
	КонецЕсли;
	
КонецПроцедуры

// Функция раскладывает переданный массив ссылок в соответствие по типам этих ссылок.
//
//	Параметры:
//		МассивСсылок - Массив Из ЛюбаяСсылка - массив ссылок на объекты информационной базы
//  Возвращаемое значение:
//		Соответствие - Соотвествие типов ссылкам.
//			Ключ - полное имя типа ссылки.
//	        Значение - Массив Из ЛюбаяСсылка - ссылок этого типа.
//
Функция СоответствиеМассивовПоТипамОбъектов(МассивСсылок) Экспорт
	
	СоответствиеТипов = Новый Соответствие;
	
	Для Каждого Объект Из МассивСсылок Цикл
		
		ТипОбъекта = Объект.Метаданные().ПолноеИмя();
		ТекущийТипОбъекта = СоответствиеТипов.Получить(ТипОбъекта); // Массив - 
		
		Если ТекущийТипОбъекта = Неопределено Тогда
			СоответствиеТипов.Вставить(ТипОбъекта, Новый Массив);
			ТекущийТипОбъекта = СоответствиеТипов.Получить(ТипОбъекта);
		КонецЕсли;
		ТекущийТипОбъекта.Добавить(Объект);
		
	КонецЦикла;
	
	Возврат СоответствиеТипов;
	
КонецФункции

// Возвращает разницу между двумя датами (в днях)
//
// Параметры:
//  ДатаНачала 		- Дата - начальная дата периода
//  ДатаОкончания	- Дата - конечная дата периода.
//  Периодичность	- ПеречислениеСсылка.Периодичность - Периодичность.
//
// Возвращаемое значение:
//   Число	 - количество дней между двумя датами.
//
Функция РазностьДат(ДатаНачала, ДатаОкончания, Периодичность) Экспорт
	
	СекундВМинуте = 60;
	МинутВЧасе = 60;
	ЧасовВДне = 24;
	
	Если Периодичность = Перечисления.Периодичность.Год Тогда
		Возврат Год(ДатаОкончания) - Год(ДатаНачала);
		
	ИначеЕсли Периодичность = Перечисления.Периодичность.Полугодие Тогда
		Возврат ?(Месяц(ДатаОкончания)>6, 2, 1) - ?(Месяц(ДатаНачала)>6, 2, 1) + 2*(Год(ДатаОкончания) - Год(ДатаНачала));
		
	ИначеЕсли Периодичность = Перечисления.Периодичность.Квартал Тогда
		Возврат Цел(Месяц(НачалоКвартала(ДатаОкончания))/3) - Цел(Месяц(НачалоКвартала(ДатаНачала))/3) + 4*(Год(ДатаОкончания) - Год(ДатаНачала));
		
	ИначеЕсли Периодичность = Перечисления.Периодичность.Месяц Тогда
		Возврат Месяц(ДатаОкончания) - Месяц(ДатаНачала) + 12*(Год(ДатаОкончания) - Год(ДатаНачала));
		
	ИначеЕсли Периодичность = Перечисления.Периодичность.Декада Тогда
		Возврат Цел((ДатаОкончания - ДатаНачала)/(10 * СекундВМинуте*МинутВЧасе*ЧасовВДне));
		
	ИначеЕсли Периодичность = Перечисления.Периодичность.Неделя Тогда
		Возврат Цел((НачалоНедели(ДатаОкончания) - НачалоНедели(ДатаНачала))/(7 * СекундВМинуте*МинутВЧасе*ЧасовВДне));
		
	ИначеЕсли Периодичность = Перечисления.Периодичность.День Тогда
		Возврат (ДатаОкончания - ДатаНачала)/(СекундВМинуте*МинутВЧасе*ЧасовВДне);
		
	КонецЕсли;
	
КонецФункции

// Возвращает массив дней, входящих в период.
//
// Параметры:
//   ДатаНачала - Дата
//   ДатаОкончания - Дата
//
// Возвращаемое значение:
//   Массив из Дата - Дни периода.
//
Функция МассивДатИзПериода(ДатаНачала, ДатаОкончания) Экспорт
	Результат = Новый Массив;
	
	ТекущийДень = НачалоДня(ДатаНачала);
	Пока ТекущийДень <= ДатаОкончания Цикл
		Результат.Добавить(ТекущийДень);
		ТекущийДень = ТекущийДень + 86400;
	КонецЦикла;
	
	Возврат Результат;
КонецФункции

// Проверяет использование объекта
//
// Параметры:
//  Параметры		- Структура - содержит объект использование которого нужно проверить
//  АдресХранилища	- Строка - адрес хранилища в которое будут помещен результат проверки.
//
Процедура ПроверитьИспользованиеОбъекта(Параметры, АдресХранилища) Экспорт
	
	ЕстьСсылки = ОбщегоНазначенияВызовСервера.ЕстьСсылкиНаОбъект(Параметры.Объект);
	
	ПоместитьВоВременноеХранилище(ЕстьСсылки, АдресХранилища);
	
КонецПроцедуры

// Возвращает ключ коллекции, имеющий указанное значение.
//
// Параметры:
// 	Коллекция - Структура -
// 	          - Соответствие -
//	          - ФиксированнаяСтруктура -
//	          - ФиксированноеСоответствие -
//  Значение - Произвольный - Указанное значение
//
// Возвращаемое значение:
//  Строка - 
Функция КлючКоллекцииПоЗначению(Коллекция, Значение) Экспорт
	
	Для Каждого КлючИЗначение Из Коллекция Цикл
		Если КлючИЗначение.Значение = Значение Тогда
			Возврат КлючИЗначение.Ключ;
		КонецЕсли;
	КонецЦикла;
	
	Возврат Неопределено;
	
КонецФункции

// Возвращает коллекцию, в которой ключи и значения поменяны местами.
//
// Параметры:
// 	Коллекция - Структура, Соответствие, ФиксированнаяСтруктура, ФиксированноеСоответствие -
// 	
// Возвращаемое значение:
//  Структура, Соответствие, ФиксированнаяСтруктура, ФиксированноеСоответствие -
Функция ПоменятьКлючИЗначениеКоллекции(Коллекция) Экспорт
	
	Если ТипЗнч(Коллекция) = Тип("Структура") ИЛИ ТипЗнч(Коллекция) = Тип("ФиксированнаяСтруктура") Тогда
		НоваяКоллекция = Новый Структура;
	ИначеЕсли ТипЗнч(Коллекция) = Тип("Соответствие") ИЛИ ТипЗнч(Коллекция) = Тип("ФиксированноеСоответствие") Тогда
		НоваяКоллекция = Новый Соответствие;
	Иначе
		Возврат Неопределено;
	КонецЕсли;
	
	Для Каждого КлючИЗначение Из Коллекция Цикл
		НоваяКоллекция.Вставить(КлючИЗначение.Значение, КлючИЗначение.Ключ);
	КонецЦикла;
	
	Если ТипЗнч(Коллекция) = Тип("ФиксированнаяСтруктура") Тогда
		НоваяКоллекция = Новый ФиксированнаяСтруктура(НоваяКоллекция);
	ИначеЕсли ТипЗнч(Коллекция) = Тип("ФиксированноеСоответствие") Тогда
		НоваяКоллекция = Новый ФиксированноеСоответствие(НоваяКоллекция);
	КонецЕсли;
	
	Возврат НоваяКоллекция;
	
КонецФункции

// Возвращает количество документов прописью.
//
// Параметры:
//  КоличествоДокументов - Число - Количество документов.
//
// Возвращаемое значение:
//  Строка - Количество документов прописью.
//
Функция ЧислоДокументовПрописью(КоличествоДокументов) Экспорт
	
	КоличествоПрописью = ЧислоПрописью(
		КоличествоДокументов,
		НСтр("ru = 'SN = Истина; FN = Ложь; FS = Ложь;';
			|en = 'SN = True; FN = False; FS = False;'"),
		НСтр("ru = 'документ,документа,документов,м,,,,,0';
			|en = 'document, documents,,,0'"));
	
	Поз = СтрНайти(КоличествоПрописью, НСтр("ru = 'документ';
											|en = 'document'"));
	Если Поз <> 0 Тогда
		КоличествоПрописью = Сред(КоличествоПрописью, Поз);
	КонецЕсли;
	
	КоличествоПрописью = Строка(КоличествоДокументов) + " " + НРег(КоличествоПрописью);
	
	Возврат КоличествоПрописью;
	
КонецФункции

// Возвращает описание типов по переданному типу
// 
// Параметры:
//	Тип - Тип - Тип значения
//
// Возвращаемое значение:
//	ОписаниеТипов - созданное на основании переданного типа описание типов.
//
Функция ОписаниеТиповПоТипу(Тип) Экспорт
	МассивТипов = Новый Массив;
	МассивТипов.Добавить(Тип);
	
	ОписаниеТипов = Новый ОписаниеТипов(МассивТипов);
	
	Возврат ОписаниеТипов;
КонецФункции

// Возвращает таблицу значений на основании массива структур
// 
// Параметры:
//	МассивСтруктур - Массив Из Структура - Массив структур, которые будут преобразованы в таблиц значений.
//										   Свойства структуры первого элемента массива определяют состав колонок результирующей таблицы.
//
// Возвращаемое значение:
//	ТаблицаЗначений - таблица значений, созданная из массива структур.
// 
Функция МассивВТаблицуЗначений(МассивСтруктур) Экспорт
	Таблица = Новый ТаблицаЗначений;
	// Создадим колонки по первой структуре массива
	Если ТипЗнч(МассивСтруктур) = Тип("Массив")
		И МассивСтруктур.Количество() <> 0 Тогда
		ПерваяСтруктура = МассивСтруктур[0];
		Для Каждого Свойство Из ПерваяСтруктура Цикл 
			Таблица.Колонки.Добавить(Свойство.Ключ, ОписаниеТиповПоТипу(ТипЗнч(Свойство.Значение)));
		КонецЦикла;
		
		Для Каждого Структура Из МассивСтруктур Цикл 
			НоваяСтрока = Таблица.Добавить();
			ЗаполнитьЗначенияСвойств(НоваяСтрока, Структура);
		КонецЦикла;
	КонецЕсли;
	
	Возврат Таблица;
КонецФункции

// Возвращает таблицу значений на основании соответствия структур.
// Свойства структуры первого элемента соответствия определяют состав колонок результирующей таблицы.
// 
// Параметры:
// 	 Соответствие - Соответствие - Соответствие структур, которое будут преобразовано в таблицу значений, где:
// 			* Ключ - Произвольный - является одной из колонок таблицы значений
// 			* Значение - Структура - Структура, которую требуется преобразовать к таблице значений
// 
// Возвращаемое значение:
// 	 ТаблицаЗначений
//
Функция СоответствиеВТаблицуЗначений(Соответствие) Экспорт
	
	Таблица = Новый ТаблицаЗначений;
	// Создадим колонки по первой структуре соответствия
	Если ТипЗнч(Соответствие) = Тип("Соответствие")
		И Соответствие.Количество() > 0 Тогда
		Для Каждого КлючИЗначение Из Соответствие Цикл 
			ПерваяСтруктура = КлючИЗначение.Значение;
			Прервать;
		КонецЦикла;
		Таблица.Колонки.Добавить("Ключ", ОписаниеТиповПоТипу(ТипЗнч(КлючИЗначение.Ключ)));
		Для Каждого Свойство Из ПерваяСтруктура Цикл 
			Таблица.Колонки.Добавить(Свойство.Ключ, ОписаниеТиповПоТипу(ТипЗнч(Свойство.Значение)));
		КонецЦикла;
		
		Для Каждого КлючИЗначение Из Соответствие Цикл 
			НоваяСтрока = Таблица.Добавить();
			НоваяСтрока.Ключ = КлючИЗначение.Ключ;
			ЗаполнитьЗначенияСвойств(НоваяСтрока, КлючИЗначение.Значение);
		КонецЦикла;
	КонецЕсли;
	
	Возврат Таблица;
	
КонецФункции

// Возвращает метаданные объекта по полному имени объекта метаданных
//
// Параметры:
//  МетаданныеСтрокой - Строка - Полный путь к метаданным реквизита как в дереве метаданных.
//                       Пример: "Документы.ПоступлениеБезналичныхДенежныхСредств.ТабличныеЧасти.РасшифровкаПлатежа.Реквизиты.Заказ"
//                               "РегистрыНакопления.ДвиженияКонтрагентДоходыРасходы.Измерения.ОбъектРасчетов".
//
// Возвращаемое значение:
//  ОбъектМетаданных - 
//
Функция МетаданныеПоИмени(МетаданныеСтрокой) Экспорт
	
	Возврат СвойствоМетаданных(Метаданные, СтрРазделить(МетаданныеСтрокой, "."));
	
КонецФункции

// Возвращает Истина, если включен режим отладки.
//
// Возвращаемое значение:
// 	 Булево -
Функция РежимОтладки() Экспорт
	
	УстановитьПривилегированныйРежим(Истина);
	РежимОтладки = ОбщегоНазначения.РежимОтладки()
		ИЛИ Константы.РежимОтладки.Получить();
	УстановитьПривилегированныйРежим(Ложь);
	
	Возврат РежимОтладки;
	
КонецФункции

// Устанавливает пометку удаления и формирует список сообщений об ошибках установки пометки удаления документов.
//
// Параметры:
//  Ссылки - Массив Из ДокументСсылка - Список документов.
// 
// Возвращаемое значение:
//   Структура - см. ОбщегоНазначенияКлиентСервер.ДобавитьОшибкуПользователю
//
Функция УстановитьПометкуУдаленияДокументов(Ссылки) Экспорт

	Перем СписокОшибок;
	ТекстНеЗаблокирован = НСтр("ru = '%1 - не удалось пометить на удаление документ, возможно документ редактируется другим пользователем.';
								|en = '%1 - cannot mark the document for deletion, maybe, the document is being edited by another user.'");

	Для Каждого Ссылка Из Ссылки Цикл
		ДокументОбъект = Ссылка.ПолучитьОбъект();
		Если ДокументОбъект = Неопределено Тогда
			Продолжить;
		КонецЕсли;
		Если ДокументОбъект.ПометкаУдаления Тогда
			Продолжить;
		КонецЕсли;
		
		Попытка
			ДокументОбъект.Заблокировать();
		Исключение
			
			ТекстОшибки = СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(ТекстНеЗаблокирован, СокрЛП(Ссылка)); 
			ОбщегоНазначенияКлиентСервер.ДобавитьОшибкуПользователю(СписокОшибок, Неопределено, ТекстОшибки, Неопределено);
			Продолжить;
			
		КонецПопытки;
		
		ДокументОбъект.УстановитьПометкуУдаления(Истина);
	КонецЦикла;
	Возврат СписокОшибок;

КонецФункции

// Перед попыткой непосредственного удаления документа устанавливает
// пометку на удаление, что позволяет отработать предусмотренным
// механизмам в документе.
// Формирует список сообщений об успешном удалении документов, либо
// об ошибках не позволяющих удалить документы.
//
// Параметры:
//  СсылкиНаУдаление - Массив Из ДокументСсылка - Список созданных документов.
//  МассивИсключаемыхОбъектов - Неопределено, Массив из ОбъектМетаданных - Список объектов метаданных, в случае наличия ссылок
//  на которые в удаляемых объектах, удаление отменяется.
// 
// Возвращаемое значение:
//   Неопределено, Структура - Содержит список сообщений. Состав ключей определяется в функции ОбщегоНазначенияКлиентСервер.ДобавитьОшибкуПользователю.
//
Функция УдалитьДокументы(СсылкиНаУдаление, МассивИсключаемыхОбъектов = Неопределено) Экспорт
	
	СписокОшибок = Неопределено;
	
	Если СсылкиНаУдаление.Количество() = 0 Тогда
		Возврат СписокОшибок;
	КонецЕсли;
	
	ТекстИмеютсяСсылки  = НСтр("ru = 'Не удалось удалить документ %1, так как на него имеются ссылки в %2.';
								|en = 'Cannot delete document %1 because it is referenced in %2.'");
	ТекстПомечен        = НСтр("ru = '%1 - помечен на удаление.';
								|en = '%1 - marked for deletion.'");
	ТекстУдален         = НСтр("ru = '%1 - удален.';
								|en = '%1 - deleted.'");
	ТекстНеЗаблокирован = НСтр("ru = '%1 - не удалось пометить на удаление документ, возможно документ редактируется другим пользователем.';
								|en = '%1 - cannot mark the document for deletion, maybe, the document is being edited by another user.'");
	
	МассивИменОбъектовМетаданных = Новый Массив();
	Для Каждого ДокументКУдалению Из СсылкиНаУдаление Цикл
		ИмяОбъектаМетаданных = ДокументКУдалению.Метаданные().ПолноеИмя();
		Если МассивИменОбъектовМетаданных.Найти(ИмяОбъектаМетаданных) = Неопределено Тогда
			МассивИменОбъектовМетаданных.Добавить(ИмяОбъектаМетаданных);
		КонецЕсли;
	КонецЦикла;
	ИменаОбъектовМетаданных = СтрСоединить(МассивИменОбъектовМетаданных, ",");
	
	Регистры = ОбщегоНазначенияУТПовтИсп.РегистрыСведенийПоМетаданнымИзмерений(ИменаОбъектовМетаданных, Истина);
	
	НазначенияЗаказов = НазначенияЗаказов(СсылкиНаУдаление);
	ОбщегоНазначенияКлиентСервер.ДополнитьМассив(СсылкиНаУдаление, НазначенияЗаказов);
	
	УстановитьПривилегированныйРежим(Истина);
	
	ТабСсылок = НайтиПоСсылкам(СсылкиНаУдаление);
	
	ВсегоСтрок = ТабСсылок.Количество();
	Для Счетчик = 1 По ВсегоСтрок Цикл
		Ссылка = ТабСсылок[ВсегоСтрок - Счетчик];
		
		Если Ссылка[0] = Ссылка[1]
			ИЛИ ЭтоЗаписьВедомогоРегистраСведений(Ссылка[1], Регистры)
			ИЛИ (ТипЗнч(МассивИсключаемыхОбъектов) = Тип("Массив")
				И ЭтоЗаписьИсключаемогоОбъекта(Ссылка[1], МассивИсключаемыхОбъектов)) Тогда
			
			ТабСсылок.Удалить(Ссылка);
			
		КонецЕсли;
		
	КонецЦикла;
	
	ПомечатьНаУдаление = Новый Массив();
	
	ВсегоСтрок = ТабСсылок.Количество();
	Для Счетчик = 1 По ВсегоСтрок Цикл
		Ссылка = ТабСсылок[ВсегоСтрок - Счетчик];
		
		Индекс = СсылкиНаУдаление.Найти(Ссылка[1]);
		Если Индекс = Неопределено Тогда
			
			Если ПомечатьНаУдаление.Найти(Ссылка[0]) = Неопределено Тогда
				
				ПомечатьНаУдаление.Добавить(Ссылка[0]);
				
				ТекстОшибки = СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(ТекстИмеютсяСсылки, СокрЛП(Ссылка[0]), СокрЛП(Ссылка[1])); 
				ОбщегоНазначенияКлиентСервер.ДобавитьОшибкуПользователю(СписокОшибок, Неопределено, ТекстОшибки, Неопределено);
				
			КонецЕсли;
			
			ТабСсылок.Удалить(Ссылка);
			
		КонецЕсли;
		
	КонецЦикла;
	
	ОбработкаЗавершена = Ложь;
	Пока Не ОбработкаЗавершена Цикл
		
		ОбработкаЗавершена = Истина;
		
		ВсегоСтрок = ТабСсылок.Количество();
		Для Счетчик = 1 По ВсегоСтрок Цикл
			Ссылка = ТабСсылок[ВсегоСтрок - Счетчик];
			
			Если ПомечатьНаУдаление.Найти(Ссылка[0]) <> Неопределено Тогда
				
				Если ПомечатьНаУдаление.Найти(Ссылка[1]) = Неопределено Тогда
					
					ПомечатьНаУдаление.Добавить(Ссылка[1]);
					
				КонецЕсли;
				
				ТабСсылок.Удалить(Ссылка);
				ОбработкаЗавершена = Ложь;
				
			КонецЕсли;
			
		КонецЦикла;
		
	КонецЦикла;
	
	Для Каждого Ссылка Из СсылкиНаУдаление Цикл
		
		ДокументОбъект = Ссылка.ПолучитьОбъект();
		Если ДокументОбъект = Неопределено Тогда
			Продолжить;
		КонецЕсли;
		
		Попытка
			ДокументОбъект.Заблокировать();
		Исключение
			
			Если ПомечатьНаУдаление.Найти(Ссылка) = Неопределено Тогда
				ПомечатьНаУдаление.Добавить(Ссылка);
			КонецЕсли;
			
			ТекстОшибки = СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(ТекстНеЗаблокирован, СокрЛП(Ссылка)); 
			ОбщегоНазначенияКлиентСервер.ДобавитьОшибкуПользователю(СписокОшибок, Неопределено, ТекстОшибки, Неопределено);
			Продолжить;
			
		КонецПопытки;
		
		ДокументОбъект.УстановитьПометкуУдаления(Истина);
		Если ПомечатьНаУдаление.Найти(Ссылка) <> Неопределено Тогда
			
			ТекстОшибки = СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(ТекстПомечен, СокрЛП(Ссылка));
			ОбщегоНазначенияКлиентСервер.ДобавитьОшибкуПользователю(СписокОшибок, Неопределено, ТекстОшибки, Неопределено);
			
		КонецЕсли;
		
	КонецЦикла;
	
	Для Каждого Ссылка Из ПомечатьНаУдаление Цикл
		
		Индекс = СсылкиНаУдаление.Найти(Ссылка);
		Если Индекс <> Неопределено Тогда
			СсылкиНаУдаление.Удалить(Индекс);
		КонецЕсли;
		
	КонецЦикла;
	
	Для Каждого Ссылка Из СсылкиНаУдаление Цикл
		
		ТекстОшибки = СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(ТекстУдален, СокрЛП(Ссылка)); 
		ОбщегоНазначенияКлиентСервер.ДобавитьОшибкуПользователю(СписокОшибок, Неопределено, ТекстОшибки, Неопределено);
		
	КонецЦикла;
	
	УдалитьОбъекты(СсылкиНаУдаление, Ложь);
	
	УстановитьПривилегированныйРежим(Ложь);
	
	Возврат СписокОшибок;
	
КонецФункции

// Возвращает структуру с ключами, соответствующими колонкам таблицы значений.
// Значения в структуре заполняются значениями полей из переданной строки таблицы.
//
// Параметры:
//	ТекущаяСтрока - СтрокаТаблицыЗначений -
//
// Возвращаемое значение:
//	Структура -
//
Функция ПреобразоватьСтрокуТаблицыВСтруктуру(ТекущаяСтрока) Экспорт
	
	Результат = Новый Структура;
	
	Для Каждого Колонка Из ТекущаяСтрока.Владелец().Колонки Цикл
		Результат.Вставить(Колонка.Имя, ТекущаяСтрока[Колонка.Имя]);
	КонецЦикла;
	
	Возврат Результат;
	
КонецФункции

// Устанавливает параметры запроса из переданной структуры.
//
// Параметры:
//	Запрос - Запрос - запрос, параметры которого надо установить
//	ПараметрыЗапроса - Структура - структура с устанавливаемыми параметрами запроса.
//
Процедура УстановитьПараметрыЗапроса(Запрос, ПараметрыЗапроса) Экспорт
	
	Если НЕ ЗначениеЗаполнено(ПараметрыЗапроса) Тогда
		Возврат;
	КонецЕсли;
	
	Для Каждого КлючИЗначение Из ПараметрыЗапроса Цикл
		Запрос.УстановитьПараметр(КлючИЗначение.Ключ, КлючИЗначение.Значение);
	КонецЦикла;
	
КонецПроцедуры

// Получает макет в метаданных и возвращает его
//
// Параметры:
//  ИмяМакетаИлиАдрес - Строка - полное имя макета. Например, Документ.РеализацияТоваровУслуг.ДанныеШаблонаСообщений 
// 
// Возвращаемое значение:
//  ТабличныйДокумент, ТекстовыйДокумент, СхемаКомпоновкиДанных -
//
Функция МакетПоИмени(ИмяМакетаИлиАдрес) Экспорт
	
	ПоложениеТочки = СтрНайти(ИмяМакетаИлиАдрес, ".",,,2);
	
	Если ПоложениеТочки = 0 Тогда
		ПоложениеТочки = СтрНайти(ИмяМакетаИлиАдрес, ".",,,1);
		
		ИмяМакета    = Прав(ИмяМакетаИлиАдрес, СтрДлина(ИмяМакетаИлиАдрес) - ПоложениеТочки); 
		Результат = ПолучитьОбщийМакет(ИмяМакета);
	Иначе
		ИмяМенеджера = Лев(ИмяМакетаИлиАдрес, ПоложениеТочки);
		ИмяМакета    = Прав(ИмяМакетаИлиАдрес, СтрДлина(ИмяМакетаИлиАдрес) - ПоложениеТочки); 
		
		МенеджерОбъекта = ОбщегоНазначения.МенеджерОбъектаПоПолномуИмени(ИмяМенеджера);
		
		Результат = МенеджерОбъекта.ПолучитьМакет(ИмяМакета);
	КонецЕсли;
	
	Возврат Результат;
	
КонецФункции

// Свернуть табличную часть объекта
// По умолчанию все числовые колонки попадают в колонки суммирования. Те числовые колонки,
// которые должны попасть в колонки группировки, нужно перечислить в параметре КолонкиГруппировок.
// Нечисловые колонки перечислять в КолонкиГруппировки не нужно.
// 
// Параметры:
//  Объект - ДокументОбъект - 
//	       - СправочникОбъект - 
//		   - ПланВидовХарактеристикОбъект - 
//         - ПланОбменаОбъект - Объект, содержащий табличную часть 
//  ИмяТЧ			   - Строка - имя табличной части, которую нужно свернуть
//  КолонкиГруппировок - Массив Из Строка -
//                     - Строка - Массив строк с именами числовых колонок или строка с именами через запятую,
//  						      которые нужно включить в колонки группировки, а не суммирования.
//
Процедура СвернутьТабличнуюЧасть(Объект, ИмяТЧ, Знач КолонкиГруппировок = Неопределено) Экспорт
	
	Если КолонкиГруппировок = Неопределено Тогда
		КолонкиГруппировок = Новый Массив;
	ИначеЕсли ТипЗнч(КолонкиГруппировок) = Тип("Строка") Тогда
		КолонкиГруппировок = СтрРазделить(КолонкиГруппировок, ",", Ложь);
	КонецЕсли;
	
	КолонкиСуммирования = Новый Массив;
	
	МетаданныеДокумента = Объект.Метаданные();
	
	Для Каждого Колонка Из МетаданныеДокумента.ТабличныеЧасти[ИмяТЧ].Реквизиты Цикл
		Если ТипЗнч(Колонка.Тип.ПривестиЗначение()) = Тип("Число") Тогда
			Если КолонкиГруппировок.Найти(Колонка.Имя)  = Неопределено Тогда
				КолонкиСуммирования.Добавить(Колонка.Имя);
			КонецЕсли;
		Иначе
			КолонкиГруппировок.Добавить(Колонка.Имя);	
		КонецЕсли;
	КонецЦикла;
	
	ТабличнаяЧасть = Объект[ИмяТЧ]; // ТабличнаяЧасть - 
	ТабличнаяЧасть.Свернуть(СтрСоединить(КолонкиГруппировок, ","), СтрСоединить(КолонкиСуммирования,","));
	
КонецПроцедуры

// Проверяет соответствие функции переданному отбору
//
// Параметры:
//  Ссылка	 - ЛюбаяСсылка -
//  Отбор	 - Структура Из КлючИЗначение - Где:
//  			* Ключ - Строка - имя реквизита
//  			* Значение - Произвольный - значение реквизита, или массив значений реквизита
// 
// Возвращаемое значение:
//  Булево 
//
Функция СсылкаСоответствуетОтбору(Ссылка, Отбор) Экспорт
	
	ИменаРеквизитов = Новый Массив;
	
	Для Каждого КлючЗначение Из Отбор Цикл
		
		ИменаРеквизитов.Добавить(КлючЗначение.Ключ);
		
	КонецЦикла;

	ЗначенияРеквизитов = ОбщегоНазначения.ЗначенияРеквизитовОбъекта(Ссылка, СтрСоединить(ИменаРеквизитов, ","));
	
	Для Каждого КлючЗначение Из Отбор Цикл
		
		ЗначениеРеквизита = ЗначенияРеквизитов[КлючЗначение.Ключ];
		
		Если ТипЗнч(КлючЗначение.Значение) = Тип("Массив")
			Или ТипЗнч(КлючЗначение.Значение) = Тип("ФиксированныйМассив") Тогда
			
			Если КлючЗначение.Значение.Найти(ЗначениеРеквизита) = Неопределено Тогда
				Возврат Ложь;
			КонецЕсли;
			
		ИначеЕсли КлючЗначение.Значение <> ЗначениеРеквизита Тогда
			
			Возврат Ложь;
			
		КонецЕсли;
		
	КонецЦикла;
	
	Возврат Истина;
	
КонецФункции

// Выполняет проверку на соответствие операций создаваемого документа операции распоряжения.
//
// Параметры:
//	РаспоряжениеСсылка    - ДокументСсылка - ссылка распоряжения, на основании которого осуществляется создание документа.
//	ИмяДокумента          - Строка      - имя документа, для которого определяются допустимые операции.
//	ХозяйственнаяОперация - ПеречислениеСсылка.ХозяйственныеОперации - хозяйственная операция, для которой выполняется проверка
//
// Возвращаемое значение:
//	Булево - Истина, возможно создание документа на основании распоряжения.
//
Функция ПроверитьОперациюРаспоряжения(РаспоряжениеСсылка, ИмяДокумента, ХозяйственнаяОперация = Неопределено) Экспорт
	
	ДопустимыеОперации = ДопустимыеХозяйственныеОперацииДокумента(ИмяДокумента);
	
	Если ЗначениеЗаполнено(ХозяйственнаяОперация) Тогда
		ОперацияДокумента = ХозяйственнаяОперация;
	Иначе
		ОперацияДокумента  = ОбщегоНазначения.ЗначениеРеквизитаОбъекта(РаспоряжениеСсылка, "ХозяйственнаяОперация");
	КонецЕсли;
	
	Если ДопустимыеОперации.Найти(ОперацияДокумента) = Неопределено Тогда
		ШаблонСтроки = НСтр("ru = 'Невозможно оформить документ ""%1"" на основании распоряжения %2 с операцией ""%3"".';
							|en = 'Cannot register the ""%1"" document based on the %2 reference with the ""%3"" operation.'");
		
		ТекстСообщения = СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(ШаблонСтроки,
											Метаданные.Документы[ИмяДокумента].Синоним,
											РаспоряжениеСсылка,
											ОперацияДокумента);
		
		ОбщегоНазначенияКлиентСервер.СообщитьПользователю(ТекстСообщения,РаспоряжениеСсылка);
		
		Возврат Ложь;
	Иначе
		Возврат Истина;
	КонецЕсли;
	
КонецФункции

// Возвращает массив с хозяйственными операциями, допустимые для документа по функциональным опциям.
//
// Параметры:
//	ИмяДокумента - Строка - имя документа, для которого определяются допустимые операции
//
// Возвращаемое значение:
//	Массив Из ПеречислениеСсылка.ХозяйственныеОперации -
//
Функция ДопустимыеХозяйственныеОперацииДокумента(ИмяДокумента) Экспорт
	
	Запрос = Новый Запрос;
	Запрос.УстановитьПараметр("ЗначениеПустойСсылки", Документы[ИмяДокумента].ПустаяСсылка());
	
	Запрос.Текст = 
	"ВЫБРАТЬ
	|	ЕСТЬNULL(НастройкиХозяйственныхОперацийФункциональныеОпции.ИмяФункциональнойОпции, """") КАК ИмяФункциональнойОпции,
	|	НастройкиХозяйственныхОперацийДокументы.Ссылка.ХозяйственнаяОперация                     КАК ХозяйственнаяОперация
	|ИЗ
	|	Справочник.НастройкиХозяйственныхОпераций.Документы КАК НастройкиХозяйственныхОперацийДокументы
	|		ВНУТРЕННЕЕ СОЕДИНЕНИЕ Справочник.ИдентификаторыОбъектовМетаданных КАК ИдентификаторыОбъектовМетаданных
	|		ПО (НастройкиХозяйственныхОперацийДокументы.ИдентификаторОбъектаМетаданных = ИдентификаторыОбъектовМетаданных.Ссылка)
	|			И (ИдентификаторыОбъектовМетаданных.ЗначениеПустойСсылки = &ЗначениеПустойСсылки)
	|
	|		ЛЕВОЕ СОЕДИНЕНИЕ Справочник.НастройкиХозяйственныхОпераций.ФункциональныеОпции КАК НастройкиХозяйственныхОперацийФункциональныеОпции
	|		ПО (НастройкиХозяйственныхОперацийДокументы.Ссылка = НастройкиХозяйственныхОперацийФункциональныеОпции.Ссылка)
	|
	|УПОРЯДОЧИТЬ ПО
	|	ИмяФункциональнойОпции";
	
	Выборка = Запрос.Выполнить().Выбрать();
	
	ДопустимыеОперации = Новый СписокЗначений;
	
	Пока Выборка.СледующийПоЗначениюПоля("ИмяФункциональнойОпции") Цикл
		
		ПолноеИмяФО = СтрШаблон("ФункциональнаяОпция.%1", Выборка.ИмяФункциональнойОпции);
		ЕстьФО = ЗначениеЗаполнено(Выборка.ИмяФункциональнойОпции)
			И Метаданные.НайтиПоПолномуИмени(ПолноеИмяФО) <> Неопределено;
		Если Не ЕстьФО
			Или ПолучитьФункциональнуюОпцию(Выборка.ИмяФункциональнойОпции) Тогда
			
			Пока Выборка.Следующий() Цикл
				Если ДопустимыеОперации.НайтиПоЗначению(Выборка.ХозяйственнаяОперация) = Неопределено Тогда
					ДопустимыеОперации.Добавить(Выборка.ХозяйственнаяОперация);
				КонецЕсли;
			КонецЦикла;
			
		КонецЕсли;
		
	КонецЦикла;
	
	ДопустимыеОперации.СортироватьПоЗначению();
	
	Возврат ДопустимыеОперации.ВыгрузитьЗначения();
	
КонецФункции

// Возвращает описание типа денежного поля.
//
// Параметры:
//  ЗнакПоля - ДопустимыйЗнак - допустимый знак денежного поля (по умолчанию Любой)
//
// Возвращаемое значение:
//  ОписаниеТипов - Описание типа денежного поля
//
Функция ОписаниеТипаДенежногоПоля(ЗнакПоля = Неопределено) Экспорт
	
	Возврат Неопределено;
	
КонецФункции

// Возвращает разрядность описания типа денежного поля.
//
// Параметры:
//  ЗнакПоля - ДопустимыйЗнак	 - допустимый знак денежного поля (по умолчанию Любой)
// 
// Возвращаемое значение:
//  Структура - Ключи:
// 		* Разрядность - Число -
//		* РазрядностьДробнойЧасти - Число -
//
Функция РазрядностьДенежногоПоля(ЗнакПоля = Неопределено) Экспорт
	
	Результат = Новый Структура("Разрядность, РазрядностьДробнойЧасти");
	ЗаполнитьЗначенияСвойств(Результат, ОписаниеТипаДенежногоПоля(ЗнакПоля).КвалификаторыЧисла);
	
	Возврат Результат;
	
КонецФункции
 
// Возвращает общий модуль локализации объекта по полному имени объекта метаданных.
//
// Параметры:
//  ПолноеИмя - Строка - полное имя объекта метаданных. Пример: "Справочник.Организации".
//
// Возвращаемое значение:
//  ОбщийМодуль - общий модуль локализации объекта.
//
Функция ПолучитьМодульЛокализации(ПолноеИмя) Экспорт
	ИмяМодуляЛокализации = "";
	ЧастиИмени = СтрРазделить(ПолноеИмя, ".");
	Если ЧастиИмени.Количество() > 1 Тогда
		ИмяМодуляЛокализации = ЧастиИмени[1] + "Локализация";
	Иначе
		ИмяМодуляЛокализации = ПолноеИмя + "Локализация";
	КонецЕсли;
	ОбщийМодульЛокализации = Неопределено;
	
	Если Метаданные.ОбщиеМодули.Найти(ИмяМодуляЛокализации) <> Неопределено Тогда
		ОбщийМодульЛокализации = Вычислить(ИмяМодуляЛокализации); // ВычислитьВБезопасномРежиме не требуется, т.к. проверка надежная.
	КонецЕсли;
	
	Если ТипЗнч(ОбщийМодульЛокализации) = Тип("ОбщийМодуль") Тогда
		Возврат ОбщийМодульЛокализации
	Иначе
		Возврат Неопределено
	КонецЕсли
	
КонецФункции

// Возвращает массив уникальных значений из колонки таблицы
//
// Параметры:
//  Таблица    - ТаблицаЗначений - 
//	           - ДанныеФормыКоллекция - таблица, из которой необходимо выбрать данные
//  ИмяКолонки - Строка - имя колонки таблицы значений, из которой необходимо выбрать значения.
// 
// Возвращаемое значение:
//  Массив Из Произвольный - Набор уникальных значений.
//
Функция ВыгрузитьЗначенияКолонки(Таблица, ИмяКолонки) Экспорт
	
	Если ТипЗнч(Таблица) = Тип("ТаблицаЗначений") Тогда
		ТаблицаКопия = Таблица.Скопировать(, ИмяКолонки);
	Иначе
		ТаблицаКопия = Таблица.Выгрузить(, ИмяКолонки);
	КонецЕсли;
	
	ТаблицаКопия.Свернуть(ИмяКолонки);
	
	Возврат ТаблицаКопия.ВыгрузитьКолонку(0);
	
КонецФункции

// Возвращает параметры рабочего места в зависимости от установленных отборов по операциям и типам документов.
//
// Параметры:
//  ТаблицаХозОперацииИТипыДокументов - ТаблицаЗначений - таблица с описанием метаданных, используемых в рабочем месте
//  КлючНазначенияФормыПоУмолчанию	 - Строка - параметр, определяющий раздел рабочего места, например, "ВнутреннееТовародвижение"
//  ЗаголовокФормыПоУмолчанию		 - Строка - заголовок рабочего места по умолчанию, например, "Внутреннее товародвижение".
// 
// Возвращаемое значение:
//  Структура - Содержит ключи:
//		* КлючНазначенияИспользования - Строка -
//		* ЗаголовокРабочегоМеста - Строка -
//
Функция ДанныеРабочегоМеста(ТаблицаХозОперацииИТипыДокументов, КлючНазначенияФормыПоУмолчанию, ЗаголовокФормыПоУмолчанию) Экспорт
	
	ОтобранныеХозОперацииИТипыДокументов = ТаблицаХозОперацииИТипыДокументов.Скопировать(Новый Структура("Отбор",Истина),
		"КлючНазначенияИспользования,ЗаголовокРабочегоМеста");
	ОтобранныеХозОперацииИТипыДокументов.Свернуть("КлючНазначенияИспользования,ЗаголовокРабочегоМеста");
	
	ДанныеРабочегоМеста = Новый Структура("КлючНазначенияИспользования,ЗаголовокРабочегоМеста",
		КлючНазначенияФормыПоУмолчанию, ЗаголовокФормыПоУмолчанию);
		
	Если ОтобранныеХозОперацииИТипыДокументов.Количество() = 1 Тогда
		Если ЗначениеЗаполнено(ОтобранныеХозОперацииИТипыДокументов[0].КлючНазначенияИспользования) Тогда
			ДанныеРабочегоМеста.КлючНазначенияИспользования = ОтобранныеХозОперацииИТипыДокументов[0].КлючНазначенияИспользования;	
		КонецЕсли;
		Если ЗначениеЗаполнено(ОтобранныеХозОперацииИТипыДокументов[0].ЗаголовокРабочегоМеста) Тогда
			ДанныеРабочегоМеста.ЗаголовокРабочегоМеста = ОтобранныеХозОперацииИТипыДокументов[0].ЗаголовокРабочегоМеста;	
		КонецЕсли;			
	КонецЕсли;
	
	Возврат ДанныеРабочегоМеста;
	
КонецФункции

// Добавляет колонки в таблицу значений
// 
// Параметры:
// 	Объект - ТаблицаЗначений, ДеревоЗначений - объект, в который нужно добавить колонки
// 	Колонки - Строка - названия колонок, разделенные запятыми.
Процедура ДобавитьКолонки(Объект, Колонки) Экспорт
	
	МассивКолонок = СтрРазделить(Колонки, ",", Ложь);
	Для Каждого Колонка Из МассивКолонок Цикл
		Объект.Колонки.Добавить(СокрЛП(Колонка));
	КонецЦикла;
	
КонецПроцедуры

// Добавляет запись в таблицу значений
// 
// Параметры:
// 	Таблица - ТаблицаЗначений - таблица значений, в которую будет добавлена запись
// 	Значение1 - Произвольный - значение, подставляемое в соответствующую колонку в порядке следования.
// 	Значение2 - Произвольный - значение, подставляемое в соответствующую колонку в порядке следования.
// 	Значение3 - Произвольный - значение, подставляемое в соответствующую колонку в порядке следования.
// 	Значение4 - Произвольный - значение, подставляемое в соответствующую колонку в порядке следования.
// 	Значение5 - Произвольный - значение, подставляемое в соответствующую колонку в порядке следования.
// 	Значение6 - Произвольный - значение, подставляемое в соответствующую колонку в порядке следования.
// 	Значение7 - Произвольный - значение, подставляемое в соответствующую колонку в порядке следования.
// 	Значение8 - Произвольный - значение, подставляемое в соответствующую колонку в порядке следования.
// 	Значение9 - Произвольный - значение, подставляемое в соответствующую колонку в порядке следования.
Процедура ДобавитьЗапись(Таблица, Значение1, Значение2=Неопределено, Значение3=Неопределено,
	Значение4=Неопределено, Значение5=Неопределено, Значение6=Неопределено, Значение7=Неопределено,
	Значение8=Неопределено, Значение9=Неопределено) Экспорт
	
	НовЗапись = Таблица.Добавить();
	НовЗапись[0] = Значение1;
	Если Значение2 <> Неопределено Тогда
		НовЗапись[1] = Значение2;
	КонецЕсли; 
	Если Значение3 <> Неопределено Тогда
		НовЗапись[2] = Значение3;
	КонецЕсли;
	Если Значение4 <> Неопределено Тогда
		НовЗапись[3] = Значение4;
	КонецЕсли;
	Если Значение5 <> Неопределено Тогда
		НовЗапись[4] = Значение5;
	КонецЕсли;
	Если Значение6 <> Неопределено Тогда
		НовЗапись[5] = Значение6;
	КонецЕсли;
	Если Значение7 <> Неопределено Тогда
		НовЗапись[6] = Значение7;
	КонецЕсли;
	Если Значение8 <> Неопределено Тогда
		НовЗапись[7] = Значение8;
	КонецЕсли;
	Если Значение9 <> Неопределено Тогда
		НовЗапись[8] = Значение9;
	КонецЕсли;

КонецПроцедуры

// Проверяет, что используемая версия платформы не ниже указанной.
//
// Параметры:
//	Версия - Строка - номер версии платформы.
//
// Возвращаемое значение:
//	Булево - Истина, если используемая версия не младше указанной в параметре Версия.
//
Функция ВерсияПлатформыНеНижеУказанной(Версия) Экспорт
	
	СистемнаяИнформация = Новый СистемнаяИнформация;
	
	Возврат (ОбщегоНазначенияКлиентСервер.СравнитьВерсии(СистемнаяИнформация.ВерсияПриложения, Версия) >= 0);
	
КонецФункции
#КонецОбласти

#Область ПоискВТаблице

// Выполняет нумерацию строк таблицы значений. Для нумерации используется колонка ПорядковыйНомер.
// Если колонка с таким именем отсутствует в переданной таблице, то она будет добавлена.
//
// Параметры:
//  Таблица	- ТаблицаЗначений - таблица, строки которой будут пронумерованы.
//
Процедура ДобавитьВТаблицуПорядковыйНомерСтрок(Таблица) Экспорт
	
	ПронумероватьТаблицуЗначений(Таблица, "ПорядковыйНомер");
	
КонецПроцедуры

// Заполняет значение колонки ПорядковыйНомер в новой строке таблицы значений,
// строки которой пронумерованы (см. ДобавитьВТаблицуПорядковыйНомерСтрок).
//
// Параметры:
//  Таблица		 - ТаблицаЗначений - таблица с пронумерованными строками.
//  НоваяСтрока	 - СтрокаТаблицыЗначений - строка в которой необходимо заполнить порядковый номер.
//
Процедура ЗаполнитьПорядковыйНомерВНовойСтроке(Таблица, НоваяСтрока) Экспорт
	
	НоваяСтрока.ПорядковыйНомер = Таблица.Количество() + 1;
	
КонецПроцедуры

// Осуществляет поиск строк в таблице значений с сохранением их порядка.
//
// Параметры:
//  Таблица				 - ТаблицаЗначений - таблица в которой необходимо выполнить поиск.
//  УсловиеПоиска		 - Структура - условие поиска строк.
//  СтрокиПронумерованы	 - Булево - Истина, если строки таблицы были предварительно пронумерованы
//		(см. ДобавитьВТаблицуПорядковыйНомерСтрок).
// 
// Возвращаемое значение:
//  Массив - найденные строки.
//
Функция НайтиСтрокиССохранениемПорядка(Таблица, УсловиеПоиска, СтрокиПронумерованы = Ложь) Экспорт
	
	НайденныеСтроки = Таблица.НайтиСтроки(УсловиеПоиска);
	
	Если НайденныеСтроки.Количество() > 1 Тогда
		
		Если СтрокиПронумерованы Тогда
			
			Результат = УпорядочитьПронумерованныеСтроки(Таблица, НайденныеСтроки);
			
		Иначе
			
			Результат = УпорядочитьНеПронумерованныеСтроки(Таблица, НайденныеСтроки);
			
		КонецЕсли;
		
	Иначе
		
		Результат = НайденныеСтроки;
		
	КонецЕсли;
	
	Возврат Результат;
	
КонецФункции

// Возвращает значения реквизитов переданной ссылки, если ссылка пустая - возвращается значение по умолчанию 
// для каждого типа реквизита.
//
// Параметры:
//	Ссылка - ДокументСсылка - ссылка на объект информационной базы.
//	Реквизиты	 - Строка -
//	             - Массив Из Строка - имена реквизитов через запятую или массив имен реквизитов.
//
// Возвращаемое значение:
//	Структура - структура, свойствами которой являются реквизиты ссылки объекта информационной базы,
//							а значениями - значения реквизитов ссылки.
//
Функция ЗначенияРеквизитовОбъектаПоУмолчанию(Ссылка, Реквизиты) Экспорт
	
	Если ЗначениеЗаполнено(Ссылка) Тогда
		Результат = ОбщегоНазначения.ЗначенияРеквизитовОбъекта(Ссылка, Реквизиты);
	Иначе
		Если ТипЗнч(Реквизиты) = Тип("Строка") Тогда 
			Результат = Новый Структура(Реквизиты);
		ИначеЕсли ТипЗнч(Реквизиты) = Тип("Массив") Тогда
			Результат = Новый Структура(СтрСоединить(Реквизиты, ","));
		Иначе
			ТекстИсключения = НСтр("ru = 'Неверный тип параметра ""Реквизиты""';
									|en = 'Invalid type of ""Attributes"" parameter'");
			ВызватьИсключение ТекстИсключения;
		КонецЕсли;
		
		МетаданныеОбъекта = Метаданные.НайтиПоТипу(ТипЗнч(Ссылка)); // ОбъектМетаданныхДокумент - 
		
		Если МетаданныеОбъекта = Неопределено Тогда
			ТекстИсключения = НСтр("ru = 'Переданное значение не является ссылкой';
									|en = 'The transferred value is not a reference'");
			ВызватьИсключение ТекстИсключения;
		КонецЕсли;
		
		Для Каждого КлючЗначение Из Результат Цикл
			
			МетаданныеРеквизита = МетаданныеОбъекта.Реквизиты.Найти(КлючЗначение.Ключ);
			
			Если МетаданныеРеквизита = Неопределено Тогда
				
				Для Каждого СтандартныйРеквизит Из  МетаданныеОбъекта.СтандартныеРеквизиты Цикл
					Если СтандартныйРеквизит.Имя = КлючЗначение.Ключ Тогда
						МетаданныеРеквизита = СтандартныйРеквизит;
						Прервать;
					КонецЕсли;
				КонецЦикла;
				
				Если МетаданныеРеквизита = Неопределено Тогда 
					
					ТекстИсключения = НСтр("ru = 'Реквизит %ИмяРеквизита% не найден';
											|en = 'Attribute %ИмяРеквизита% is not found'");
					ТекстИсключения = СтрЗаменить(ТекстИсключения, "%ИмяРеквизита%", КлючЗначение.Ключ);
					ВызватьИсключение ТекстИсключения;
				КонецЕсли;
				
			КонецЕсли;
			
			Результат[КлючЗначение.Ключ] = МетаданныеРеквизита.Тип.ПривестиЗначение();	
			
		КонецЦикла;
		
	КонецЕсли;
	
	Возврат Результат;
	
КонецФункции

// Параметры:
// 	Ссылка - см. ОбщегоНазначения.ЗначениеРеквизитаОбъекта.Ссылка
// 	ИмяРеквизита - см. ОбщегоНазначения.ЗначениеРеквизитаОбъекта.ИмяРеквизита
// Возвращаемое значение:
//  Булево - значение реквизита, прочитанного из информационной базы по ссылке на объект
//  		см. ОбщегоНазначения.ЗначениеРеквизитаОбъекта. Если полученное значение не имеет тип булево, 
//  		возвращается значение Ложь.
//
Функция ЗначениеРеквизитаОбъектаТипаБулево(Ссылка, ИмяРеквизита) Экспорт
	УстановитьПривилегированныйРежим(Истина);
	Результат = ОбщегоНазначения.ЗначениеРеквизитаОбъекта(Ссылка, ИмяРеквизита);
	Если ТипЗнч(Результат) <> Тип("Булево") Тогда
		Результат = Ложь;
	КонецЕсли;
	УстановитьПривилегированныйРежим(Ложь);	
	Возврат Результат
КонецФункции

// Обходит реквизиты и стандартные реквизиты объекта метаданных и создает структуру с такими же полями.
//
// Параметры:
//	ОбъектМетаданных - ОбъектМетаданных - объект метаданных, используемый в качестве источника копирования свойств.
//
// Возвращаемое значение:
//	Структура - структура, свойствами которой являются реквизиты источника копирования.
//
Функция СтруктураСоСвойствамиОбъектаМетаданных(ОбъектМетаданных) Экспорт
	
	СтруктураСоСвойствамиОбъектаМетаданных = Новый Структура;
	
	Для Каждого Реквизит Из ОбъектМетаданных.Реквизиты Цикл
		СтруктураСоСвойствамиОбъектаМетаданных.Вставить(Реквизит.Имя, Реквизит.Тип.ПривестиЗначение());
	КонецЦикла;
	
	Для Каждого Реквизит Из ОбъектМетаданных.СтандартныеРеквизиты Цикл
		СтруктураСоСвойствамиОбъектаМетаданных.Вставить(Реквизит.Имя, Реквизит.Тип.ПривестиЗначение());
	КонецЦикла;
	
	Возврат СтруктураСоСвойствамиОбъектаМетаданных;
	
КонецФункции

// Получить максимальную дату однотипных документов.
// 
// Параметры:
//  МассивДокументов - Массив из ДокументСсылка - Массив однотипных документов
// 
// Возвращаемое значение:
//  Дата - максимальная дата документов, если был передлан не пустой массив и ТекущаяДатаСеанса если пустой
Функция ПолучитьМаксимальнуюДатуДокументов(МассивДокументов) Экспорт
	
	МаксимальнаяДата = ТекущаяДатаСеанса();

	Если МассивДокументов.Количество() = 0 Тогда
		Возврат МаксимальнаяДата;
	КонецЕсли;
	
	ТекстЗапроса = "ВЫБРАТЬ
	|	МАКСИМУМ(Документ.Дата) КАК Дата
	|ИЗ
	|	&ПолноеИмяОбъектаМетаданных КАК Документ
	|ГДЕ
	|	Документ.Ссылка В (&МассивДокументов)";
	
	ТекстЗапроса = СтрЗаменить(ТекстЗапроса, "&ПолноеИмяОбъектаМетаданных", МассивДокументов[0].Метаданные().ПолноеИмя());
	
	Запрос = Новый Запрос;
	Запрос.Текст = ТекстЗапроса;
	
	Запрос.УстановитьПараметр("МассивДокументов", МассивДокументов);

	Результат = Запрос.Выполнить().Выгрузить();
	
	Если Результат.Количество() Тогда
		МаксимальнаяДата = Результат[0].Дата;
	КонецЕсли;
	
	Возврат МаксимальнаяДата;
	
КонецФункции

#КонецОбласти

#Область НастройкиФорм

// Устанавливает параметры контекстных функциональных опций формы.
//
// Параметры:
// 	Форма - ФормаКлиентскогоПриложения - 
// 	ПараметрыНастройки - Структура -
//
Процедура НастроитьФормуПоПараметрам(Форма, ПараметрыНастройки) Экспорт
	
	УстановитьПривилегированныйРежим(Истина);
	
	Запрос = Новый Запрос;
	ТекстЗапроса = 
	"ВЫБРАТЬ
	|	НастройкиФорм.Ссылка
	|ИЗ
	|	Справочник.ПараметрыКонтекстныхФункциональныхОпций КАК НастройкиФорм
	|ГДЕ
	|	ИСТИНА";
	
	Для каждого ПараметрНастройки Из ПараметрыНастройки Цикл
	
		ТекстЗапроса = ТекстЗапроса + " 
		|	И НастройкиФорм." + ПараметрНастройки.Ключ + " = &" + ПараметрНастройки.Ключ;
		Запрос.УстановитьПараметр(ПараметрНастройки.Ключ, ПараметрНастройки.Значение);
	
	КонецЦикла;
	
	Запрос.Текст = ТекстЗапроса;
	
	Выборка = Запрос.Выполнить().Выбрать();
	
	Если Выборка.Следующий() Тогда
		
		Настройка = Выборка.Ссылка;
		
	Иначе
		
		СправочникОбъект = Справочники.ПараметрыКонтекстныхФункциональныхОпций.СоздатьЭлемент();
		
		ЗаполнитьЗначенияСвойств(СправочникОбъект, ПараметрыНастройки);
		
		СправочникОбъект.Записать();
		
		Настройка = СправочникОбъект.Ссылка;
		
	КонецЕсли;
	
	УстановитьПривилегированныйРежим(Ложь);
	
	Форма.УстановитьПараметрыФункциональныхОпцийФормы(Новый Структура("НастройкаФормы", Настройка));
	
КонецПроцедуры

// Параметры:
// 	Форма - ФормаКлиентскогоПриложения - 
// 	ИмяФОИспользованияППД - Строка -
//
Процедура ИнициализироватьРеквизитыФормыДляПолнотекстовогоПоиска(Форма, ИмяФОИспользованияППД) Экспорт
	
	Возврат;
	
КонецПроцедуры

// Сохраняет в реквизит КэшДанныхМеханизмов формы данные, необходимые для работы механизма.
// 
// Параметры:
// 	Форма - ФормаКлиентскогоПриложения - Форма
// 	ИмяМеханизма - Строка - Имя механизма, который сохраняет данные
// 	ДанныеДляКэширования - Произвольный - Кэшируемые данные
//
Процедура СохранитьДанныеМеханизмаВКэшФормы(Форма, ИмяМеханизма, ДанныеДляКэширования) Экспорт
	
	Если НЕ ОбщегоНазначенияКлиентСервер.ЕстьРеквизитИлиСвойствоОбъекта(Форма, "КэшДанныхМеханизмов") Тогда
		ДобавляемыеРеквизиты = Новый Массив;
		ДобавляемыеРеквизиты.Добавить(Новый РеквизитФормы("КэшДанныхМеханизмов", Новый ОписаниеТипов("Неопределено")));
		Форма.ИзменитьРеквизиты(ДобавляемыеРеквизиты);
		Форма.КэшДанныхМеханизмов = Новый Структура;
	КонецЕсли;
	Форма.КэшДанныхМеханизмов.Вставить(ИмяМеханизма, ДанныеДляКэширования);
	
КонецПроцедуры

// Удаляет повторяющиеся элементы массива.
//
// Параметры:
// 	Массив - Массив - 
//	НеИспользоватьНеопределено - Булево - 
// 
// Возвращаемое значение:
// 	Массив - Исходный массив, но уже без повторяющихся элементов
//
Функция УдалитьПовторяющиесяЭлементыМассива(Массив, НеИспользоватьНеопределено = Ложь) Экспорт
	
	ОписаниеТиповСправочники  = Справочники.ТипВсеСсылки(); 
	ОписаниеТиповДокументы    = Документы.ТипВсеСсылки(); 
	ОписаниеТиповПВХ          = ПланыВидовХарактеристик.ТипВсеСсылки(); 
	ОписаниеТиповПланыСчетов  = ПланыСчетов.ТипВсеСсылки(); 
	ОписаниеТиповПланыРасчета = ПланыВидовРасчета.ТипВсеСсылки(); 
	
	Если ТипЗнч(Массив) = Тип("Массив") Тогда 
		
		УжеВМассиве 		   = Новый Соответствие; 
		БылоНеопределено 	   = Ложь;
		КоличествоЭлементовВМассиве = Массив.Количество(); 
		
		Для ОбратныйИндекс = 1 По КоличествоЭлементовВМассиве Цикл 
			
			ЭлементМассива = Массив[КоличествоЭлементовВМассиве - ОбратныйИндекс]; 
			ТипЭлемента    = ТипЗнч(ЭлементМассива); 
			
			Если ЭлементМассива = Неопределено Тогда
				
				Если БылоНеопределено ИЛИ НеИспользоватьНеопределено Тогда
					Массив.Удалить(КоличествоЭлементовВМассиве - ОбратныйИндекс); 
				Иначе
					БылоНеопределено = Истина;
				КонецЕсли;
				
				Продолжить;
				
			ИначеЕсли ОписаниеТиповСправочники.СодержитТип(ТипЭлемента) 
			 ИЛИ ОписаниеТиповДокументы.СодержитТип(ТипЭлемента) 
			 ИЛИ ОписаниеТиповПВХ.СодержитТип(ТипЭлемента) 
			 ИЛИ ОписаниеТиповПланыСчетов.СодержитТип(ТипЭлемента) 
			 ИЛИ ОписаниеТиповПланыРасчета.СодержитТип(ТипЭлемента) Тогда 
				
				ИДЭлемента = Строка(ЭлементМассива.УникальныйИдентификатор()); 
				
			Иначе 
				
				ИДЭлемента = ЭлементМассива; 
				
			КонецЕсли; 
			
			Если УжеВМассиве[ИДЭлемента] = Истина Тогда 
				Массив.Удалить(КоличествоЭлементовВМассиве - ОбратныйИндекс); 
			Иначе 
				УжеВМассиве[ИДЭлемента] = Истина; 
			КонецЕсли; 
			
		КонецЦикла;      
		
	КонецЕсли;
	
	Возврат Массив;
	
КонецФункции

// Функция возвращает представление клавиши
// Параметры:
//	ЗначениеКлавиша						- Клавиша
//
// Возвращаемое значение:
//	Строка - Представление клавиши.
//
Функция ПредставлениеКлавиши(ЗначениеКлавиша) Экспорт
	
	Если Строка(Клавиша._1) = Строка(ЗначениеКлавиша) Тогда
		Возврат "1";
	ИначеЕсли Строка(Клавиша._2) = Строка(ЗначениеКлавиша) Тогда
		Возврат "2";
	ИначеЕсли Строка(Клавиша._3) = Строка(ЗначениеКлавиша) Тогда
		Возврат "3";
	ИначеЕсли Строка(Клавиша._4) = Строка(ЗначениеКлавиша) Тогда
		Возврат "4";
	ИначеЕсли Строка(Клавиша._5) = Строка(ЗначениеКлавиша) Тогда
		Возврат "5";
	ИначеЕсли Строка(Клавиша._6) = Строка(ЗначениеКлавиша) Тогда
		Возврат "6";
	ИначеЕсли Строка(Клавиша._7) = Строка(ЗначениеКлавиша) Тогда
		Возврат "7";
	ИначеЕсли Строка(Клавиша._8) = Строка(ЗначениеКлавиша) Тогда
		Возврат "8";
	ИначеЕсли Строка(Клавиша._9) = Строка(ЗначениеКлавиша) Тогда
		Возврат "9";
	ИначеЕсли Строка(Клавиша.Num0) = Строка(ЗначениеКлавиша) Тогда
		Возврат "Num 0";
	ИначеЕсли Строка(Клавиша.Num1) = Строка(ЗначениеКлавиша) Тогда
		Возврат "Num 1";
	ИначеЕсли Строка(Клавиша.Num2) = Строка(ЗначениеКлавиша) Тогда
		Возврат "Num 2";
	ИначеЕсли Строка(Клавиша.Num3) = Строка(ЗначениеКлавиша) Тогда
		Возврат "Num 3";
	ИначеЕсли Строка(Клавиша.Num4) = Строка(ЗначениеКлавиша) Тогда
		Возврат "Num 4";
	ИначеЕсли Строка(Клавиша.Num5) = Строка(ЗначениеКлавиша) Тогда
		Возврат "Num 5";
	ИначеЕсли Строка(Клавиша.Num6) = Строка(ЗначениеКлавиша) Тогда
		Возврат "Num 6";
	ИначеЕсли Строка(Клавиша.Num7) = Строка(ЗначениеКлавиша) Тогда
		Возврат "Num 7";
	ИначеЕсли Строка(Клавиша.Num8) = Строка(ЗначениеКлавиша) Тогда
		Возврат "Num 8";
	ИначеЕсли Строка(Клавиша.Num9) = Строка(ЗначениеКлавиша) Тогда
		Возврат "Num 9";
	ИначеЕсли Строка(Клавиша.NumAdd) = Строка(ЗначениеКлавиша) Тогда
		Возврат "Num +";
	ИначеЕсли Строка(Клавиша.NumDecimal) = Строка(ЗначениеКлавиша) Тогда
		Возврат "Num .";
	ИначеЕсли Строка(Клавиша.NumDivide) = Строка(ЗначениеКлавиша) Тогда
		Возврат "Num /";
	ИначеЕсли Строка(Клавиша.NumMultiply) = Строка(ЗначениеКлавиша) Тогда
		Возврат "Num *";
	ИначеЕсли Строка(Клавиша.NumSubtract) = Строка(ЗначениеКлавиша) Тогда
		Возврат "Num -";
	Иначе
		Возврат Строка(ЗначениеКлавиша);
	КонецЕсли;
	
КонецФункции

// Функция возвращает представление клавиши
// Параметры:
//	СочетаниеКлавиш	 - СочетаниеКлавиш - Сочетание клавиш для которого нужно сформировать представление
//	БезСкобок - Булево - Флаг, указывающий, что представление должно быть сформировано без скобок.
//
// Возвращаемое значение:
//	Строка - Представление сочетания клавиш.
//
Функция ПредставлениеСочетанияКлавиш(СочетаниеКлавиш, БезСкобок = Ложь) Экспорт
	
	Если СочетаниеКлавиш.Клавиша = Клавиша.Нет Тогда
		Возврат "";
	КонецЕсли;
	
	Наименование = ?(БезСкобок, "", "(");
	Если СочетаниеКлавиш.Ctrl Тогда
		Наименование = Наименование + "Ctrl+"
	КонецЕсли;
	Если СочетаниеКлавиш.Alt Тогда
		Наименование = Наименование + "Alt+"
	КонецЕсли;
	Если СочетаниеКлавиш.Shift Тогда
		Наименование = Наименование + "Shift+"
	КонецЕсли;
	Наименование = Наименование + ПредставлениеКлавиши(СочетаниеКлавиш.Клавиша) + ?(БезСкобок, "", ")");
	
	Возврат Наименование;
	
КонецФункции

// Устанавливает свойство ОтображениеСтраницФормы в Нет, если фактически отображается только одна закладка
// Параметры:
//  ЭлементСтраница  - ГруппаФормы - страница, для которой определяется необходимость отображения закладок.
//
Процедура УдалитьЗакладкиЕслиСтраницаОдна(ЭлементСтраница) Экспорт
	
	Если ЭлементСтраница.ПодчиненныеЭлементы.Количество() = 1 Тогда
		ЭлементСтраница.ОтображениеСтраниц = ОтображениеСтраницФормы.Нет;
	Иначе
		КоличествоВидимыхСтраниц = 0;
		Для Каждого ПодчиненнаяСтраница Из ЭлементСтраница.ПодчиненныеЭлементы Цикл
			
			Если КоличествоВидимыхСтраниц > 1 Тогда
				Прервать;
			КонецЕсли;
			
			Для Каждого ЭлементСтраницы Из ПодчиненнаяСтраница.ПодчиненныеЭлементы Цикл
				
				Если ЭлементСтраницы.Видимость Тогда
					КоличествоВидимыхСтраниц = КоличествоВидимыхСтраниц + 1;
					Прервать;
				КонецЕсли;
				
			КонецЦикла;
			
		КонецЦикла;
		
		Если КоличествоВидимыхСтраниц = 1 Тогда
			ЭлементСтраница.ОтображениеСтраниц = ОтображениеСтраницФормы.Нет;
		КонецЕсли;
		
	КонецЕсли;
	
КонецПроцедуры

// В настройках пользователя могут быть битые ссылки. Процедура проверяет, что ссылки не битые, и если это так -
// заменяет эти ссылки на пустые. Если процедура вызывается в событии ПередЗагрузкойДанныхИзНастроекНаСервере - можно
// очистить ссылки собственно в загружаемых настройка. Если в ПриЗагрузкеДанныхИзНастроекНаСервере - настройки уже применены
// к реквизитам формы и чистить нужно их.
//
// Параметры:
//  Настройки	 - Структура, Соответствие -
//  Форма		 - ФормаКлиентскогоПриложения, Неопределено - если передана форма - очищаются реквизиты, если Неопределено - настройки 
//
Процедура ОчиститьНастройкиИлиРеквизитыФормыОтНесуществующихСсылок(Настройки, Форма = Неопределено) Экспорт
	
	Если Форма <> Неопределено Тогда
		ОчищаемыйОбъект = Форма;
	Иначе
		ОчищаемыйОбъект = Настройки;
	КонецЕсли;
	
	Если ТипЗнч(Настройки) = Тип("Структура")
		Или ТипЗнч(Настройки) = Тип("Соответствие") Тогда
		
		Для Каждого КлючЗначение Из Настройки Цикл
			
			Если ПустаяСтрока(КлючЗначение.Ключ) Тогда
				Продолжить;
			КонецЕсли;
			
			ТипЗначения = ТипЗнч(ОчищаемыйОбъект[КлючЗначение.Ключ]);
			
			Если ОбщегоНазначения.ЭтоСсылка(ТипЗначения)
				И Не ОбщегоНазначения.СсылкаСуществует(ОчищаемыйОбъект[КлючЗначение.Ключ]) Тогда
				ОписаниеТипов = Новый ОписаниеТипов(ОбщегоНазначенияКлиентСервер.ЗначениеВМассиве(ТипЗначения));
				ОчищаемыйОбъект[КлючЗначение.Ключ] = ОписаниеТипов.ПривестиЗначение();
			КонецЕсли;
		КонецЦикла;
		
	КонецЕсли;
	
КонецПроцедуры

// Возвращает структуру измененных параметров
// 
// Параметры:
// 	СтруктураПараметровНовая - Структура - Структура параметров механизма до изменения ключевых реквизитов.
// 	СтруктураПараметровСтарая - Структура - Структура параметров механизма после изменения ключевых реквизитов.
// Возвращаемое значение:
// 	Структура -
Функция ИзмененныеПараметры(СтруктураПараметровНовая, СтруктураПараметровСтарая) Экспорт
	
	Результат = Новый Структура();
	
	Если ТипЗнч(СтруктураПараметровНовая) <> Тип("Структура") ИЛИ ТипЗнч(СтруктураПараметровСтарая) <> Тип("Структура") Тогда
		Возврат Результат;
	КонецЕсли;
	
	Для каждого КлючИЗначение Из СтруктураПараметровНовая Цикл
		
		Если ТипЗнч(КлючИЗначение.Значение) = Тип("Массив")
			ИЛИ ТипЗнч(КлючИЗначение.Значение) = Тип("Структура") Тогда
			Продолжить;
		КонецЕсли;
		
		Если КлючИЗначение.Значение <> СтруктураПараметровСтарая[КлючИЗначение.Ключ] Тогда
			Результат.Вставить(КлючИЗначение.Ключ, СтруктураПараметровСтарая[КлючИЗначение.Ключ] );
		КонецЕсли;
	КонецЦикла;
	
	Возврат Результат;
	
КонецФункции

#КонецОбласти

#Область ЗаполненияТабличныхЧастейДокумента

// Процедура проверяет дубли строк в табличной части
//
// Параметры:
//  Объект				 - ДокументОбъект, ФормаКлиентскогоПриложения - проверяемый ДокументОбъект или форма
//  ИмяТЧ				 - Строка			 - имя проверяемой табличной части
//  КлючевыеРеквизитыТЧ	 - Массив -
//	                     - Строка - массив имен реквизитов, по которым определяется уникальность строки
//  Отказ				 - Булево			 - отказ продолжения операции.
//  ПредставлениеТЧ		 - Строка			 - если не указано, то представление будет получено из метаданных.
//  УказыватьНомераСтрок - Булево			 - определяет необходимость вывода номера строки в сообщении об ошибке.
//
Процедура ПроверитьНаличиеДублейСтрокТЧ(Объект, ИмяТЧ, КлючевыеРеквизитыТЧ, Отказ, ПредставлениеТЧ = "", УказыватьНомераСтрок = Истина) Экспорт
	
	Если ТипЗнч(КлючевыеРеквизитыТЧ) = Тип("Строка") Тогда
		КлючевыеРеквизиты = СтрРазделить(КлючевыеРеквизитыТЧ, ",");
	Иначе
		КлючевыеРеквизиты = КлючевыеРеквизитыТЧ;
	КонецЕсли;
	
	КлючДанных = КлючДанныхДляСообщенияПользователю(Объект);
	
	ЭтоФорма = Ложь;
	Если ТипЗнч(Объект) = Тип("ФормаКлиентскогоПриложения") Тогда
		ЭтоФорма = Истина;
	Иначе
		МетаданныеОбъекта = Объект.Метаданные();
		Если ПустаяСтрока(ПредставлениеТЧ) Тогда
			ПредставлениеТЧ = МетаданныеОбъекта.ТабличныеЧасти[ИмяТЧ].Синоним;
		КонецЕсли;
	КонецЕсли;
	
	МассивСтрокПоляВыборки = Новый Массив;
	МассивСтрокПоляСоединения = Новый Массив;
	МассивСтрокПоляВыгрузки = Новый Массив;
	МассивСтрокСообщенияОДублях = Новый Массив;
	
	Для Каждого СтрМас Из КлючевыеРеквизиты Цикл
		МассивСтрокПоляВыборки.Добавить(СтрШаблон("ТаблицаПроверки.%1", СтрМас));
		МассивСтрокПоляСоединения.Добавить(СтрШаблон("ТаблицаПроверки.%1 = ДублирующиесяСтроки.%1", СтрМас));
		МассивСтрокПоляВыгрузки.Добавить(СтрМас);
		ПредставлениеРеквизита = ?(ЭтоФорма, "",МетаданныеОбъекта.ТабличныеЧасти[ИмяТЧ].Реквизиты[СтрМас].Синоним);
		МассивСтрокСообщенияОДублях.Добавить(СтрШаблон("""%1""", ПредставлениеРеквизита));
	КонецЦикла;	
	
	ТекстПоляВыборки = СтрСоединить(МассивСтрокПоляВыборки, "," + Символы.ПС);
	ТекстПоляСоединения = СтрСоединить(МассивСтрокПоляСоединения, Символы.ПС + "И" + " ");
	ТекстПоляВыгрузки = СтрСоединить(МассивСтрокПоляВыгрузки, ",");
	ТекстДляСообщенияОДублях =  СтрСоединить(МассивСтрокСообщенияОДублях, ",");
	
	ТекстЗапроса =
	"ВЫБРАТЬ 
	|	ТаблицаПроверки.НомерСтроки,
	|	&ПоляВыборки
	|ПОМЕСТИТЬ ТаблицаПроверки
	|ИЗ
	|	&ТаблицаПроверки КАК ТаблицаПроверки
	|;
	|
	|////////////////////////////////////////////////////////////////////////////////
	|ВЫБРАТЬ
	|	МИНИМУМ(ТаблицаПроверки.НомерСтроки) КАК НомерСтроки,
	|	СУММА(1) КАК КоличествоДублей,
	|	&ПоляВыборки
	|ПОМЕСТИТЬ ДублирующиесяСтроки
	|ИЗ
	|	ТаблицаПроверки КАК ТаблицаПроверки
	|
	|СГРУППИРОВАТЬ ПО 
	|	&ПоляВыборки
	|
	|ИМЕЮЩИЕ
	|	СУММА(1) > 1
	|;
	|
	|////////////////////////////////////////////////////////////////////////////////
	|ВЫБРАТЬ
	|	ТаблицаПроверки.НомерСтроки,
	|	ДублирующиесяСтроки.НомерСтроки КАК ПерваяСтрока,
	|	&ПоляВыборки
	|ИЗ
	|	ТаблицаПроверки КАК ТаблицаПроверки
	|		ВНУТРЕННЕЕ СОЕДИНЕНИЕ ДублирующиесяСтроки КАК ДублирующиесяСтроки
	|		ПО ТаблицаПроверки.НомерСтроки <> ДублирующиесяСтроки.НомерСтроки 
	|			И &ПоляСоединения";
	ТекстЗапроса = СтрЗаменить(ТекстЗапроса, "&ПоляВыборки", ТекстПоляВыборки);
	ТекстЗапроса = СтрЗаменить(ТекстЗапроса, "&ПоляСоединения", ?(ТекстПоляСоединения = "", "ИСТИНА", ТекстПоляСоединения));
	
	Запрос = Новый Запрос(ТекстЗапроса);
	Запрос.УстановитьПараметр("ТаблицаПроверки",Объект[ИмяТЧ].Выгрузить(,"НомерСтроки," + ТекстПоляВыгрузки));
	
	Выборка = Запрос.Выполнить().Выбрать();
	
	Если ЭтоФорма Тогда
		Если УказыватьНомераСтрок Тогда
			Если КлючевыеРеквизиты.Количество() = 1 Тогда
				ШаблонСообщения = НСтр("ru = 'В строке %НомерСтроки% списка ""%ПредставлениеТЧ%"" по сравнению со строкой %ПерваяСтрока% повторяется значение ""%ПовторяемоеЗначение%"" в ключевом поле.';
										|en = 'In line %НомерСтроки% of the %ПредставлениеТЧ% list, compared to line %ПерваяСтрока% the %ПовторяемоеЗначение% value is repeated in the key field.'");
			Иначе
				ШаблонСообщения = НСтр("ru = 'В строке %НомерСтроки% списка ""%ПредставлениеТЧ%"" по сравнению со строкой %ПерваяСтрока% повторяется сочетание значений ""%ПовторяемоеЗначение%"" в ключевых полях.';
										|en = 'In line %НомерСтроки% of the %ПредставлениеТЧ% list, compared to line %ПерваяСтрока% the %ПовторяемоеЗначение% value combination is repeated in key fields.'");
			КонецЕсли;
		Иначе
			Если КлючевыеРеквизиты.Количество() = 1 Тогда
				ШаблонСообщения = НСтр("ru = 'В списке ""%ПредставлениеТЧ%"" повторяется значение ""%ПовторяемоеЗначение%"" в ключевом поле.';
										|en = 'In the %ПредставлениеТЧ% list, the %ПовторяемоеЗначение% value is repeated in the key field.'");
			Иначе
				ШаблонСообщения = НСтр("ru = 'В списке ""%ПредставлениеТЧ%"" повторяется сочетание значений ""%ПовторяемоеЗначение%"" в ключевых полях.';
										|en = 'In the %ПредставлениеТЧ% list, the %ПовторяемоеЗначение% value combination is repeated in key fields.'");
			КонецЕсли;
		КонецЕсли;
	Иначе
		Если УказыватьНомераСтрок Тогда
			Если КлючевыеРеквизиты.Количество() = 1 Тогда
				ШаблонСообщения = НСтр("ru = 'В строке %НомерСтроки% списка ""%ПредставлениеТЧ%"" по сравнению со строкой %ПерваяСтрока% повторяется значение ""%ПовторяемоеЗначение%"" в полях %НазванияПолей%.';
										|en = 'In line %НомерСтроки% of the ""%ПредставлениеТЧ%"" list compared to line %ПерваяСтрока% the ""%ПовторяемоеЗначение%"" value is repeated in fields %НазванияПолей%.'");
			Иначе
				ШаблонСообщения = НСтр("ru = 'В строке %НомерСтроки% списка ""%ПредставлениеТЧ%"" по сравнению со строкой %ПерваяСтрока% повторяется сочетание значений ""%ПовторяемоеЗначение%"" в полях %НазванияПолей%.';
										|en = 'In line %НомерСтроки% of the ""%ПредставлениеТЧ%"" list compared to line %ПерваяСтрока% the ""%ПовторяемоеЗначение%"" value combination is repeated in the %НазванияПолей% fields.'");
			КонецЕсли;
		Иначе
			Если КлючевыеРеквизиты.Количество() = 1 Тогда
				ШаблонСообщения = НСтр("ru = 'В списке ""%ПредставлениеТЧ%"" повторяется значение ""%ПовторяемоеЗначение%"" в поле %НазванияПолей%.';
										|en = 'In the ""%ПредставлениеТЧ%"" list, the ""%ПовторяемоеЗначение%"" value is repeated in field %НазванияПолей%.'");
			Иначе
				ШаблонСообщения = НСтр("ru = 'В списке ""%ПредставлениеТЧ%"" повторяется сочетание значений ""%ПовторяемоеЗначение%"" в полях %НазванияПолей%.';
										|en = 'In the ""%ПредставлениеТЧ%"" list, the ""%ПовторяемоеЗначение%"" value combination is repeated in fields %НазванияПолей%.'");
			КонецЕсли;
		КонецЕсли;
	КонецЕсли;

	Пока Выборка.Следующий() Цикл
		
		ТекстСообщения =  СтрЗаменить(ШаблонСообщения, "%ПредставлениеТЧ%", ПредставлениеТЧ);
		ТекстСообщения =  СтрЗаменить(ТекстСообщения, "%НомерСтроки%", Выборка.НомерСтроки);
		ТекстСообщения =  СтрЗаменить(ТекстСообщения, "%ПерваяСтрока%", Выборка.ПерваяСтрока);
		ТекстСообщения =  СтрЗаменить(ТекстСообщения, "%НазванияПолей%", ТекстДляСообщенияОДублях);
		
		ПовторяемоеЗначение = "";
		
		Для Каждого СтрМас Из КлючевыеРеквизиты Цикл
			ПредставлениеЗначения = СокрЛП(Строка(Выборка[СтрМас]));
			Если ЗначениеЗаполнено(ПредставлениеЗначения) Тогда
				ПовторяемоеЗначение = ПовторяемоеЗначение + Выборка[СтрМас] + "/";
			КонецЕсли;
		КонецЦикла;
		
		ПовторяемоеЗначение = Лев(ПовторяемоеЗначение, СтрДлина(ПовторяемоеЗначение) - 1);
		
		ТекстСообщения =  СтрЗаменить(ТекстСообщения, "%ПовторяемоеЗначение%", ПовторяемоеЗначение);
		
		Если УказыватьНомераСтрок Тогда
			Поле = ОбщегоНазначенияКлиентСервер.ПутьКТабличнойЧасти(ИмяТЧ, Выборка.НомерСтроки, "НомерСтроки");
		Иначе
			Поле = ИмяТЧ;
		КонецЕсли;
		
		ОбщегоНазначенияКлиентСервер.СообщитьПользователю(ТекстСообщения,КлючДанных,Поле,"Объект",Отказ);
		
	КонецЦикла;
КонецПроцедуры

// Процедура заполняет значения реквизитов табличной части по структуре
//
// Параметры:
// 		КоллекцияДанных - ДанныеФормыКоллекция - Табличная часть
// 		СтруктураРеквизитов - Структура - Ключ - имя реквизита флага активности. Значение - строка перечисления зависимых реквизитов.
//
Процедура ЗаполнитьДубликатыЗависимыхРеквизитовВКоллекции(КоллекцияДанных, СтруктураРеквизитов) Экспорт
	
	// Получение шаблона поля выборки для значения дубликата реквизита
	// 		Если флаг активности ИСТИНА - скопировать значение из реквизита
	// 		Иначе - заполнить пустым значением.
	ШаблонПоляВыборки = 
	"	ВЫБОР КОГДА Коллекция.%ИмяФлага% = ИСТИНА
	|		ТОГДА Коллекция.%ИмяРеквизита%
	|		ИНАЧЕ 0
	|	КОНЕЦ КАК %ИмяРеквизита%%ИмяФлага%";
	
	МассивПолейВыборки = Новый Массив; 
	МассивПолейВыгрузки = Новый Массив;
	МассивПолейВыгрузки.Добавить("НомерСтроки");
	Для Каждого РеквизитФлага Из СтруктураРеквизитов Цикл
		МассивПолейВыгрузки.Добавить(РеквизитФлага.Ключ);
		ЗависимыеРеквизиты = Новый Структура(РеквизитФлага.Значение);
		Для Каждого ЗависимыйРеквизит Из ЗависимыеРеквизиты Цикл
			ПолеВыборки = СтрЗаменить(ШаблонПоляВыборки, "%ИмяФлага%", РеквизитФлага.Ключ);
			ПолеВыборки = СтрЗаменить(ПолеВыборки, "%ИмяРеквизита%", ЗависимыйРеквизит.Ключ);
			МассивПолейВыборки.Добавить(ПолеВыборки);
			МассивПолейВыгрузки.Добавить(ЗависимыйРеквизит.Ключ + ", " + ЗависимыйРеквизит.Ключ + РеквизитФлага.Ключ);
		КонецЦикла;
	КонецЦикла;
	
	ТекстЗапроса =
	"ВЫБРАТЬ
	|	Коллекция.НомерСтроки,
	|	&ПоляВыборки
	|ПОМЕСТИТЬ втКоллекция
	|ИЗ &КоллекцияДанных КАК Коллекция;
	|
	|ВЫБРАТЬ *
	|ИЗ втКоллекция КАК втКоллекция
	|УПОРЯДОЧИТЬ ПО НомерСтроки";
	ТекстЗапроса = СтрЗаменить(ТекстЗапроса, "&ПоляВыборки", СтрСоединить(МассивПолейВыборки, "," + Символы.ПС));
	
	Запрос = Новый Запрос(ТекстЗапроса);
	Запрос.УстановитьПараметр("КоллекцияДанных", КоллекцияДанных.Выгрузить( , СтрСоединить(МассивПолейВыгрузки, ",")));
	
	Выборка = Запрос.Выполнить().Выбрать();
	Пока Выборка.Следующий() Цикл
		ЗаполнитьЗначенияСвойств(КоллекцияДанных[Выборка.НомерСтроки-1], Выборка, , "НомерСтроки");
	КонецЦикла;
	
КонецПроцедуры // ЗаполнитьДубликатыЗависимыхРеквизитовВКоллекции()

// Процедура проверяет отмену строк в табличной части документа
// Параметры:
//	Объект - ДокументОбъект - Проверяемый документ
//	ИмяТЧ - Строка - имя проверяемой табличной части
//	ИмяРеквизитаОтменыСтрок - Строка - имя проверяемого булевого реквизита ТЧ.
// 
// Возвращаемое значение:
// 	Булево - Результат проверки
//
Функция ВсеСтрокиОтменены(Объект, ИмяТЧ, ИмяРеквизитаОтменыСтрок) Экспорт
	
	СтруктураОтбора = Новый Структура(ИмяРеквизитаОтменыСтрок, Ложь);
	НеОтмененныеСтроки = Объект[ИмяТЧ].НайтиСтроки(СтруктураОтбора);
	
	Возврат (НеОтмененныеСтроки.Количество() = 0);
	
КонецФункции

#КонецОбласти

#Область КонтрольНесогласованныхИзменений

// Осуществляет установку подписки на события изменения элементов формы.
//
// Параметры:
// 		Форма - ФормаКлиентскогоПриложения - Форма документа:
// 							* Объект - ДокументОбъект - Свойства:
// 								* Ссылка - ДокументСсылка -
// 		ИменаЭлементов - Массив Из Строка - массив имен элементов формы.
// 		Установить - Булево - необходимость установки или снятия предупреждения.
//
Процедура УстановитьПодпискуНаСобытияИзмененияЭлементовФормы(Форма, ИменаЭлементов, Установить) Экспорт
	
	Если Не ЗначениеЗаполнено(Форма.Объект.Ссылка) Тогда
		Возврат;
	КонецЕсли;
	
	СтруктураПолейТаблиц = Новый Структура;
	
	ТипУправляемаяФорма = Тип("ФормаКлиентскогоПриложения");
	ТипДанныеФормыСтруктура = Тип("ДанныеФормыСтруктура");
	ТипПолеФормы = Тип("ПолеФормы");
	ТипКнопкаФормы = Тип("КнопкаФормы");
	ТипТаблицаФормы = Тип("ТаблицаФормы");
	
	Элементы = Форма.Элементы;
	
	ОбработчикиСобытийТабличныхЧастей = Новый Структура();
	МассивЭлементов = Новый Массив;
	Для Каждого ИмяЭлементаПолное Из ИменаЭлементов Цикл
		
		ПозицияРазделителя = СтрНайти(ИмяЭлементаПолное, ";");
		Если ПозицияРазделителя > 0 Тогда
			Массив = СтроковыеФункцииКлиентСервер.РазложитьСтрокуВМассивПодстрок(ИмяЭлементаПолное, ";");
			ИмяЭлемента = Массив[0];
		Иначе
			ИмяЭлемента = ИмяЭлементаПолное;
		КонецЕсли;
		
		Если МассивЭлементов.Найти(ИмяЭлемента) <> Неопределено Тогда
			Продолжить;
		КонецЕсли;
		
		Элемент = Элементы.Найти(ИмяЭлемента);
		Если Элемент = Неопределено Тогда
			Продолжить;
		КонецЕсли;
		
		МассивЭлементов.Добавить(ИмяЭлемента);
		
		Если ПозицияРазделителя > 0 И Массив.Количество() > 1 Тогда
			Если СтрНайти(Массив[1], ",") > 0 Тогда
				ОбработчикиСобытийТабличныхЧастей.Вставить(ИмяЭлемента, СтроковыеФункцииКлиентСервер.РазложитьСтрокуВМассивПодстрок(Массив[1], ","));
			Иначе
				ОбработчикиСобытийТабличныхЧастей.Вставить(ИмяЭлемента, Массив[1]);
			КонецЕсли;
		КонецЕсли;
		
		ПоляИсключения = Новый Массив;
		Если ПозицияРазделителя > 0
			И Массив.Количество() > 2 Тогда
			ПоляИсключения = СтроковыеФункцииКлиентСервер.РазложитьСтрокуВМассивПодстрок(Массив[2], ",");
		КонецЕсли;
		
		ОбработатьВложенныеПоля(Элементы, Элемент, МассивЭлементов, СтруктураПолейТаблиц, ПоляИсключения);
		
	КонецЦикла;
	
	ИмяОбработчикаПустой = "Подключаемый_ПустойОбработчик_УстановитьДоступностьЭлементовПоСтатусуСервер";
	Если Форма.СтруктураДействийКонтрольНеСогласованныхИзменений = Неопределено Тогда
		
		Форма.СтруктураДействийКонтрольНеСогласованныхИзменений = Новый Структура;
		Форма.СтруктураДействийКонтрольНеСогласованныхИзменений.Вставить("Команды", Новый Структура);
		Форма.СтруктураДействийКонтрольНеСогласованныхИзменений.Вставить("ПриИзменении", Новый Структура);
		Форма.СтруктураДействийКонтрольНеСогласованныхИзменений.Вставить("Нажатие", Новый Структура);
		Форма.СтруктураДействийКонтрольНеСогласованныхИзменений.Вставить("ПередНачаломИзменения", Новый Структура);
		Форма.СтруктураДействийКонтрольНеСогласованныхИзменений.Вставить("ПередНачаломДобавления", Новый Структура);
		Форма.СтруктураДействийКонтрольНеСогласованныхИзменений.Вставить("ПередУдалением", Новый Структура);
		
		Форма.СтруктураДействийКонтрольНеСогласованныхИзменений.Вставить("ОжидаетсяОповещение", Ложь);
		Форма.СтруктураДействийКонтрольНеСогласованныхИзменений.Вставить("ЗначенияРеквизитов", Новый Структура);
		Форма.СтруктураДействийКонтрольНеСогласованныхИзменений.Вставить("ПутьКДанным", Новый Структура);
		Форма.СтруктураДействийКонтрольНеСогласованныхИзменений.Вставить("СвязиПараметровВыбора", Новый Соответствие);
		
		Для Каждого ИмяТаблицы Из СтруктураПолейТаблиц Цикл
			
			Имена = Новый Массив;
			Форма.СтруктураДействийКонтрольНеСогласованныхИзменений.ЗначенияРеквизитов.Вставить(ИмяТаблицы.Ключ, Новый Структура);
			
			Для Каждого ИмяЭлемента Из СтруктураПолейТаблиц[ИмяТаблицы.Ключ] Цикл
				
				Данные = Неопределено;
				ПутьКДанным = Элементы[ИмяЭлемента].ПутьКДанным;
				Если ЗначениеЗаполнено(ПутьКДанным) Тогда
					
					Позиция = СтрНайти(ПутьКДанным, ".");
					Пока Позиция > 0 Цикл
						ПутьКДанным = Сред(ПутьКДанным, Позиция + 1);
						Позиция = СтрНайти(ПутьКДанным, ".");
					КонецЦикла;
					Имена.Добавить(ПутьКДанным);
					
				КонецЕсли;
				
			КонецЦикла;
			
			Для Каждого Имя Из Имена Цикл
				Форма.СтруктураДействийКонтрольНеСогласованныхИзменений.ЗначенияРеквизитов[ИмяТаблицы.Ключ].Вставить(Имя);
			КонецЦикла;
			
		КонецЦикла;
		
		ИмяОбработчикаПриИзменении            = "Подключаемый_ПриИзменении_УстановитьДоступностьЭлементовПоСтатусуСервер";
		ИмяОбработчикаНажатие                 = "Подключаемый_Нажатие_УстановитьДоступностьЭлементовПоСтатусуСервер";
		ИмяОбработчикаКоманды                 = "Подключаемый_Команда_УстановитьДоступностьЭлементовПоСтатусуСервер";
		ИмяОбработчикаПередНачаломИзменения   = "Подключаемый_ПередНачаломИзменения_УстановитьДоступностьЭлементовПоСтатусуСервер";
		ИмяОбработчикаПередНачаломДобавления  = "Подключаемый_ПередНачаломДобавления_УстановитьДоступностьЭлементовПоСтатусуСервер";
		ИмяОбработчикаПередУдалением          = "Подключаемый_ПередУдалением_УстановитьДоступностьЭлементовПоСтатусуСервер";
		
		Для Каждого ИмяЭлементаПолное Из МассивЭлементов Цикл
			
			ПозицияРазделителя = СтрНайти(ИмяЭлементаПолное, ";");
			Если ПозицияРазделителя > 0 Тогда
				ИмяЭлемента = Лев(ИмяЭлементаПолное, ПозицияРазделителя - 1);
			Иначе
				ИмяЭлемента = ИмяЭлементаПолное;
			КонецЕсли;
			
			Элемент = Элементы[ИмяЭлемента];
			Если Элемент = Неопределено Тогда
				Продолжить;
			КонецЕсли;
			
			ТипЗнчЭлемент = ТипЗнч(Элемент);
			
			Если ТипЗнчЭлемент = ТипПолеФормы Тогда
				
				Действие = Элемент.ПолучитьДействие("ПриИзменении");
				Если ЗначениеЗаполнено(Действие) И Действие <> ИмяОбработчикаПустой Тогда
					Форма.СтруктураДействийКонтрольНеСогласованныхИзменений.ПриИзменении.Вставить(ИмяЭлемента, Действие);
				КонецЕсли;
				
				Данные = Неопределено;
				ПутьКДанным = Элемент.ПутьКДанным;
				Если ЗначениеЗаполнено(ПутьКДанным) Тогда
					Массив = СтроковыеФункцииКлиентСервер.РазложитьСтрокуВМассивПодстрок(ПутьКДанным, ".");
					Данные = Форма;
					Для Каждого СтрокаМассива Из Массив Цикл
						ТипЗнчДанные = ТипЗнч(Данные);
						Если ТипЗнчДанные = ТипУправляемаяФорма
							ИЛИ ТипЗнчДанные = ТипДанныеФормыСтруктура Тогда
							Данные = Данные[СтрокаМассива];
						Иначе
							Данные = Неопределено;
							Прервать;
						КонецЕсли;
					КонецЦикла;
				КонецЕсли;
				
				Если Данные <> Неопределено Тогда
					Форма.СтруктураДействийКонтрольНеСогласованныхИзменений.ЗначенияРеквизитов.Вставить(ИмяЭлемента, Данные);
				КонецЕсли;
				Форма.СтруктураДействийКонтрольНеСогласованныхИзменений.ПутьКДанным.Вставить(ИмяЭлемента, ПутьКДанным);
				Элемент.УстановитьДействие("ПриИзменении", ИмяОбработчикаПриИзменении);
				
				Если Элемент.Вид = ВидПоляФормы.ПолеВвода Тогда
					Для Каждого СвязьПараметровВыбора Из Элемент.СвязиПараметровВыбора Цикл
						Если СвязьПараметровВыбора.ИзменениеЗначения = РежимИзмененияСвязанногоЗначения.Очищать Тогда
							Массив = Форма.СтруктураДействийКонтрольНеСогласованныхИзменений.СвязиПараметровВыбора.Получить(СвязьПараметровВыбора.ПутьКДанным);
							Если Массив = Неопределено Тогда
								Массив = Новый Массив;
								Форма.СтруктураДействийКонтрольНеСогласованныхИзменений.СвязиПараметровВыбора.Вставить(СвязьПараметровВыбора.ПутьКДанным, Массив);
							КонецЕсли;
							Массив.Добавить(ИмяЭлементаПолное);
						КонецЕсли;
					КонецЦикла;
				КонецЕсли;
				
			ИначеЕсли ТипЗнчЭлемент = ТипТаблицаФормы Тогда
				
				Действия = Неопределено;
				ОбработчикиСобытийТабличныхЧастей.Свойство(ИмяЭлемента, Действия);
				
				Если Не ЗначениеЗаполнено(Действия) Или Действия.Найти("ПередНачаломДобавления") <> Неопределено Тогда
					Действие = Элементы[ИмяЭлемента].ПолучитьДействие("ПередНачаломДобавления");
					Если ЗначениеЗаполнено(Действие) И Действие <> ИмяОбработчикаПустой Тогда
						Форма.СтруктураДействийКонтрольНеСогласованныхИзменений.ПередНачаломДобавления.Вставить(ИмяЭлемента, Действие);
					КонецЕсли;
					Элемент.УстановитьДействие("ПередНачаломДобавления", ИмяОбработчикаПередНачаломДобавления);
				КонецЕсли;
				
				Если Не ЗначениеЗаполнено(Действия) Или Действия.Найти("ПередУдалением") <> Неопределено Тогда
					Действие = Элементы[ИмяЭлемента].ПолучитьДействие("ПередУдалением");
					Если ЗначениеЗаполнено(Действие) И Действие <> ИмяОбработчикаПустой Тогда
						Форма.СтруктураДействийКонтрольНеСогласованныхИзменений.ПередУдалением.Вставить(ИмяЭлемента, Действие);
					КонецЕсли;
					Элемент.УстановитьДействие("ПередУдалением", ИмяОбработчикаПередУдалением);
				КонецЕсли;
				
				Если Не ЗначениеЗаполнено(Действия) Или Действия.Найти("ПередНачаломИзменения") <> Неопределено Тогда
					Действие = Элементы[ИмяЭлемента].ПолучитьДействие("ПередНачаломИзменения");
					Если ЗначениеЗаполнено(Действие) И Действие <> ИмяОбработчикаПустой Тогда
						Форма.СтруктураДействийКонтрольНеСогласованныхИзменений.ПередНачаломИзменения.Вставить(ИмяЭлемента, Действие);
					КонецЕсли;
					Элемент.УстановитьДействие("ПередНачаломИзменения", ИмяОбработчикаПередНачаломИзменения);
				КонецЕсли;
				
			ИначеЕсли ТипЗнчЭлемент = ТипКнопкаФормы Тогда
				
				ИмяКоманды = Элемент.ИмяКоманды;
				
				Если Не ЗначениеЗаполнено(ИмяКоманды) Тогда
					Продолжить;
				КонецЕсли;
				
				Если Форма.СтруктураДействийКонтрольНеСогласованныхИзменений.Команды.Свойство(ИмяКоманды) Тогда
					Продолжить;
				КонецЕсли;
				
				КомандаФормы = Форма.Команды[ИмяКоманды]; // КомандаФормы - 
				
				Действие = КомандаФормы.Действие;
				Если ЗначениеЗаполнено(Действие) Тогда
					Форма.СтруктураДействийКонтрольНеСогласованныхИзменений.Команды.Вставить(ИмяКоманды, Действие);
				КонецЕсли;
				
				КомандаФормы.Действие = ИмяОбработчикаКоманды;
				
			ИначеЕсли ТипЗнчЭлемент = Тип("ДекорацияФормы") Тогда
				
				Действие = Элемент.ПолучитьДействие("Нажатие");
				Если ЗначениеЗаполнено(Действие) И Действие <> ИмяОбработчикаПустой Тогда
					Форма.СтруктураДействийКонтрольНеСогласованныхИзменений.Нажатие.Вставить(ИмяЭлемента, Действие);
				КонецЕсли;
				
				Элемент.УстановитьДействие("Нажатие", ИмяОбработчикаНажатие);
				
			Иначе
				ВызватьИсключение НСтр("ru = 'Внутренняя ошибка';
										|en = 'Internal error'");
			КонецЕсли;
		КонецЦикла;
		
	Иначе
		
		Если Форма.СтруктураДействийКонтрольНеСогласованныхИзменений <> Неопределено Тогда
			Форма.СтруктураДействийКонтрольНеСогласованныхИзменений.ОжидаетсяОповещение = Ложь;
		КонецЕсли;
		
	КонецЕсли;
	
КонецПроцедуры

#КонецОбласти

#Область УсловноеОформление

// Устанавливаем условное оформление для поля формы "Приоритет"
//    в зависимости от его значения.
//
// Параметры:
// 		Форма - ФормаКлиентскогоПриложения - Содержит данную форму с реквизитами:
// 			* Элементы - ВсеЭлементыФормы - Коллекция элементов формы:
// 				** Приоритет - ПолеФормы - 
//
Процедура УстановитьУсловноеОформлениеПриоритета(Форма) Экспорт
	
	Если Форма.ИмяФормы = "Обработка.СамообслуживаниеПартнеров.Форма.МастерОформленияЗаказа" Тогда
		ПутьКРеквизитуПриоритет = "Приоритет";
	Иначе
		ПутьКРеквизитуПриоритет = "Объект.Приоритет";
	КонецЕсли;
	
	УсловноеОформление = Форма.УсловноеОформление;
	ЭлементыФормы = Форма.Элементы;
	
	//
	ЭлементУсловногоОформления = УсловноеОформление.Элементы.Добавить();

	ПолеЭлемента = ЭлементУсловногоОформления.Поля.Элементы.Добавить();
	ПолеЭлемента.Поле = Новый ПолеКомпоновкиДанных(ЭлементыФормы.Приоритет.Имя);

	ОтборЭлемента = ЭлементУсловногоОформления.Отбор.Элементы.Добавить(Тип("ЭлементОтбораКомпоновкиДанных"));
	ОтборЭлемента.ЛевоеЗначение = Новый ПолеКомпоновкиДанных(ПутьКРеквизитуПриоритет);
	ОтборЭлемента.ВидСравнения = ВидСравненияКомпоновкиДанных.Равно;
	ОтборЭлемента.ПравоеЗначение = Справочники.Приоритеты.ПолучитьВысшийПриоритет();

	ЭлементУсловногоОформления.Оформление.УстановитьЗначениеПараметра("ЦветФона", ЦветаСтиля.ВысокийПриоритетДокумента);

	//
	ЭлементУсловногоОформления = УсловноеОформление.Элементы.Добавить();

	ПолеЭлемента = ЭлементУсловногоОформления.Поля.Элементы.Добавить();
	ПолеЭлемента.Поле = Новый ПолеКомпоновкиДанных(ЭлементыФормы.Приоритет.Имя);

	ОтборЭлемента = ЭлементУсловногоОформления.Отбор.Элементы.Добавить(Тип("ЭлементОтбораКомпоновкиДанных"));
	ОтборЭлемента.ЛевоеЗначение = Новый ПолеКомпоновкиДанных(ПутьКРеквизитуПриоритет);
	ОтборЭлемента.ВидСравнения = ВидСравненияКомпоновкиДанных.Равно;
	ОтборЭлемента.ПравоеЗначение = Справочники.Приоритеты.ПолучитьНизшийПриоритет();

	ЭлементУсловногоОформления.Оформление.УстановитьЗначениеПараметра("ЦветФона", ЦветаСтиля.НизкийПриоритетДокумента);
	
	//
	Запрос = Новый Запрос(
	"ВЫБРАТЬ
	|	Приоритеты.Ссылка КАК Приоритет,
	|	Приоритеты.Цвет   КАК Цвет
	|ИЗ
	|	Справочник.Приоритеты КАК Приоритеты");
	
	РезультатЗапроса = Запрос.Выполнить();
	
	Если НЕ РезультатЗапроса.Пустой() Тогда
		
		Выборка = РезультатЗапроса.Выбрать();
		
		Пока Выборка.Следующий() Цикл
			
			Элемент = УсловноеОформление.Элементы.Добавить();

			ПолеЭлемента = Элемент.Поля.Элементы.Добавить();
			ПолеЭлемента.Поле = Новый ПолеКомпоновкиДанных(ЭлементыФормы.Приоритет.Имя);

			ОтборЭлемента = Элемент.Отбор.Элементы.Добавить(Тип("ЭлементОтбораКомпоновкиДанных"));
			ОтборЭлемента.ЛевоеЗначение = Новый ПолеКомпоновкиДанных(ПутьКРеквизитуПриоритет);
			ОтборЭлемента.ВидСравнения = ВидСравненияКомпоновкиДанных.Равно;
			ОтборЭлемента.ПравоеЗначение = Выборка.Приоритет;
			
			Цвет = Выборка.Цвет; // ХранилищеЗначения -
			Элемент.Оформление.УстановитьЗначениеПараметра("ЦветТекста", Цвет.Получить());
			
		КонецЦикла;
		
	КонецЕсли;
	
КонецПроцедуры

// Процедура заполняет всеми подчиненными полями (с учетом вложенности в группы) оформляемые поля условного оформления
// Пример вызова: ЗаполнитьРекурсивноПоляУсловногоОформления(ЭлементУО.Поля, Элементы.Товары.ПодчиненныеЭлементы).
//
// Параметры:
//	ОформляемыеПоляКомпоновкиДанных	- ОформляемыеПоляКомпоновкиДанных -
//	КоллекцияЭлементов - ЭлементыФормы -
//	ИсключаяПоля - Массив -
//	             - Строка -
//	             - Неопределено - значение по умолчанию Неопределено, массив имен элементов, которые не нужно добавлять в оформляемые поля.
//
Процедура ЗаполнитьРекурсивноПоляУсловногоОформления(ОформляемыеПоляКомпоновкиДанных, КоллекцияЭлементов, Знач ИсключаяПоля = Неопределено) Экспорт
	
	Если ТипЗнч(ИсключаяПоля) = Тип("Строка") Тогда
		ИсключаяПоля = СтроковыеФункцииКлиентСервер.РазложитьСтрокуВМассивПодстрок(ИсключаяПоля);
	КонецЕсли;
	
	Для Каждого Поле Из КоллекцияЭлементов Цикл
		Если ТипЗнч(Поле) = Тип("ПолеФормы") Тогда
			Если ИсключаяПоля = Неопределено
				Или ИсключаяПоля.Найти(Поле.Имя) = Неопределено Тогда
					ПолеЭлемента = ОформляемыеПоляКомпоновкиДанных.Элементы.Добавить();
					ПолеЭлемента.Поле = Новый ПолеКомпоновкиДанных(Поле.Имя);
			КонецЕсли;
		ИначеЕсли ТипЗнч(Поле) = Тип("ГруппаФормы")Тогда	
			ЗаполнитьРекурсивноПоляУсловногоОформления(ОформляемыеПоляКомпоновкиДанных, Поле.ПодчиненныеЭлементы);
		КонецЕсли;
	КонецЦикла;

КонецПроцедуры

// Добавляет на форму условное оформление элемента (отметку незаполненного), исходя из значения служебного реквизита
// по следующему правилу: если реквизит не заполнен а служебный реквизит заполнен то пометка устанавливается, иначе снимается.
//
//  Параметры:
//   УсловноеОформление - УсловноеОформлениеКомпоновкиДанных - условное оформление формы.
//   ИмяЭлемента - Строка - имя элемента для условного оформления.
//   ПутьКРеквизиту - Строка - путь к оформляемому реквизиту, например "Объект.Товары".
//   ПутьКПризнаку - Строка - путь к служебному реквизиту, определяющему необходимость отметки незаполненного значения.
//
Процедура УстановитьСнятьОтметкуНезаполненного(УсловноеОформление, ИмяЭлемента, ПутьКРеквизиту, ПутьКПризнаку) Экспорт
	
	// Установка отметки.
	Элемент = УсловноеОформление.Элементы.Добавить();
	
	ПолеЭлемента = Элемент.Поля.Элементы.Добавить();
	ПолеЭлемента.Поле = Новый ПолеКомпоновкиДанных(ИмяЭлемента);
	
	Отбор = Элемент.Отбор.Элементы.Добавить(Тип("ЭлементОтбораКомпоновкиДанных"));
	Отбор.ЛевоеЗначение = Новый ПолеКомпоновкиДанных(ПутьКПризнаку);
	Отбор.ВидСравнения = ВидСравненияКомпоновкиДанных.Заполнено;
	
	Отбор = Элемент.Отбор.Элементы.Добавить(Тип("ЭлементОтбораКомпоновкиДанных"));
	Отбор.ЛевоеЗначение = Новый ПолеКомпоновкиДанных(ПутьКРеквизиту);
	Отбор.ВидСравнения = ВидСравненияКомпоновкиДанных.НеЗаполнено;
	
	Элемент.Оформление.УстановитьЗначениеПараметра("ОтметкаНезаполненного", Истина);
	
	// Снятие отметки.
	Элемент = УсловноеОформление.Элементы.Добавить();
	
	ПолеЭлемента = Элемент.Поля.Элементы.Добавить();
	ПолеЭлемента.Поле = Новый ПолеКомпоновкиДанных(ИмяЭлемента);
	
	Отбор = Элемент.Отбор.Элементы.Добавить(Тип("ЭлементОтбораКомпоновкиДанных"));
	Отбор.ЛевоеЗначение = Новый ПолеКомпоновкиДанных(ПутьКПризнаку);
	Отбор.ВидСравнения = ВидСравненияКомпоновкиДанных.НеЗаполнено;
	
	Элемент.Оформление.УстановитьЗначениеПараметра("ОтметкаНезаполненного", Ложь);
	
	// Снятие отметки.
	Элемент = УсловноеОформление.Элементы.Добавить();
	
	ПолеЭлемента = Элемент.Поля.Элементы.Добавить();
	ПолеЭлемента.Поле = Новый ПолеКомпоновкиДанных(ИмяЭлемента);
	
	Отбор = Элемент.Отбор.Элементы.Добавить(Тип("ЭлементОтбораКомпоновкиДанных"));
	Отбор.ЛевоеЗначение = Новый ПолеКомпоновкиДанных(ПутьКРеквизиту);
	Отбор.ВидСравнения = ВидСравненияКомпоновкиДанных.Заполнено;
	
	Элемент.Оформление.УстановитьЗначениеПараметра("ОтметкаНезаполненного", Ложь);
	
КонецПроцедуры

#КонецОбласти

#Область ПереключениеИнтерфейса

// Установка набора видимых подсистем командного интерфейса
//  и настроек всем пользователям вида интерфейса (Такси / в закладках).
//
// Параметры:
//  Режим	 - Строка	 - ИнтерфейсТакси / ИнтерфейсВерсии82 - соответствует константе, которая будет установлена в Истину.
//
Процедура УстановитьРежимКомандногоИнтерфейса(Режим) Экспорт
	
	Если НЕ ОбщегоНазначения.ДоступноИспользованиеРазделенныхДанных() Тогда
		Возврат;
	КонецЕсли;
	
	// Установка констант
	
	РежимТакси = ВРег(Режим) = ВРег("ИнтерфейсТакси");
	Режим82    = ВРег(Режим) = ВРег("ИнтерфейсВерсии82");
	
	Если НЕ РежимТакси
		И НЕ Режим82 Тогда
		Возврат;
	КонецЕсли;
	
	УстановитьПривилегированныйРежим(Истина);
	Константы.ИнтерфейсВерсии82.Установить(Режим82);
	
	// Установка настроек по умолчанию всем пользователям
	
	ВсеПользователи = ПользователиИнформационнойБазы.ПолучитьПользователей(); // Массив из ПользовательИнформационнойБазы -
	Если ВсеПользователи.Количество() > 0 Тогда
		Для каждого ПользовательИБ Из ВсеПользователи Цикл
			ПользователиСлужебный.УстановитьНачальныеНастройки(ПользовательИБ.Имя);
		КонецЦикла;
	Иначе
		ПользователиСлужебный.УстановитьНачальныеНастройки("");
	КонецЕсли;

КонецПроцедуры

// Процедура - Переключение интерфейса при создании на сервере
//
// Параметры:
//  Форма	 - ФормаКлиентскогоПриложения - Форма панели администрирования.
//
Процедура ПереключениеИнтерфейсаПриСозданииНаСервере(Форма) Экспорт 

	// Значения реквизитов формы
	Если Константы.ИнтерфейсВерсии82.Получить() Тогда
		Форма.ВариантИнтерфейса = "ИнтерфейсВерсии82";
	Иначе
		Форма.ВариантИнтерфейса = "ИнтерфейсТакси";
	КонецЕсли;
	Форма.ВариантИнтерфейсаДоИзменения = Форма.ВариантИнтерфейса;
	
	ТекущийРежим = Метаданные.РежимСовместимостиИнтерфейса;
	Такси = (ТекущийРежим = Метаданные.СвойстваОбъектов.РежимСовместимостиИнтерфейса.Такси
		ИЛИ ТекущийРежим = Метаданные.СвойстваОбъектов.РежимСовместимостиИнтерфейса.ТаксиРазрешитьВерсия8_2);
	
	Форма.Элементы.ВариантИнтерфейса.СписокВыбора.Очистить();
	ПредставлениеИнтерфейса82 = НСтр("ru = 'Как в предыдущих версиях Управления торговлей';
									|en = 'As in the previous Sales Management versions'");
	//++ НЕ УТ
	ПредставлениеИнтерфейса82 = НСтр("ru = 'Как в предыдущих версиях 1С:ERP';
									|en = 'As in the previous 1C:ERP versions'");
	//-- НЕ УТ
	Если Такси ИЛИ ПолучитьФункциональнуюОпцию("БазоваяВерсия") Тогда
	
		Форма.Элементы.ВариантИнтерфейса.СписокВыбора.Добавить("ИнтерфейсТакси", НСтр("ru = '""Такси"" (рекомендуется)';
																						|en = 'Taxi (recommended)'"));
		Форма.Элементы.ВариантИнтерфейса.СписокВыбора.Добавить("ИнтерфейсВерсии82", ПредставлениеИнтерфейса82);
		
	Иначе
		
		Форма.Элементы.ВариантИнтерфейса.СписокВыбора.Добавить("ИнтерфейсТакси", НСтр("ru = '""Такси""';
																						|en = '""Taxi""'"));
		Форма.Элементы.ВариантИнтерфейса.СписокВыбора.Добавить("ИнтерфейсВерсии82", ПредставлениеИнтерфейса82 + " " + НСтр("ru = '(рекомендуется)';
																															|en = '(recommended)'"));
		
	КонецЕсли; 

КонецПроцедуры

#КонецОбласти

#Область ДинамическийСписок

// Восстанавливает настройки динамического списка, используется после изменения текста запроса 
//
// Параметры:
//  Список - ДинамическийСписок - динамический список, для которого нужно восстановить настройки
//
Процедура ВосстановитьНастройкиДинамическогоСписка(Список) Экспорт
	
	Список.КомпоновщикНастроек.Восстановить(СпособВосстановленияНастроекКомпоновкиДанных.Полное);
	
	ДоступныеПоляПорядка = Список.Порядок.ДоступныеПоляПорядка;
	
	ЭлементыПорядка = Список.Порядок.Элементы;
	ИндексЭлементов = ЭлементыПорядка.Количество() - 1;
	Пока ИндексЭлементов > -1 Цикл
		
		Если ДоступныеПоляПорядка.НайтиПоле(ЭлементыПорядка[ИндексЭлементов].Поле) = Неопределено Тогда
			ЭлементыПорядка.Удалить(ЭлементыПорядка[ИндексЭлементов]);	
		КонецЕсли;
		
		ИндексЭлементов = ИндексЭлементов - 1;
		
	КонецЦикла;	
	
КонецПроцедуры	

#КонецОбласти

#Область ПолучениеДанныхВыбора

Процедура ОбработкаПолученияДанныхВыбораХозяйственныеОперации(ДанныеВыбора, Параметры, СтандартнаяОбработка) Экспорт
	
	СтандартнаяОбработка = Ложь;
	
	ДоступныеФО = Новый Массив;
	Для Каждого ФО Из Метаданные.ФункциональныеОпции Цикл
		ДоступныеФО.Добавить(ФО.Имя);
	КонецЦикла;
	
	ТекстЗапроса = 
	"ВЫБРАТЬ
	|	НастройкиХозяйственныхОперацийФункциональныеОпции.ИмяФункциональнойОпции,
	|	НастройкиХозяйственныхОперацийФункциональныеОпции.Ссылка.ХозяйственнаяОперация КАК ХозяйственнаяОперация
	|ИЗ
	|	Справочник.НастройкиХозяйственныхОпераций.ФункциональныеОпции КАК НастройкиХозяйственныхОперацийФункциональныеОпции
	|ГДЕ
	|	НастройкиХозяйственныхОперацийФункциональныеОпции.ИмяФункциональнойОпции В(&ДоступныеФункциональныеОпции)
	|
	|УПОРЯДОЧИТЬ ПО
	|	ХозяйственнаяОперация
	|
	|ИТОГИ ПО
	|	ХозяйственнаяОперация";
	
	Запрос = Новый Запрос(ТекстЗапроса);
	Запрос.УстановитьПараметр("ДоступныеФункциональныеОпции", ДоступныеФО);
	
	МассивИсключаемыхЗначений = Новый Массив;
	ВыборкаПоОперациям = Запрос.Выполнить().Выбрать(ОбходРезультатаЗапроса.ПоГруппировкам);
	Пока ВыборкаПоОперациям.Следующий() Цикл
		ФункциональныеОпции = ВыборкаПоОперациям.Выбрать();
		ДоступнаПоФО = Ложь;
		Пока ФункциональныеОпции.Следующий() Цикл
			ПолноеИмяФО = СтрШаблон("ФункциональнаяОпция.%1", ФункциональныеОпции.ИмяФункциональнойОпции);
			ЕстьФО = Метаданные.НайтиПоПолномуИмени(ПолноеИмяФО) <> Неопределено;
			ДоступнаПоФО = Не ЕстьФО
				Или ПолучитьФункциональнуюОпцию(ФункциональныеОпции.ИмяФункциональнойОпции);
			Если ДоступнаПоФО Тогда
				Прервать;
			КонецЕсли;
		КонецЦикла;
		Если НЕ ДоступнаПоФО Тогда
			МассивИсключаемыхЗначений.Добавить(ВыборкаПоОперациям.ХозяйственнаяОперация);
		КонецЕсли;
	КонецЦикла;
	
	Если Параметры.Свойство("ЭтоВыборЗначенияДоступа") Тогда
		ТекстЗапроса = 
		"ВЫБРАТЬ
		|	НастройкиХозяйственныхОпераций.ХозяйственнаяОперация КАК Ссылка
		|ИЗ
		|	Справочник.НастройкиХозяйственныхОпераций КАК НастройкиХозяйственныхОпераций
		|ГДЕ
		|	НастройкиХозяйственныхОпераций.ИспользоватьДляОграниченийДоступа = ЛОЖЬ";
		
		Запрос = Новый Запрос(ТекстЗапроса);
		ЗапрещенныеДляВыбора = Запрос.Выполнить().Выгрузить().ВыгрузитьКолонку("Ссылка");
		ОбщегоНазначенияКлиентСервер.ДополнитьМассив(МассивИсключаемыхЗначений, ЗапрещенныеДляВыбора);
	КонецЕсли;
	
	ДоступныеДляВыбораЗначенияПеречисления(
		"ХозяйственныеОперации",
		ДанныеВыбора,
		Параметры,
		МассивИсключаемыхЗначений);
	
КонецПроцедуры

Процедура ОбработкаПолученияДанныхВыбораГруппыФинансовогоУчетаРасчетов(ДанныеВыбора, Параметры, СтандартнаяОбработка) Экспорт
	Справочники.ГруппыФинансовогоУчетаРасчетов.ПреобразоватьОтборПараметровВыбора(Параметры.Отбор);
КонецПроцедуры

#КонецОбласти


#Область ПроцедурыИФункцииУстановкиСтатусовДляМассиваДокументов

// Возвращает соответствие массивов документов по типам
//
// Параметры:
// 		МассивСсылок - Массив из ДокументСсылка - Массив ссылок.
//
// Возвращаемое значение:
// 		Соответствие - Ключ - Тип документа, Значение - Массив ссылок на документы.
//
Функция РазложитьМассивСсылокПоТипам(МассивСсылок) Экспорт
	
	СоответствиеТипов = Новый Соответствие;
	
	Для Счетчик = 0 По МассивСсылок.Количество() -1 Цикл
		
		ТипСсылки = ТипЗнч(МассивСсылок[Счетчик]);
		Массив = СоответствиеТипов[ТипСсылки];
		Если Массив = Неопределено Тогда
			Массив = Новый Массив;
			СоответствиеТипов.Вставить(ТипСсылки, Массив);
		КонецЕсли;
		Массив.Добавить(МассивСсылок[Счетчик]);
		
	КонецЦикла;
	
	Возврат СоответствиеТипов;
	
КонецФункции // РазложитьМассивСсылокПоТипам

#КонецОбласти

#Область МетодыРаботыСРеквизитамиОбъектов

// Позволяет определить есть ли среди реквизитов табличной части объекта реквизит с переданным именем.
//
// Параметры:
//  ИмяРеквизита - Строка - Строковое имя искомого реквизита.
//  МетаданныеОбъекта - ОбъектМетаданных - описание метаданных объекта, среди реквизитов которого производится поиск.
//  ИмяТабЧасти  - Строка - Строковое имя табличной части объекта, среди реквизитов которого производится поиск.
//
// Возвращаемое значение:
//  Булево - Истина, нашли реквизит с таким именем, Ложь - не нашли.
//
Функция ЕстьРеквизитТабЧастиОбъекта(ИмяРеквизита, МетаданныеОбъекта, ИмяТабЧасти) Экспорт

	ТабЧасть = МетаданныеОбъекта.ТабличныеЧасти.Найти(ИмяТабЧасти);

	Если ТабЧасть = Неопределено Тогда // нет такой таб. части
		Возврат Ложь;
	КонецЕсли;
	
	Возврат ТабЧасть.Реквизиты.Найти(ИмяРеквизита) <> Неопределено;
	
КонецФункции

#КонецОбласти

#Область ЗаменаСсылокПоИнформационнойБазе

// Заменяет ссылки по информационной базе.
//
// Параметры:
//	ПарыЗамен - Соответствие - ключи содержат замещаемых, значения содержат заменители
//	Исключения - Массив - необязателен, значения типа ОбъектМетаданных, в экземплярах которых замены проводить нельзя.
//
Процедура ЗаменитьСсылки(ПарыЗамен, Исключения = Неопределено) Экспорт
	УстановитьПривилегированныйРежим(Истина);
	
	Английский = Метаданные.СвойстваОбъектов.ВариантВстроенногоЯзыка.Английский;
	ДвиженияССубконтоИмя = ?(Метаданные.ВариантВстроенногоЯзыка = Английский, ".RecordsWithExtDimensions", ".ДвиженияССубконто");
	
	Если Исключения = Неопределено Тогда
		Исключения = Новый Массив;
	КонецЕсли;
	
	// [ссылающийся объект](.Метаданные, .Замены[(.Замещаемое, .Заменитель)], .ТипыЗамещаемых[]).
	ИндексЗамены = ИндексЗамены(ПарыЗамен);
	КешПолей = Новый Соответствие;
	// Обходим индекс и в каждом ключе-объекта полностью замещаем все ссылки, подлежащие замене.
	Для Каждого УзелЗамены Из ИндексЗамены Цикл
		Ссылка = УзелЗамены.Ключ;
		МетаданныеУзла = УзелЗамены.Значение.Метаданные; // ОбъектМетаданных - 
		Замены = УзелЗамены.Значение.Замены;
		ТипыЗамещаемых = УзелЗамены.Значение.ТипыЗамещаемых;
		
		Если Исключения.Найти(МетаданныеУзла) <> Неопределено Тогда
			Продолжить;
		КонецЕсли;
		
		Если ЭтоСсылочныйОбъектМетаданных(МетаданныеУзла) Тогда
			// любой ссылочный объект
			ОбъектДанных = Ссылка.ПолучитьОбъект();
			Если ОбъектДанных <> Неопределено Тогда
				ПолноеИмя = МетаданныеУзла.ПолноеИмя();
				ИменаПолей = ИменаПолейСТипами(КешПолей, ПолноеИмя, ТипыЗамещаемых, "Ссылка, Ref");
				ЗаменитьЗначения(ОбъектДанных, ИменаПолей, Замены);
				// табчасти объекта
				ЗаменитьВТабчастях(
					КешПолей, МетаданныеУзла.ТабличныеЧасти, ОбъектДанных, ПолноеИмя, Замены, ТипыЗамещаемых, Исключения);
				// стандартные табчасти планов
				Если Метаданные.ПланыСчетов.Содержит(МетаданныеУзла) Или Метаданные.ПланыВидовРасчета.Содержит(МетаданныеУзла) Тогда
					ЗаменитьВТабчастях(
						КешПолей, МетаданныеУзла.СтандартныеТабличныеЧасти, ОбъектДанных, ПолноеИмя, Замены, ТипыЗамещаемых, Исключения);
				КонецЕсли;
				// пишем сам объект
				ЗаписатьДанные(ОбъектДанных);
				ОбъектДанных = Неопределено;
			КонецЕсли;
		ИначеЕсли Метаданные.Константы.Содержит(МетаданныеУзла) Тогда
			// значения в константах
			Константа = Константы[МетаданныеУзла.Имя];
			Константа.Установить(НовоеЗначение(Константа.Получить(), Замены));
		ИначеЕсли Метаданные.РегистрыСведений.Содержит(МетаданныеУзла) Тогда
			// необъектные таблицы
			ИменаПолей = ИменаПолейСТипами(КешПолей, МетаданныеУзла.ПолноеИмя(), ТипыЗамещаемых);
			Отборы = ОтборыРегистраСведений(МетаданныеУзла, Ссылка);
			Набор = НаборЗаписей(РегистрыСведений[МетаданныеУзла.Имя], Отборы);
			
			Таблица = Набор.Выгрузить();
			Набор.Очистить();
			ЗаписатьДанные(Набор);

			ЗаменитьЗначения(Таблица[0], ИменаПолей, Замены);
			Для Каждого ИмяПоля Из ИменаПолей Цикл
				Если Не Отборы.Свойство(ИмяПоля) Тогда
					Продолжить;
				КонецЕсли;
				ЭлементОтбора = Набор.Отбор[ИмяПоля]; // ЭлементОтбора - 
				ЭлементОтбора.Установить(НовоеЗначение(Отборы[ИмяПоля], Замены));
			КонецЦикла;
			Набор.Загрузить(Таблица);
			ЗаписатьДанные(Набор);
		КонецЕсли;
		// обработка движений документа
		Если Метаданные.Документы.Содержит(МетаданныеУзла) Тогда
			Для Каждого Движение Из МетаданныеУзла.Движения Цикл
				ДопТаблица = "";
				Если Исключения.Найти(Движение) <> Неопределено Тогда
					Продолжить;
				КонецЕсли;
				Если Метаданные.РегистрыНакопления.Содержит(Движение) Тогда
					Регистр = РегистрыНакопления[Движение.Имя];
				ИначеЕсли Метаданные.РегистрыСведений.Содержит(Движение) Тогда
					Регистр = РегистрыСведений[Движение.Имя];
				ИначеЕсли Метаданные.РегистрыБухгалтерии.Содержит(Движение) Тогда
					ДопТаблица = ДвиженияССубконтоИмя;
					Регистр = РегистрыБухгалтерии[Движение.Имя];
				ИначеЕсли Метаданные.РегистрыРасчета.Содержит(Движение) Тогда
					Регистр = РегистрыРасчета[Движение.Имя];
				КонецЕсли;
				ЗаменитьВПодчиненномРегистре(КешПолей, Регистр, Ссылка, Движение.ПолноеИмя() + ДопТаблица, Замены, ТипыЗамещаемых);
			КонецЦикла;
			// обработка последовательностей, включающих документ
			Для Каждого Движение Из Метаданные.Последовательности Цикл
				Если Исключения.Найти(Движение) <> Неопределено Тогда
					Продолжить;
				КонецЕсли;
				Если Движение.Документы.Содержит(МетаданныеУзла) Тогда
					ЗаменитьВПодчиненномРегистре(
						КешПолей, Последовательности[Движение.Имя], Ссылка, Движение.ПолноеИмя(), Замены, ТипыЗамещаемых);
				КонецЕсли;
			КонецЦикла;
		КонецЕсли;
	КонецЦикла;
	
КонецПроцедуры

// Строим соответствие вида [ссылающийся объект](.Метаданные, .Замены[(.Замещаемое, .Заменитель)], .ТипыЗамещаемых[])
// в итоге представляем результаты поиска по ссылкам в индексе с ключом-объектом, содержащим замещаемые ссылки.
//
Функция ИндексЗамены(ПарыЗамен)
	
	СписокСсылок = Новый Массив;
	Для Каждого Пара Из ПарыЗамен Цикл
		СписокСсылок.Добавить(Пара.Ключ);
	КонецЦикла;
	РезультатыПоиска = НайтиПоСсылкам(СписокСсылок);
	// (.Ссылка: исходная ссылка; .Данные: ссылающийся объект; .Метаданные: метаданные ссылающегося объекта).
	
	ИндексЗамены = Новый Соответствие;
	Для Каждого Результат Из РезультатыПоиска Цикл
		УзелЗамены = ИндексЗамены[Результат.Данные];
		Если Неопределено = УзелЗамены Тогда
			УзелЗамены =
				Новый Структура("Метаданные, Замены, ТипыЗамещаемых", Результат.Метаданные, Новый Массив, Новый Массив);
			ИндексЗамены.Вставить(Результат.Данные, УзелЗамены);
		КонецЕсли;

		УзелЗамены.Замены.Добавить(
			Новый Структура("Замещаемое, Заменитель", Результат.Ссылка, ПарыЗамен[Результат.Ссылка]));

		ТипЗамещаемого = ТипЗнч(Результат.Ссылка);
		Если Неопределено = УзелЗамены.ТипыЗамещаемых.Найти(ТипЗамещаемого) Тогда
			УзелЗамены.ТипыЗамещаемых.Добавить(ТипЗамещаемого);
		КонецЕсли;
	КонецЦикла;
	
	Возврат ИндексЗамены;
КонецФункции

// Параметры:
// 	КешПолей - Соответствие -
// 	ОписанияТабчастей - Массив Из ОбъектМетаданныхТабличнаяЧасть - 
// 	Объект - ДокументОбъект, СправочникОбъект - 
// 	ИмяОсновнойТаблицы - Строка - Описание
// 	Замены - Соответствие -
// 	ТипыЗамещаемых - Массив из Тип -
// 	Исключения - Массив, Неопределено -
Процедура ЗаменитьВТабчастях(КешПолей, ОписанияТабчастей, Объект, ИмяОсновнойТаблицы, Замены, ТипыЗамещаемых, Исключения)
	Для Каждого Описание Из ОписанияТабчастей Цикл
		Если Исключения.Найти(Описание) <> Неопределено Тогда
			Продолжить;
		КонецЕсли;
		ИменаПолей = ИменаПолейСТипами(КешПолей, ИмяОсновнойТаблицы + "." + Описание.Имя, ТипыЗамещаемых, "Ссылка, Ref");
		Для Каждого Табстрока Из Объект[Описание.Имя] Цикл
			ЗаменитьЗначения(Табстрока, ИменаПолей, Замены);
		КонецЦикла;
	КонецЦикла;
КонецПроцедуры

Процедура ЗаменитьВПодчиненномРегистре(КешПолей, МенеджерРегистра, Ссылка, ИмяТаблицыРегистра, Замены, ТипыЗамещаемых)
	ИменаПолей = ИменаПолейСТипами(КешПолей, ИмяТаблицыРегистра, ТипыЗамещаемых, "Регистратор, Recorder");
	Набор = НаборЗаписей(МенеджерРегистра, Новый Структура("Регистратор", Ссылка));
	ЗначениеЗаменено = Ложь;
	Для Каждого Запись Из Набор Цикл
		ЗаменитьЗначения(Запись, ИменаПолей, Замены, ЗначениеЗаменено);
	КонецЦикла;
	ЗаписатьДанные(Набор, ЗначениеЗаменено);
КонецПроцедуры

Функция ИменаПолейСТипами(КешПолейТаблиц, ИмяТаблицы, ТипыДанных, ИменаИсключений = "")
	
	ИменаПолей  = Новый Массив;
	Исключения  = Новый Структура(ИменаИсключений);
	ПоляТаблицы = КешПолейТаблиц.Получить(ИмяТаблицы);
	
	Если ПоляТаблицы = Неопределено Тогда
		
	    ПоляТаблицы = Новый Массив;
		
	    СхемаЗапроса = Новый СхемаЗапроса;
	    СхемаЗапроса.УстановитьТекстЗапроса(
			СтрЗаменить("ВЫБРАТЬ * ИЗ ТаблицаВыборки КАК Т ГДЕ ЛОЖЬ", "ТаблицаВыборки", ИмяТаблицы));
		
		Для Каждого КолонкаЗапроса Из СхемаЗапроса.ПакетЗапросов[0].Колонки Цикл
	        Если ТипЗнч(КолонкаЗапроса) = Тип("КолонкаСхемыЗапроса") Тогда
	            ПоляТаблицы.Добавить(
					Новый Структура("Имя,ТипЗначения", КолонкаЗапроса.Псевдоним, КолонкаЗапроса.ТипЗначения));
	        КонецЕсли; 
	    КонецЦикла;
		
	    КешПолейТаблиц.Вставить(ИмяТаблицы, ПоляТаблицы);
		
	КонецЕсли;
	
	Для Каждого Поле Из ПоляТаблицы Цикл
		
		Если Исключения.Свойство(Поле.Имя) Тогда
			Продолжить;
		КонецЕсли;
		
		Для Каждого ТипДанных Из ТипыДанных Цикл
			Если Поле.ТипЗначения.СодержитТип(ТипДанных) И ИменаПолей.Найти(Поле.Имя) = Неопределено Тогда
				ИменаПолей.Добавить(Поле.Имя);
			КонецЕсли;
		КонецЦикла;
		
	КонецЦикла;
	
    Возврат ИменаПолей;
	
КонецФункции

Процедура ЗаменитьЗначения(Данные, ИменаПолей, Замены, Заменено = Ложь)
	Для Каждого ИмяПоля Из ИменаПолей Цикл
		НовоеЗначение = НовоеЗначение(Данные[ИмяПоля], Замены);
		Если НовоеЗначение <> Данные[ИмяПоля] Тогда;
			Заменено = Истина;
			Данные[ИмяПоля] = НовоеЗначение;
		КонецЕсли;
	КонецЦикла;
КонецПроцедуры

Функция НовоеЗначение(СтароеЗначение, Замены)
	Для Каждого Замена Из Замены Цикл
		Если СтароеЗначение = Замена.Замещаемое Тогда
			Возврат Замена.Заменитель;
		КонецЕсли;
	КонецЦикла;
	Возврат СтароеЗначение;
КонецФункции

Процедура ЗаписатьДанные(Данные, Принудительно = Ложь)
	Если Данные.Модифицированность() Или Принудительно Тогда
		Данные.ОбменДанными.Загрузка = Истина;
		Данные.Записать();
	КонецЕсли;
КонецПроцедуры

// Параметры:
// 	МетаданныеРегистра - ОбъектМетаданныхРегистрСведений -
// 	Запись - РегистрСведенийЗаписьИмяРегистраСведений -
// Возвращаемое значение:
// 	Структура - 
//  
Функция ОтборыРегистраСведений(МетаданныеРегистра, Запись)
	Отборы = Новый Структура;
	Если МетаданныеРегистра.ПериодичностьРегистраСведений <> Метаданные.СвойстваОбъектов.ПериодичностьРегистраСведений.Непериодический Тогда
		Отборы.Вставить("Период", Запись.Период);
	КонецЕсли;
	Для Каждого Измерение Из МетаданныеРегистра.Измерения Цикл
		Отборы.Вставить(Измерение.Имя, Запись[Измерение.Имя]);
	КонецЦикла;
	Возврат Отборы;
КонецФункции

// Параметры:
// 	МенеджерРегистра - РегистрСведенийМенеджер - 
// 	                 - РегистрыНакопленияМенеджер - 
// 	Отборы - Структура - Описание:
// 					* Период - Дата -
// Возвращаемое значение:
// 	РегистрСведенийНаборЗаписей, РегистрНакопленияНаборЗаписей -
//
Функция НаборЗаписей(МенеджерРегистра, Отборы)
	
	Набор = МенеджерРегистра.СоздатьНаборЗаписей();
	Для Каждого Отбор Из Отборы Цикл
		ЭлементОтбора = Набор.Отбор[Отбор.Ключ]; // ЭлементОтбора - 
		ЭлементОтбора.Установить(Отбор.Значение);
	КонецЦикла;
	Набор.Прочитать();
	Возврат Набор;
КонецФункции

Функция ЭтоСсылочныйОбъектМетаданных(ОбъектМетаданных)
	Возврат Метаданные.Справочники.Содержит(ОбъектМетаданных)
		ИЛИ Метаданные.Документы.Содержит(ОбъектМетаданных)
		ИЛИ Метаданные.Перечисления.Содержит(ОбъектМетаданных)
		ИЛИ Метаданные.ПланыВидовХарактеристик.Содержит(ОбъектМетаданных)
		ИЛИ Метаданные.ПланыСчетов.Содержит(ОбъектМетаданных)
		ИЛИ Метаданные.ПланыВидовРасчета.Содержит(ОбъектМетаданных)
		ИЛИ Метаданные.БизнесПроцессы.Содержит(ОбъектМетаданных)
		ИЛИ Метаданные.Задачи.Содержит(ОбъектМетаданных)
		ИЛИ Метаданные.ПланыОбмена.Содержит(ОбъектМетаданных);
КонецФункции

#КонецОбласти

#Область МетодыДляОтладкиИТестирования

// Показать произвольную выборку данных в отладчике
// Пример:
//	ОбщегоНазначенияУТ.ЗапросВыполнитьВыгрузить("выбрать * из Справочник.Валюты где Валюты.Код = &Код", Новый Структура("Код", "810"))
//
// Параметры:
// 	ТекстЗапроса - Строка - 
// 	ПараметрыЗапроса - Структура -
// 	МенеджерВременныхТаблиц - МенеджерВременныхТаблиц -
//
// Возвращаемое значение:
// 	ТаблицаЗначений - 
Функция ЗапросВыполнитьВыгрузить(ТекстЗапроса, ПараметрыЗапроса = Неопределено, МенеджерВременныхТаблиц = Неопределено) Экспорт
	
	Запрос = Новый Запрос(ТекстЗапроса);
	
	Если МенеджерВременныхТаблиц <> Неопределено Тогда
		Запрос.МенеджерВременныхТаблиц = МенеджерВременныхТаблиц;
	КонецЕсли;
	
	Если ЗначениеЗаполнено(ПараметрыЗапроса) Тогда
		Для Каждого Параметр Из ПараметрыЗапроса Цикл
			Запрос.УстановитьПараметр(Параметр.Ключ, Параметр.Значение);
		КонецЦикла;
	КонецЕсли;
	
	Возврат Запрос.Выполнить().Выгрузить();
	
КонецФункции

// Показать временную таблицу из менеджера временных таблиц.
// Используется для просмотра временных таблиц в отладчике.
// Пример вызова функции:
//	ОбщегоНазначенияУТ.ПоказатьВременнуюТаблицу(Запрос, "ТаблицаТоваров")
//
// Параметры:
// 	МенеджерВременныхТаблицИлиЗапрос - МенеджерВременныхТаблиц - 
//	                                 - Запрос -
//  ИмяВременнойТаблицы - Строка - 
//
// Возвращаемое значение:
// 	ТаблицаЗначений - Данные временной таблицы
//
Функция ПоказатьВременнуюТаблицу(МенеджерВременныхТаблицИлиЗапрос, ИмяВременнойТаблицы) Экспорт
	
	ЗакрытьМенеджерВременныхТаблиц = Ложь;
	
	Если ТипЗнч(МенеджерВременныхТаблицИлиЗапрос) = Тип("Запрос") Тогда
		Если МенеджерВременныхТаблицИлиЗапрос.МенеджерВременныхТаблиц = Неопределено Тогда
			МенеджерВременныхТаблиц = Новый МенеджерВременныхТаблиц;
			ЗакрытьМенеджерВременныхТаблиц = Истина;
			МенеджерВременныхТаблицИлиЗапрос.МенеджерВременныхТаблиц = МенеджерВременныхТаблиц; 
		Иначе
			МенеджерВременныхТаблиц = МенеджерВременныхТаблицИлиЗапрос.МенеджерВременныхТаблиц;
		КонецЕсли;
		МенеджерВременныхТаблицИлиЗапрос.Выполнить();
	Иначе
		МенеджерВременныхТаблиц = МенеджерВременныхТаблицИлиЗапрос;
	КонецЕсли; 
	
	ТекстЗапроса = 
	"ВЫБРАТЬ
	|	*
	|ИЗ
	|	&ВременнаяТаблица";
	ТекстЗапроса = СтрЗаменить(ТекстЗапроса, "&ВременнаяТаблица", ИмяВременнойТаблицы);
	
	ДанныеТаблицы = ЗапросВыполнитьВыгрузить(ТекстЗапроса,, МенеджерВременныхТаблиц);
	
	Если ЗакрытьМенеджерВременныхТаблиц Тогда
		МенеджерВременныхТаблиц.Закрыть();
		МенеджерВременныхТаблицИлиЗапрос.МенеджерВременныхТаблиц = Неопределено;
	КонецЕсли; 
	
	Возврат ДанныеТаблицы;
	
КонецФункции


// Описание
// 
// Параметры:
// 	ПолноеИмяФайла	- Строка	- полный путь к файлу
// Возвращаемое значение:
// 	ТипФайлаТабличногоДокумента - тип файла табличного документа, соответствующий переданному значению
Функция ПолучитьТипФайлаТабличногоДокументаПоПолномуИмени(ПолноеИмяФайла) Экспорт
	
	СоответствияРасширенияТипуФайла = Новый Соответствие();
	СоответствияРасширенияТипуФайла.Вставить(".DOCX",	ТипФайлаТабличногоДокумента.DOCX);
	СоответствияРасширенияТипуФайла.Вставить(".HTML",	ТипФайлаТабличногоДокумента.HTML);
	СоответствияРасширенияТипуФайла.Вставить(".ODS",		ТипФайлаТабличногоДокумента.ODS);
	СоответствияРасширенияТипуФайла.Вставить(".PDF",		ТипФайлаТабличногоДокумента.PDF);
	СоответствияРасширенияТипуФайла.Вставить(".TXT",		ТипФайлаТабличногоДокумента.TXT);
	СоответствияРасширенияТипуФайла.Вставить(".XLS",		ТипФайлаТабличногоДокумента.XLS);
	СоответствияРасширенияТипуФайла.Вставить(".XLSX",	ТипФайлаТабличногоДокумента.XLSX);
	
	Файл = Новый Файл(ПолноеИмяФайла);
	ТипФайла = СоответствияРасширенияТипуФайла.Получить(ВРег(Файл.Расширение));
	
	Возврат ?(ТипФайла = Неопределено, ТипФайлаТабличногоДокумента.MXL, ТипФайла);

КонецФункции

// Преобразует таблицу значений в табличный документ и сохраняет его в файл.
//
// Параметры:
//  Таблица									 - ТаблицаЗначений	 - произвольная таблица значений
//  ПолноеИмяФайла							 - Строка			 - полное имя сохраняемого файла, с расширением.
//  Оформить								 - Булево			 - см. описание параметра в функции ОбщегоНазначенияУТ.ТабличныйДокументИзТаблицыЗначений
//  МетаданныеТабличнойЧастиДляЗаголовков	 - ОбъектМетаданныхТабличнаяЧасть, Неопределено - см. описание
//																		параметра в функции ОбщегоНазначенияУТ.ТабличныйДокументИзТаблицыЗначений
// 
// Возвращаемое значение:
//  Строка - текст сообщения об ошибке или пустая строка, если запись выполнена успешно.
//
// Примеры:
// 	ОбщегоНазначенияУТ.СохранитьТаблицуЗначенийВФайл(Таблица, "c:\temp\таблица.mxl")
//  ОбщегоНазначенияУТ.СохранитьТаблицуЗначенийВФайл(ОбщегоНазначенияУТ.ПоказатьВременнуюТаблицу(МВТ, "Таблица"), "c:\temp\таблица.mxl")
//
Функция СохранитьТаблицуЗначенийВФайл(Таблица, ПолноеИмяФайла, Оформить = Ложь, МетаданныеТабличнойЧастиДляЗаголовков = Неопределено) Экспорт
	
	ВыгрузкаТаблицы = ТабличныйДокументИзТаблицыЗначений(Таблица, Оформить, МетаданныеТабличнойЧастиДляЗаголовков);
	
	// Сохраним табличный документ в файл
	ТекстОшибки = "";
	Попытка
		ВыгрузкаТаблицы.Записать(ПолноеИмяФайла, ПолучитьТипФайлаТабличногоДокументаПоПолномуИмени(ПолноеИмяФайла));
	Исключение
		ТекстОшибки = ПодробноеПредставлениеОшибки(ИнформацияОбОшибке());
	КонецПопытки;
	
	Возврат ТекстОшибки;
	
КонецФункции

// Возвращает представление таблицы значений в виде табличного документа
//
// Параметры:
//  Таблица	- ТаблицаЗначений -
//  Оформить - Булево - если передано ИСТИНА, то
//							добавляется пустая строка перед шапкой,
//							шапка выделяется цветом фона, иначе - жирным шрифтом,
//							ширина колонки устанавливается по ширине заголовка, иначе ширина по умолчанию,
//							устанавливаются свойства табличного документа ТолькоПросмотр = Истина,ОтображатьСетку = Ложь, ОтображатьЗаголовки = Ложь.
//  МетаданныеТабличнойЧастиДляЗаголовков - ОбъектМетаданныхТабличнаяЧасть -
//	                                      - Неопределено -
//  											если переданы метаданные, то в шапке таблицы выводятся синонимы полей из метаданных
//                                              если колонка таблицы значений не найдена - она не выводится в табличный документ
//                                              если метаданные не переданы, то в шапке показываются заголовки колонок из таблицы значений,
//                                              	если заголовков нет - показываются имена колонок.
// 
// Возвращаемое значение:
//   ТабличныйДокумент -
//
Функция ТабличныйДокументИзТаблицыЗначений(Таблица, Оформить = Ложь, МетаданныеТабличнойЧастиДляЗаголовков = Неопределено) Экспорт
	
	ВыгрузкаТаблицы = Новый ТабличныйДокумент; // преобразованная в mxl таблица значений
	
	Если Оформить Тогда
		НомерСтроки  = 2;
	Иначе
		НомерСтроки  = 1;
	КонецЕсли;	
		
	НомерКолонки = 0;
	
	// Сформируем шапку табличного документа - выведем имена колонок таблицы значений
	Для Каждого ТекКолонка Из Таблица.Колонки Цикл
		
		НомерКолонки = НомерКолонки + 1;
		
		Область = ВыгрузкаТаблицы.Область(НомерСтроки, НомерКолонки, НомерСтроки, НомерКолонки);
		Если МетаданныеТабличнойЧастиДляЗаголовков = Неопределено Тогда 
			Область.Текст = ?(ЗначениеЗаполнено(ТекКолонка.Заголовок), ТекКолонка.Заголовок, ТекКолонка.Имя);
		Иначе
			Реквизит = МетаданныеТабличнойЧастиДляЗаголовков.Реквизиты.Найти(ТекКолонка.Имя);
			Если Реквизит = Неопределено Тогда
				Область.ШиринаКолонки = 1;
				Продолжить;
			Иначе
				Область.Текст = Реквизит.Синоним;
			КонецЕсли;
		КонецЕсли;
		Область.ГраницаСнизу  = Новый Линия(ТипЛинииЯчейкиТабличногоДокумента.Сплошная, 1);
		Область.ГраницаСверху = Новый Линия(ТипЛинииЯчейкиТабличногоДокумента.Сплошная, 1);
		Область.ГраницаСлева  = Новый Линия(ТипЛинииЯчейкиТабличногоДокумента.Сплошная, 1);
		Область.ГраницаСправа = Новый Линия(ТипЛинииЯчейкиТабличногоДокумента.Сплошная, 1);
		
		Если Оформить Тогда
			Область.ЦветФона = ЦветаСтиля.ИтогиФонГруппы;	
			Область.ШиринаКолонки = СтрДлина(Область.Текст);
		Иначе
			Область.Шрифт    = Новый Шрифт(Область.Шрифт,,, Истина); 
		КонецЕсли;
		
	КонецЦикла;
	
	// Выведем строки таблицы значений
	Для Каждого ТекСтр Из Таблица Цикл
		
		НомерСтроки = НомерСтроки + 1;
		НомерКолонки = 0;
		
		Для Каждого ТекКолонка Из Таблица.Колонки Цикл
			НомерКолонки = НомерКолонки + 1;
			
			Если МетаданныеТабличнойЧастиДляЗаголовков <> Неопределено Тогда 
				Реквизит = МетаданныеТабличнойЧастиДляЗаголовков.Реквизиты.Найти(ТекКолонка.Имя);
				Если Реквизит = Неопределено Тогда
					Продолжить;
				КонецЕсли;
			КонецЕсли;	
			
			Область = ВыгрузкаТаблицы.Область(НомерСтроки, НомерКолонки, НомерСтроки, НомерКолонки);
			Область.Текст         = Строка(ТекСтр[ТекКолонка.Имя]);
			Область.ГраницаСнизу  = Новый Линия(ТипЛинииЯчейкиТабличногоДокумента.Сплошная, 1);
			Область.ГраницаСверху = Новый Линия(ТипЛинииЯчейкиТабличногоДокумента.Сплошная, 1);
			Область.ГраницаСлева  = Новый Линия(ТипЛинииЯчейкиТабличногоДокумента.Сплошная, 1);
			Область.ГраницаСправа = Новый Линия(ТипЛинииЯчейкиТабличногоДокумента.Сплошная, 1);
			
		КонецЦикла;
		
	КонецЦикла;
	
	ВыгрузкаТаблицы.ФиксацияСверху = 1;
	ВыгрузкаТаблицы.ФиксацияСлева  = 1;
	
	Если Оформить Тогда
		
		ВыгрузкаТаблицы.ТолькоПросмотр      = Истина;
		ВыгрузкаТаблицы.ОтображатьСетку     = Ложь;
		ВыгрузкаТаблицы.ОтображатьЗаголовки = Ложь;
		
	КонецЕсли;
	
	Возврат ВыгрузкаТаблицы;
	
КонецФункции

// Считывает таблицу значений из табличного документа.
// Помещение таблицы значений в текстовый документ можно выполнить функцией СохранитьТаблицуЗначенийВФайл().
// В первой строке таблицы должны быть указаны имена колонок таблицы значений,
// в остальных строках - значения в соответствующих ячейках таблицы значений.
// Пример вызова функции:
// 	ОбщегоНазначенияУТ.ПолучитьТаблицуЗначенийИзФайла("c:\temp\таблица.mxl").
//
// Параметры:
//	ПолноеИмяФайла - Строка - полное имя считываемого файла, с расширением.
//
// Возвращаемое значение:
//	Строка 			- если при чтении файла произошла ошибка, то возвращается текст сообщения об ошибке;
//	ТаблицаЗначений - если ошибок не было, то возвращается считанная таблица значений.
//
Функция ПолучитьТаблицуЗначенийИзФайла(ПолноеИмяФайла) Экспорт
	
	ВыгрузкаТаблицы = Новый ТабличныйДокумент; // преобразованная в mxl таблица значений
	
	// Прочитаем файл.
	Попытка
		ВыгрузкаТаблицы.Прочитать(ПолноеИмяФайла);
	Исключение
		
		ТекстОшибки = СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
			НСтр("ru = 'Невозможно прочитать таблицу значений из файла ""%1"":
				|%2';
				|en = 'Cannot read table of values from the ""%1"" file:
				|%2'"),
			ПолноеИмяФайла,
			ИнформацияОбОшибке());
		
		Возврат ТекстОшибки;
		
	КонецПопытки;
	
	Таблица = Новый ТаблицаЗначений;
	
	Если ВыгрузкаТаблицы.ВысотаТаблицы = 0 ИЛИ ВыгрузкаТаблицы.ШиринаТаблицы = 0 Тогда
		Возврат Таблица;
	КонецЕсли;
	
	// Создадим колонки таблицы значений.
	НомерСтроки = 1;
	
	// В первой строке таблицы должны быть перечислены имена колонок.
	// Если в ячейке первой строки указан текст, не подходящий для имени колонки таблицы значений, то вернем сообщение об ошибке.
	Для НомерКолонки = 1 По ВыгрузкаТаблицы.ШиринаТаблицы Цикл
		
		Область = ВыгрузкаТаблицы.Область(НомерСтроки, НомерКолонки, НомерСтроки, НомерКолонки);
		ТекстЯчейки = СокрЛП(Область.Текст);
		
		Попытка
			Таблица.Колонки.Добавить(ТекстЯчейки, Новый ОписаниеТипов("Строка"));
		Исключение
			
			ТекстОшибки = СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
				НСтр("ru = 'Невозможно прочитать таблицу значений из файла ""%1"":
					|недопустимое имя колонки таблицы значений: ""%2""';
					|en = 'Cannot read the value table from the ""%1"" file:
					|invalid column name of the value table: ""%2""'"),
				ПолноеИмяФайла,
				ТекстЯчейки);
			
			Возврат ТекстОшибки;
			
		КонецПопытки;
		
	КонецЦикла;
	
	Для НомерСтроки = 2 По ВыгрузкаТаблицы.ВысотаТаблицы Цикл
		
		НоваяСтрока = Таблица.Добавить();
		
		Для НомерКолонки = 1 По ВыгрузкаТаблицы.ШиринаТаблицы Цикл
			
			Область = ВыгрузкаТаблицы.Область(НомерСтроки, НомерКолонки, НомерСтроки, НомерКолонки);
			ТекстЯчейки = СокрЛП(Область.Текст);
			
			НоваяСтрока[Таблица.Колонки[НомерКолонки - 1].Имя] = ТекстЯчейки;
			
		КонецЦикла;
		
	КонецЦикла;
	
	Возврат Таблица;
	
КонецФункции

#КонецОбласти

#Область СистемныеОпределяютПоведениеКонфигурации

// Проверяет соблюдение условий открытия базовой версии конфигурации в режиме Предприятие.
//
// Возвращаемое значение:
// 	Булево - Если текущая версия конфигурации не является базовой, то возвращается значение Истина.
//           Если текущая версия конфигурации является базовой, то возвращается значение Истина.
//	         В случае, если ИБ развернута в файловом варианте и запускается в однопользовательском режиме.
//
Функция ВозможенЗапускБазовойВерсии() Экспорт
	
	Если НЕ СтандартныеПодсистемыСервер.ЭтоБазоваяВерсияКонфигурации() Тогда
		Возврат Истина; // ОК: это не базовая версия
	КонецЕсли;
	
	Если НЕ ОбщегоНазначения.ИнформационнаяБазаФайловая(СтрокаСоединенияИнформационнойБазы()) Тогда
		Возврат Ложь; // не файловая ИБ
	КонецЕсли;
	
	СеансыИнформационнойБазы = ПолучитьСеансыИнформационнойБазы();
	НомерТекущегоСеанса		 = НомерСеансаИнформационнойБазы();
	ЗапрещенныеПриложения	 = ",1CV8,1CV8C,WebClient,WSConnection,COMConnection,";
	
	Для Каждого СеансИБ Из СеансыИнформационнойБазы Цикл
		
		Если СеансИБ.НомерСеанса = НомерТекущегоСеанса Тогда
			Продолжить;
		ИначеЕсли СтрНайти(ЗапрещенныеПриложения, "," + СеансИБ.ИмяПриложения + ",") > 0 Тогда
			Возврат Ложь; // открыты другие сеансы 1С:Предприятия
		КонецЕсли;
		
	КонецЦикла;
	
	Возврат Истина; // ОК: это файловая ИБ в однопользовательском режиме
	
КонецФункции

#КонецОбласти

#Область Константы

// Возвращает состав набор констант.
//
// Параметры:
//	Набор - КонстантыНабор -
//
// Возвращаемое значение:
//  Структура -
//		Ключ - имя константы из набора.
//
Функция ПолучитьСтруктуруНабораКонстант(Набор) Экспорт
	
	Результат = Новый Структура;
	
	Для Каждого МетаКонстанта Из Метаданные.Константы Цикл
		Если ОбщегоНазначенияУТКлиентСервер.ЕстьРеквизитОбъекта(Набор, МетаКонстанта.Имя) Тогда
			Результат.Вставить(МетаКонстанта.Имя);
		КонецЕсли;
	КонецЦикла;
	
	Возврат Результат;
	
КонецФункции

#КонецОбласти

#Область Перечисления

// Получает список выбора для указанного перечисления.
//
// Параметры:
//	ИмяПеречисления 	- Строка - имя перечисления как оно задано в конфигураторе.
//	ДанныеВыбора 		- СписокЗначений - сформированный список выбора перечисления.
//	Параметры 			- Структура - подробнее см. ОбработкаПолученияДанныхВыбора
//	ИсключаемыеЗначения - Массив - значения перечисления, не включаемые в список выбора.
//
Процедура ДоступныеДляВыбораЗначенияПеречисления(ИмяПеречисления, ДанныеВыбора, Параметры = Неопределено, ИсключаемыеЗначения = Неопределено) Экспорт
	
	Если Параметры = Неопределено Тогда
		Параметры = Новый Структура;
		Параметры.Вставить("Отбор", Новый Структура);
		Параметры.Вставить("СтрокаПоиска", "");
	КонецЕсли;
	
	ДанныеВыбора = Новый СписокЗначений; // результат
	
	Запрос = Новый Запрос;
	ТекстЗапроса =
	"ВЫБРАТЬ
	|	ЗначенияПеречисления.Ссылка КАК Ссылка,
	|	ПРЕДСТАВЛЕНИЕ(ЗначенияПеречисления.Ссылка) КАК Представление
	|ИЗ
	|	&Таблица КАК ЗначенияПеречисления
	|ГДЕ
	|	НЕ ЗначенияПеречисления.Ссылка В (&ИсключаемыеЗначения)
	|	И &ОтборПоСсылке
	|
	|УПОРЯДОЧИТЬ ПО
	|	ЗначенияПеречисления.Порядок";
	
	Если ИсключаемыеЗначения = Неопределено Тогда
		Запрос.УстановитьПараметр("ИсключаемыеЗначения", Новый Массив);
	Иначе
		Запрос.УстановитьПараметр("ИсключаемыеЗначения", ИсключаемыеЗначения);
	КонецЕсли;
	
	Если Параметры.Отбор.Свойство("Ссылка") Тогда
		ТекстЗапроса = СтрЗаменить(ТекстЗапроса, "&ОтборПоСсылке", "ЗначенияПеречисления.Ссылка В (&ОтборПоСсылке)");
		Запрос.УстановитьПараметр("ОтборПоСсылке", Параметры.Отбор.Ссылка);
	Иначе
		ТекстЗапроса = СтрЗаменить(ТекстЗапроса, "&ОтборПоСсылке", "ИСТИНА");
	КонецЕсли;
	
	Запрос.Текст = СтрЗаменить(ТекстЗапроса, "&Таблица", "Перечисление." + ИмяПеречисления);
	
	Выборка = Запрос.Выполнить().Выбрать();
	
	Пока Выборка.Следующий() Цикл
		
		Если НЕ ЗначениеЗаполнено(Параметры.СтрокаПоиска)
		 ИЛИ СтрНайти(НРег(Выборка.Представление), НРег(Параметры.СтрокаПоиска)) = 1 Тогда
			ДанныеВыбора.Добавить(Выборка.Ссылка);
		КонецЕсли;
		
	КонецЦикла;
	
КонецПроцедуры

#КонецОбласти

#Область ДополнительныеРеквизитыИСведения

// Служебная. Возвращает наборы доп. реквизитов и сведений, доступных при данных настройках конфигурации.
//
// Возвращаемое значение:
//	Массив Из СправочникСсылка.НаборыДополнительныхРеквизитовИСведений -
//
Функция ДоступныеДопРеквизитыИСведения() Экспорт
	
	ДоступныеСвойства = Новый Массив;
	
	СвязиСвойствИФО = ОбщегоНазначенияУТПовтИсп.СвязиДопРеквизитовИФункциональныхОпций();
	
	Для Каждого КлючИЗначение Из СвязиСвойствИФО Цикл
		
		Если НЕ ЗначениеЗаполнено(КлючИЗначение.Значение) Тогда
			
			// Этот набор доп. свойств не зависит от ФО
			ДоступныеСвойства.Добавить(КлючИЗначение.Ключ);
			
		Иначе
			
			РодительскиеФО = Новый Структура(КлючИЗначение.Значение);
			
			Для Каждого ТекущаяФО Из РодительскиеФО Цикл
				Если ПолучитьФункциональнуюОпцию(ТекущаяФО.Ключ) Тогда
					// Включена хотя бы одна ФО, от которой зависит этот набор доп. свойств
					ДоступныеСвойства.Добавить(КлючИЗначение.Ключ);
					Прервать;
				КонецЕсли;
			КонецЦикла;
			
		КонецЕсли;
		
	КонецЦикла;
	
	Возврат ДоступныеСвойства;
	
КонецФункции

#КонецОбласти

#Область Подсистемы

// Добавляет подсистему в коллекцию.
//
// Параметры:
//	Коллекция - Массив - 
//	          - СписокЗначений - коллекция, куда добавляется подсистема из метаданных
//	ИмяПодсистемы - Строка - имя подсистемы. Подчиненные подсистемы разделяются ".", служебные слова "Подсистема" или "Подсистемы" указывать не нужно.
//	Представление - Строка - представление подсистемы (для списка значений).
//
Процедура ДобавитьПодсистемуВКоллекцию(Коллекция, ИмяПодсистемы, Представление = "") Экспорт
	
	Подсистема = ПодсистемаПоИмени(ИмяПодсистемы);
	Если Подсистема = Неопределено Тогда
		Возврат; // нет такой подсистемы в метаданных
	КонецЕсли;
	
	Если ЗначениеЗаполнено(Представление) Тогда
		Коллекция.Добавить(Подсистема, Представление);
	Иначе
		Коллекция.Добавить(Подсистема);
	КонецЕсли;
	
КонецПроцедуры

// Возвращает метаданные подсистемы по ее имени.
//
// Параметры:
//	ИмяПодсистемы - Строка - имя подсистемы
//		подчиненные подсистемы разделяются ".",	служебные слова "Подсистема" или "Подсистемы" указывать не нужно.
//
// Возвращаемое значение:
//	ОбъектМетаданных - метаданные подсистемы или Неопределено, если подсистемы с таким именем не существует.
//
Функция ПодсистемаПоИмени(ИмяПодсистемы) Экспорт
	
	ПолноеИмяПодсистемы = Сред(СтрЗаменить("." + ИмяПодсистемы, ".", ".Подсистема."), 2);;
	
	Возврат Метаданные.НайтиПоПолномуИмени(ПолноеИмяПодсистемы);
	
КонецФункции

#КонецОбласти

#Область Прочее

Процедура ОбработатьВложенныеПоля(ЭлементыФормы, ЭлементФормы, МассивЭлементов, Структура, ПоляИсключения)
	
	ТипЗнчЭлементФормы = ТипЗнч(ЭлементФормы);
	
	Если ТипЗнчЭлементФормы = Тип("ТаблицаФормы")
		ИЛИ ТипЗнчЭлементФормы = Тип("ГруппаФормы") Тогда
		Если ТипЗнчЭлементФормы = Тип("ТаблицаФормы") Тогда
			ИмяЭлемента = ЭлементФормы.Имя;
			Структура.Вставить(ИмяЭлемента, Новый Массив);
			ОбработатьПоляТаблицыФормы(ЭлементыФормы, ЭлементФормы, Структура[ИмяЭлемента], ПоляИсключения);
		КонецЕсли;
		Для Каждого Элемент Из ЭлементФормы.ПодчиненныеЭлементы Цикл
			Имя = Элемент.Имя;
			ПодчиненныйЭлемент = ЭлементыФормы[Имя];
			ТипЗнчПодчиненныйЭлемент = ТипЗнч(ПодчиненныйЭлемент);
			Если ТипЗнчПодчиненныйЭлемент = Тип("ПолеФормы") Тогда
				Если МассивЭлементов.Найти(Имя) <> Неопределено
					Или ПоляИсключения.Найти(Имя) <> Неопределено Тогда
					Продолжить;
				КонецЕсли;
				МассивЭлементов.Добавить(Имя);
			ИначеЕсли ТипЗнчПодчиненныйЭлемент = Тип("ГруппаФормы") Тогда
				ОбработатьВложенныеПоля(ЭлементыФормы, ПодчиненныйЭлемент, МассивЭлементов, Структура, ПоляИсключения);
			КонецЕсли;
		КонецЦикла;
	КонецЕсли;
	
КонецПроцедуры

Процедура ОбработатьПоляТаблицыФормы(ЭлементыФормы, ЭлементФормы, МассивЭлементов, ПоляИсключения)
	
	ТипЗнчЭлементФормы = ТипЗнч(ЭлементФормы);
	
	Если ТипЗнчЭлементФормы = Тип("ТаблицаФормы")
		ИЛИ ТипЗнчЭлементФормы = Тип("ГруппаФормы") Тогда
		Для Каждого Элемент Из ЭлементФормы.ПодчиненныеЭлементы Цикл
			ПодчиненныйЭлемент = ЭлементыФормы[Элемент.Имя];
			ТипЗнчПодчиненныйЭлемент = ТипЗнч(ПодчиненныйЭлемент);
			Если ТипЗнчПодчиненныйЭлемент = Тип("ПолеФормы") Тогда
				Если МассивЭлементов.Найти(Элемент.Имя) <> Неопределено
					Или ПоляИсключения.Найти(Элемент.Имя) <> Неопределено Тогда
					Продолжить;
				КонецЕсли;
				МассивЭлементов.Добавить(Элемент.Имя);
			ИначеЕсли ТипЗнчПодчиненныйЭлемент = Тип("ГруппаФормы") Тогда
				ОбработатьПоляТаблицыФормы(ЭлементыФормы, ПодчиненныйЭлемент, МассивЭлементов, ПоляИсключения);
			КонецЕсли;
		КонецЦикла;
	КонецЕсли;
	
КонецПроцедуры

// Функция возвращает идентификатор конфигурации.
// Длина идентификатора не должна превышать 8 символов.
//
// Возвращаемое значение:
// 	Строка -
Функция ИДКонфигурации() Экспорт
	
	//++ НЕ УТКА
	Возврат "УП2"; // в конфигурации 1С:ERP

	//-- НЕ УТКА

	//++ НЕ УТ
	Возврат "КА2"; // в конфигурации КА2

	//-- НЕ УТ
	Возврат "УТ11" + ?(СтандартныеПодсистемыСервер.ЭтоБазоваяВерсияКонфигурации(), "Базовая", ""); // в конфигурации УТ11
	
КонецФункции

Функция ПолучитьПрефиксДляУИП(Ссылка)

	Соответствие = Новый Соответствие();
	Соответствие.Вставить("ДоговорыКонтрагентов",				НСтр("ru = 'ДОГ';
																		|en = 'CONT'", ОбщегоНазначения.КодОсновногоЯзыка()));
	Соответствие.Вставить("АктВыполненныхРабот",				НСтр("ru = 'АКТ';
																	|en = 'CERTIFICATE'", ОбщегоНазначения.КодОсновногоЯзыка()));
	Соответствие.Вставить("ВозвратТоваровПоставщику",			НСтр("ru = 'НКВ';
																		|en = 'VendReturn'", ОбщегоНазначения.КодОсновногоЯзыка()));
	Соответствие.Вставить("ВыкупВозвратнойТарыКлиентом",		НСтр("ru = 'НК';
																	|en = 'CustomInv'", ОбщегоНазначения.КодОсновногоЯзыка()));
	Соответствие.Вставить("ЗаказКлиента",						НСтр("ru = 'ЗК';
																		|en = 'SO'", ОбщегоНазначения.КодОсновногоЯзыка()));
	Соответствие.Вставить("ЗаявкаНаВозвратТоваровОтКлиента",	НСтр("ru = 'ЗКВ';
																	|en = 'Return request'", ОбщегоНазначения.КодОсновногоЯзыка()));
	Соответствие.Вставить("ОтчетКомиссионера",					НСтр("ru = 'ОК';
																		|en = 'ConsRep'", ОбщегоНазначения.КодОсновногоЯзыка()));
	Соответствие.Вставить("ОтчетКомиссионераОСписании",			НСтр("ru = 'ОКС';
																		|en = 'ConsStockLost'", ОбщегоНазначения.КодОсновногоЯзыка()));
	Соответствие.Вставить("ОтчетКомитенту",						НСтр("ru = 'ОКТ';
																		|en = 'ConsRep'", ОбщегоНазначения.КодОсновногоЯзыка()));
	Соответствие.Вставить("ОтчетПоКомиссииМеждуОрганизациями",	НСтр("ru = 'ОКО';
																		|en = 'ComRep'", ОбщегоНазначения.КодОсновногоЯзыка()));
	Соответствие.Вставить("РеализацияТоваровУслуг",				НСтр("ru = 'НК';
																		|en = 'CustomInv'", ОбщегоНазначения.КодОсновногоЯзыка()));
	Соответствие.Вставить("РеализацияУслугПрочихАктивов",		НСтр("ru = 'НК';
																		|en = 'CustomInv'", ОбщегоНазначения.КодОсновногоЯзыка()));
	Соответствие.Вставить("ПередачаТоваровМеждуОрганизациями",	НСтр("ru = 'НК';
																		|en = 'CustomInv'", ОбщегоНазначения.КодОсновногоЯзыка()));
	Соответствие.Вставить("СчетНаОплатуКлиенту",				НСтр("ru = 'СЧ';
																	|en = 'ACC'", ОбщегоНазначения.КодОсновногоЯзыка()));
	Соответствие.Вставить("СчетФактураВыданный",				НСтр("ru = 'СФ';
																	|en = 'TaxInv'", ОбщегоНазначения.КодОсновногоЯзыка()));
	//++ НЕ УТКА

	//++ Устарело_Переработка24
	Соответствие.Вставить("ЗаказДавальца",						НСтр("ru = 'ЗКД';
																		|en = 'MatProvOrder'", ОбщегоНазначения.КодОсновногоЯзыка()));
	//-- Устарело_Переработка24
	Соответствие.Вставить("ЗаказДавальца2_5",					НСтр("ru = 'ЗКД';
																		|en = 'MatProvOrder'", ОбщегоНазначения.КодОсновногоЯзыка()));
	//-- НЕ УТКА
	
	Возврат Соответствие[Ссылка.Метаданные().Имя];
	
КонецФункции

Функция ПолучитьУникальныйИдентификаторПлатежаСКонтрольнымРазрядом(Код,Сдвиг = Неопределено)
	
	Если Сдвиг = Неопределено Тогда
		Сдвиг = 0;
	КонецЕсли;
	
	СтруктураСоответствий = СтруктураСоответствийБуквИЦифр();
	
	СтрокаЦифр = "0123456789";	
	ВесРазряда = 1+Сдвиг;
	Результат = 0;
	// Замена служебных символов в коде.
	СтрокаБукв = "АБВГДЕЖЗИКЛМНОПРСТУФХЦЧШЩЭЮЯЪЫЬABCDEFGHIJKLMNOPQRSTUVWXYZ";
	НовКод = "";
	Для Инд = 1 По СтрДлина(Код) Цикл
		Попытка
			СимволКода = ВРЕГ(Сред(Код,Инд,1));
		Исключение
			СимволКода = Сред(Код,Инд,1);
		КонецПопытки;
		Если СтрНайти(СтрокаЦифр,СимволКода)=0 И СтрНайти(СтрокаБукв,СимволКода)=0 Тогда
			НовКод = НовКод + "0";
		Иначе
			НовКод = НовКод + СимволКода;
		КонецЕсли;
	КонецЦикла;
	Код = НовКод;
	//Конец замены
	Если СтрДлина(Код)<19 Тогда
		СтрокаКода = СтроковыеФункцииКлиентСервер.ДополнитьСтроку(Код,19,"0","Справа");
	Иначе
		СтрокаКода = Лев(Код,19);
	КонецЕсли;
	
	Для Инд = 1 По 19 Цикл 
		СимволКода = Сред(СтрокаКода,Инд,1);
		Если СтрНайти(СтрокаЦифр,СимволКода)>0 Тогда
			Значение = Число(СимволКода);
		ИначеЕсли СтруктураСоответствий.Свойство(ВРег(СимволКода)) Тогда
			Значение = СтруктураСоответствий[СимволКода]%10;			
		КонецЕсли;		
		Результат = Результат + ВесРазряда*Значение;
		
		ВесРазряда = ВесРазряда + 1;
		Если ВесРазряда = 11 Тогда
			ВесРазряда = 1;
		КонецЕсли;
	КонецЦикла;
	
	КонтрольныйРазряд = Результат % 11;
	
	Если КонтрольныйРазряд = 10 Тогда
		Если Сдвиг = 0 Тогда
			Возврат ПолучитьУникальныйИдентификаторПлатежаСКонтрольнымРазрядом(Код,2);
		Иначе
			КонтрольныйРазряд = 0;
		КонецЕсли;
	КонецЕсли;
	
	ПолныйКод = СтрокаКода+Строка(КонтрольныйРазряд);
	
	Возврат ПолныйКод;
	
КонецФункции

Функция СтруктураСоответствийБуквИЦифр()
	
	СтруктураСоответствий = Новый Структура();
	
	СтруктураСоответствий.Вставить("А", 1);   //@NON-NLS
	СтруктураСоответствий.Вставить("Б", 2);   //@NON-NLS
	СтруктураСоответствий.Вставить("В", 3);   //@NON-NLS
	СтруктураСоответствий.Вставить("Г", 4);   //@NON-NLS
	СтруктураСоответствий.Вставить("Д", 5);   //@NON-NLS
	СтруктураСоответствий.Вставить("Е", 6);   //@NON-NLS
	СтруктураСоответствий.Вставить("Ж", 7);   //@NON-NLS
	СтруктураСоответствий.Вставить("З", 8);   //@NON-NLS
	СтруктураСоответствий.Вставить("И", 9);   //@NON-NLS
	СтруктураСоответствий.Вставить("К", 10);  //@NON-NLS
	СтруктураСоответствий.Вставить("Л", 11);  //@NON-NLS
	СтруктураСоответствий.Вставить("М", 12);  //@NON-NLS
	СтруктураСоответствий.Вставить("Н", 13);  //@NON-NLS
	СтруктураСоответствий.Вставить("О", 14);  //@NON-NLS
	СтруктураСоответствий.Вставить("П", 15);  //@NON-NLS
	СтруктураСоответствий.Вставить("Р", 16);  //@NON-NLS
	СтруктураСоответствий.Вставить("С", 17);  //@NON-NLS
	СтруктураСоответствий.Вставить("Т", 18);  //@NON-NLS
	СтруктураСоответствий.Вставить("У", 19);  //@NON-NLS
	СтруктураСоответствий.Вставить("Ф", 20);  //@NON-NLS
	СтруктураСоответствий.Вставить("Х", 21);  //@NON-NLS
	СтруктураСоответствий.Вставить("Ц", 22);  //@NON-NLS
	СтруктураСоответствий.Вставить("Ч", 23);  //@NON-NLS
	СтруктураСоответствий.Вставить("Ш", 24);  //@NON-NLS
	СтруктураСоответствий.Вставить("Щ", 25);  //@NON-NLS
	СтруктураСоответствий.Вставить("Э", 26);  //@NON-NLS
	СтруктураСоответствий.Вставить("Ю", 27);  //@NON-NLS
	СтруктураСоответствий.Вставить("Я", 28);  //@NON-NLS
	СтруктураСоответствий.Вставить("Ъ", 33);  //@NON-NLS
	СтруктураСоответствий.Вставить("Ы", 36);  //@NON-NLS
	СтруктураСоответствий.Вставить("Ь", 46);  //@NON-NLS
	СтруктураСоответствий.Вставить("A", 1);   //@NON-NLS
	СтруктураСоответствий.Вставить("B", 3);   //@NON-NLS
	СтруктураСоответствий.Вставить("C", 17);  //@NON-NLS
	СтруктураСоответствий.Вставить("D", 29);  //@NON-NLS
	СтруктураСоответствий.Вставить("E", 6);   //@NON-NLS
	СтруктураСоответствий.Вставить("F", 30);  //@NON-NLS
	СтруктураСоответствий.Вставить("G", 31);  //@NON-NLS
	СтруктураСоответствий.Вставить("H", 13);  //@NON-NLS
	СтруктураСоответствий.Вставить("I", 32);  //@NON-NLS
	СтруктураСоответствий.Вставить("J", 33);  //@NON-NLS
	СтруктураСоответствий.Вставить("K", 10);  //@NON-NLS
	СтруктураСоответствий.Вставить("L", 34);  //@NON-NLS
	СтруктураСоответствий.Вставить("M", 12);  //@NON-NLS
	СтруктураСоответствий.Вставить("N", 35);  //@NON-NLS
	СтруктураСоответствий.Вставить("O", 14);  //@NON-NLS
	СтруктураСоответствий.Вставить("P", 16);  //@NON-NLS
	СтруктураСоответствий.Вставить("Q", 36);  //@NON-NLS
	СтруктураСоответствий.Вставить("R", 37);  //@NON-NLS
	СтруктураСоответствий.Вставить("S", 38);  //@NON-NLS
	СтруктураСоответствий.Вставить("T", 18);  //@NON-NLS
	СтруктураСоответствий.Вставить("U", 39);  //@NON-NLS
	СтруктураСоответствий.Вставить("V", 40);  //@NON-NLS
	СтруктураСоответствий.Вставить("W", 41);  //@NON-NLS
	СтруктураСоответствий.Вставить("X", 21);  //@NON-NLS
	СтруктураСоответствий.Вставить("Y", 19);  //@NON-NLS
	СтруктураСоответствий.Вставить("Z", 42);  //@NON-NLS
	
	Возврат СтруктураСоответствий;
	
КонецФункции

// Возвращает свернутую копию таблицы
//
// Параметры:
//  Таблица					 - ТаблицаЗначений - Исходная таблица
//  КолонкиГруппировок		 - Строка - Имена колонок, по которым необходимо группировать строки.
//  ДополнительныеАналитики	 - Строка - Имена колонок, по которым необходимо группировать строки, если они есть в исходной таблице.
//  КолонкиСуммирования		 - Строка - Имена колонок, по которым необходимо суммировать значения.
// 
// Возвращаемое значение:
//  ТаблицаЗначений - свернутая копия таблицы значений
//
Функция СвернутаяКопияТаблицы(Таблица, Знач КолонкиГруппировок, Знач ДополнительныеАналитики = Неопределено, Знач КолонкиСуммирования = Неопределено) Экспорт
	
	Если ДополнительныеАналитики <> Неопределено Тогда
		
		СоставДопАналитик = СтрРазделить(ДополнительныеАналитики, ",", Ложь);
		
		Для Индекс = -СоставДопАналитик.ВГраница() По 0 Цикл
			ИмяКолонки = СокрЛП(СоставДопАналитик[-Индекс]);
			Если Таблица.Колонки.Найти(ИмяКолонки) <> Неопределено Тогда
				Продолжить;
			КонецЕсли;
			СоставДопАналитик.Удалить(-Индекс);
		КонецЦикла;
		
		Если СоставДопАналитик.Количество() <> 0 Тогда
			КолонкиГруппировок = КолонкиГруппировок + "," + СтрСоединить(СоставДопАналитик, ",");
		КонецЕсли;
		
	КонецЕсли;
	
	Если КолонкиСуммирования <> Неопределено Тогда
		НовыйСоставКолонок = КолонкиГруппировок + "," + КолонкиСуммирования;
	Иначе
		НовыйСоставКолонок = КолонкиГруппировок;
	КонецЕсли;
	
	Если ТипЗнч(Таблица) <> Тип("ТаблицаЗначений") Тогда
		ВременнаяТаблица = Таблица.Выгрузить(, НовыйСоставКолонок);
	Иначе
		ВременнаяТаблица = Таблица.Скопировать(, НовыйСоставКолонок);
	КонецЕсли;
	
	ВременнаяТаблица.Свернуть(КолонкиГруппировок, КолонкиСуммирования);
	
	Возврат ВременнаяТаблица;
	
КонецФункции

// Возвращает таблицу значений с данными дерева значений
//
// Параметры:
//  ДеревоДанных - ДеревоЗначений - дерево с данными
//  Уровень		 - Число - уровень дерева, на котором расположены искомые данные (нумерация с 0). Если не передано, то 
//						   будут возвращенные данные со всех последних уровней веток.
//
// Возвращаемое значение:
//  ТаблицаЗначений - содержит данные дерева.
//
Функция ДанныеДерева(ДеревоДанных, Уровень = Неопределено) Экспорт
	
	ТаблицаВозврата = Новый ТаблицаЗначений;
	Для Каждого Колонка Из ДеревоДанных.Колонки Цикл
		ТаблицаВозврата.Колонки.Добавить(Колонка.Имя, Колонка.ТипЗначения);
	КонецЦикла;
	
	СтрокиДерева = ДеревоДанных.Строки;
	
	ЗаполнитьТаблицуРекурсивно(ТаблицаВозврата, СтрокиДерева, Уровень, 0);
	
	Возврат ТаблицаВозврата;

КонецФункции

Процедура ЗаполнитьТаблицуРекурсивно(ТаблицаЗначений, СтрокиДерева, ИскомыйУровень, ТекущийУровень)
	
	Для Каждого Строка Из СтрокиДерева Цикл

		Если ТипЗнч(СтрокиДерева) = Тип("КоллекцияСтрокДереваЗначений") Тогда
			Подстроки = Строка.Строки;
		ИначеЕсли ТипЗнч(СтрокиДерева) = Тип("ДанныеФормыКоллекцияЭлементовДерева") Тогда
			Подстроки = Строка.ПолучитьЭлементы();
		КонецЕсли;
		
		Если ИскомыйУровень = ТекущийУровень 
			Или (ИскомыйУровень = Неопределено И Подстроки.Количество() = 0) Тогда
			НовСтрока = ТаблицаЗначений.Добавить();
			ЗаполнитьЗначенияСвойств(НовСтрока, Строка);
		Иначе
			ЗаполнитьТаблицуРекурсивно(ТаблицаЗначений, Подстроки, ИскомыйУровень, ТекущийУровень + 1);
		КонецЕсли;
		
	КонецЦикла;
	
КонецПроцедуры


Функция СвойствоМетаданных(МетаданныеОбъекта, ЧастиИмени, Индекс = 0)
	
	Имя = ЧастиИмени[Индекс];
	Свойство = МетаданныеОбъекта[Имя];
	Если Индекс < ЧастиИмени.ВГраница() Тогда
		Свойство = СвойствоМетаданных(Свойство, ЧастиИмени, Индекс+1);
	КонецЕсли;
	Возврат Свойство;
	
КонецФункции

// Проверяет, что переданный тип - примитивный
//
// Параметры:
//  ПроверяемыйТип - Тип - 
// 
// Возвращаемое значение:
//  Булево -
//
Функция ЭтоПримитивныйТип(ПроверяемыйТип) Экспорт
	
	Если ПроверяемыйТип = Тип("Неопределено")
		Или ПроверяемыйТип = Тип("Булево")
		Или ПроверяемыйТип = Тип("Строка")
		Или ПроверяемыйТип = Тип("Число")
		Или ПроверяемыйТип = Тип("Дата")
		Или ПроверяемыйТип = Тип("УникальныйИдентификатор") Тогда
		
		Возврат Истина;
		
	Иначе
		
		Возврат Ложь;
		
	КонецЕсли;
	
КонецФункции

// Представление объекта по метаданным
//
// Параметры:
//  МетаданныеОбъекта - ОбъектМетаданных -
// 
// Возвращаемое значение:
//  Строка -
//
Функция ПредставлениеОбъектаПоМетаданным(МетаданныеОбъекта) Экспорт
		
	Если Не ПустаяСтрока(МетаданныеОбъекта.ПредставлениеОбъекта) Тогда
		Возврат МетаданныеОбъекта.ПредставлениеОбъекта;
	Иначе
		Возврат МетаданныеОбъекта.Синоним;
	КонецЕсли;
	
КонецФункции

// Устанавливаем условное оформление для поля формы "ВариантОформления" в документе ТаможеннаяДекларация
//    в зависимости от его значения.
//
// Параметры:
// 		Список - ФормаКлиентскогоПриложения - Содержит данную форму.
//
Процедура УстановитьУсловноеОформлениеВариантОформленияГТД(Список) Экспорт
	
	УсловноеОформление = Список.УсловноеОформление;
	
	//
	ЭлементУсловногоОформления = УсловноеОформление.Элементы.Добавить();

	ПолеЭлемента = ЭлементУсловногоОформления.Поля.Элементы.Добавить();
	ПолеЭлемента.Поле = Новый ПолеКомпоновкиДанных("ВариантОформления");

	ОтборЭлемента = ЭлементУсловногоОформления.Отбор.Элементы.Добавить(Тип("ЭлементОтбораКомпоновкиДанных"));
	ОтборЭлемента.ЛевоеЗначение = Новый ПолеКомпоновкиДанных("ВариантОформления");
	ОтборЭлемента.ВидСравнения = ВидСравненияКомпоновкиДанных.Равно;
	ОтборЭлемента.ПравоеЗначение = Перечисления.ХозяйственныеОперации.ОформлениеГТДБрокером;
	
	ЭлементУсловногоОформления.Оформление.УстановитьЗначениеПараметра("Текст", НСтр("ru = 'Брокером';
																					|en = 'Broker'"));
	
	//
	ЭлементУсловногоОформления = УсловноеОформление.Элементы.Добавить();

	ПолеЭлемента = ЭлементУсловногоОформления.Поля.Элементы.Добавить();
	ПолеЭлемента.Поле = Новый ПолеКомпоновкиДанных("ВариантОформления");

	ОтборЭлемента = ЭлементУсловногоОформления.Отбор.Элементы.Добавить(Тип("ЭлементОтбораКомпоновкиДанных"));
	ОтборЭлемента.ЛевоеЗначение = Новый ПолеКомпоновкиДанных("ВариантОформления");
	ОтборЭлемента.ВидСравнения = ВидСравненияКомпоновкиДанных.Равно;
	ОтборЭлемента.ПравоеЗначение = Перечисления.ХозяйственныеОперации.ОформлениеГТДСамостоятельно;
	
	ЭлементУсловногоОформления.Оформление.УстановитьЗначениеПараметра("Текст", НСтр("ru = 'Самостоятельно';
																					|en = 'Independently'"));
	
КонецПроцедуры

// Параметры:
// 	Ссылка - ДокументСсылка - 
// 	Регистры - См. ОбщегоНазначенияУТПовтИсп.РегистрыСведенийПоМетаданнымИзмерений
Функция ЭтоЗаписьВедомогоРегистраСведений(Ссылка, Регистры)
	
	Для Каждого Элемент Из Регистры Цикл
		Если ТипЗнч(Ссылка) = Тип("РегистрСведенийКлючЗаписи." + Элемент.Имя) Тогда
			Возврат Истина;
		КонецЕсли;
	КонецЦикла;
	
	Возврат Ложь;
	
КонецФункции

Функция ЭтоЗаписьИсключаемогоОбъекта(Ссылка, Объекты)
	
	Для Каждого Элемент Из Объекты Цикл
		ПолноеИмя = Элемент.ПолноеИмя();
		
		ВидМетаданных = "";
		Если СтрНайти(ПолноеИмя, "Справочник.") Тогда
			ВидМетаданных = "СправочникСсылка";
		ИначеЕсли СтрНайти(ПолноеИмя, "Документ.") Тогда
			ВидМетаданных = "ДокументСсылка";
		ИначеЕсли СтрНайти(ПолноеИмя, "РегистрСведений.") Тогда
			ВидМетаданных = "РегистрСведенийКлючЗаписи";
		Иначе
			Возврат Ложь;
		КонецЕсли;
		
		Если ТипЗнч(Ссылка) = Тип(ВидМетаданных + "." + Элемент.Имя) Тогда
			Возврат Истина;
		Иначе
			Возврат Ложь;
		КонецЕсли;
		
	КонецЦикла;
	
КонецФункции

Функция НазначенияЗаказов(МассивЗаказов)
	
	Запрос = Новый Запрос();
	Запрос.Текст =
		"ВЫБРАТЬ
		|	Таблица.Ссылка КАК Ссылка
		|ИЗ
		|	Справочник.Назначения КАК Таблица
		|ГДЕ
		|	Таблица.Заказ В(&МассивЗаказов)";
	Запрос.УстановитьПараметр("МассивЗаказов", МассивЗаказов);
	Возврат Запрос.Выполнить().Выгрузить().ВыгрузитьКолонку("Ссылка");
	
КонецФункции

// Переносит файл от прежнего владельца к новому
//
// Параметры:
//	ВладелецФайла - ЛюбаяСсылка - ссылка на новый объект-владелец файла
//	РеквизитПриемник - СправочникСсылка -
//	                 - СправочникСсылка.ПартнерыПрисоединенныеФайлы - Значение переменной-приемника ссылки на новый файл
//	РеквизитИсточник - СправочникСсылка -
//	                 - СправочникСсылка.ПартнерыПрисоединенныеФайлы - Значение переменной-источника ссылки на новый файл
//	ФормироватьНовуюСсылкуНаФайл - Булево - указывает создавать ли файл с новой ссылкой или использовать текущую.
//
Процедура СкопироватьПрисоединенныйФайл(ВладелецФайла, РеквизитПриемник, РеквизитИсточник, ФормироватьНовуюСсылкуНаФайл = Истина) Экспорт
	ФайлИсточник = РаботаСФайлами.ДанныеФайла(РеквизитИсточник, Новый УникальныйИдентификатор, Истина);
	
	Параметры = Новый Структура;
	Параметры.Вставить("Автор", Пользователи.ТекущийПользователь());
	Параметры.Вставить("ВладелецФайлов", ВладелецФайла);
	Параметры.Вставить("ИмяБезРасширения", ФайлИсточник.Наименование);
	Параметры.Вставить("РасширениеБезТочки", ФайлИсточник.Расширение);
	Параметры.Вставить("ВремяИзмененияУниверсальное", ФайлИсточник.ДатаМодификацииУниверсальная);
	
	ИмяСправочника = РаботаСФайламиСлужебный.ИмяСправочникаХраненияФайлов(ВладелецФайла,, Неопределено);
	
	РеквизитПриемник = РаботаСФайлами.ДобавитьФайл(
		Параметры,
		ФайлИсточник.СсылкаНаДвоичныеДанныеФайла,,
		РеквизитИсточник.Описание,
		?(ФормироватьНовуюСсылкуНаФайл, 
			Неопределено, 
			Справочники[ИмяСправочника].ПолучитьСсылку(РеквизитИсточник.УникальныйИдентификатор())
		)
	);
КонецПроцедуры

// Возвращает хеш сумму переданного объекта
//
// Параметры:
//	СериализуемыйОбъект - Произвольный - объект, который может быть сериализован. В противном случае будет выдано исключение.
//	ТипХешФункции - ХешФункция - один из типов хеш-функции CRC32, MD5, SHA1, SHA256.
//
// Возвращаемое значение:
//  Строка - хеш-сумма в виде строки.
//
Функция ХешСуммаСериализуемогоОбъекта(СериализуемыйОбъект, ТипХешФункции) Экспорт
	СериализованнаяСтрока = ОбщегоНазначения.ЗначениеВСтрокуXML(СериализуемыйОбъект);
	
	ХешированиеДанных = Новый ХешированиеДанных(ТипХешФункции);
	ХешированиеДанных.Добавить(СериализованнаяСтрока);
	ХешСумма = СтрЗаменить(ХешированиеДанных.ХешСумма, " ", "");
	
	Возврат ХешСумма;
КонецФункции

// Возвращает хеш сумму переданного объекта
//
// Параметры:
//	ИсходнаяСтрока - Строка - строка, по которой будет строится хеш. В противном случае будет выдано исключение.
//	ТипХешФункции - ХешФункция - один из типов хеш-функции CRC32, MD5, SHA1, SHA256.
//
// Возвращаемое значение:
//  Строка - хеш-сумма в виде строки.
//
Функция ХешСуммаСтроки(ИсходнаяСтрока, ТипХешФункции) Экспорт
	Если Не ТипЗнч(ИсходнаяСтрока) = Тип("Строка") Тогда
		ВызватьИсключение НСтр("ru = 'Недопустимый тип источника получения данных.';
								|en = 'Invalid type of data receipt source.'");
	КонецЕсли;
	
	ХешированиеДанных = Новый ХешированиеДанных(ТипХешФункции);
	ХешированиеДанных.Добавить(ИсходнаяСтрока);
	ХешСумма = СтрЗаменить(ХешированиеДанных.ХешСумма, " ", "");
	
	Возврат ХешСумма;
КонецФункции

Процедура ПроверитьИспользованиеРеквизитаПолучитьПустоеЗначение(Объект, МетаданныеОбъекта, ИмяРеквизита, ПустыеЗначенияРеквизитов)
	
	Если ПустыеЗначенияРеквизитов.Свойство(ИмяРеквизита) Тогда
		Возврат;
	КонецЕсли;
	
	МетаданныеРеквизита = МетаданныеОбъекта.Реквизиты.Найти(ИмяРеквизита);
	
	Если МетаданныеРеквизита = Неопределено Тогда
		
		Для Каждого СтандартныйРеквизит Из МетаданныеОбъекта.СтандартныеРеквизиты Цикл
			Если СтандартныйРеквизит.Имя = ИмяРеквизита Тогда
				МетаданныеРеквизита = СтандартныйРеквизит;
				Прервать;
			КонецЕсли;
		КонецЦикла;
		
		Если МетаданныеРеквизита = Неопределено Тогда
			ТекстИсключения = НСтр("ru = 'Реквизит %ИмяРеквизита% не найден в %ИмяОъекта%. Ошибка в описании параметров синхронизации с ключами.';
									|en = 'The%ИмяРеквизита% attribute is not found in the %ИмяОъекта%. An error occurred in description of parameters of synchronization with keys.'");
			ТекстИсключения = СтрЗаменить(ТекстИсключения, "%ИмяРеквизита%", ИмяРеквизита);
			ТекстИсключения = СтрЗаменить(ТекстИсключения, "%ИмяОъекта%", МетаданныеОбъекта.ПолноеИмя());
			ВызватьИсключение ТекстИсключения;
		КонецЕсли;
		
	Иначе
		
		Если (ОбщегоНазначения.ЭтоСправочник(МетаданныеОбъекта)
			Или ОбщегоНазначения.ЭтоПланВидовХарактеристик(МетаданныеОбъекта))
			И (МетаданныеОбъекта.Иерархический
			И МетаданныеОбъекта.ВидИерархии = Метаданные.СвойстваОбъектов.ВидИерархии.ИерархияГруппИЭлементов) Тогда
			
			Если МетаданныеРеквизита.Использование <> Метаданные.СвойстваОбъектов.ИспользованиеРеквизита.ДляГруппыИЭлемента Тогда
				
				Если (Объект.ЭтоГруппа
					И МетаданныеРеквизита.Использование = Метаданные.СвойстваОбъектов.ИспользованиеРеквизита.ДляЭлемента)
					Или (Не Объект.ЭтоГруппа
					И МетаданныеРеквизита.Использование = Метаданные.СвойстваОбъектов.ИспользованиеРеквизита.ДляГруппы) Тогда
					
					ПустыеЗначенияРеквизитов.Вставить(ИмяРеквизита, "Неиспользуется");
					Возврат;
				КонецЕсли;
				
			КонецЕсли;
			
		КонецЕсли;
		
	КонецЕсли;
	
	ПустыеЗначенияРеквизитов.Вставить(ИмяРеквизита,	МетаданныеРеквизита.Тип.ПривестиЗначение()); 
		
КонецПроцедуры

// Выполняет свертку набора записей регистра.
//
// Параметры:
// 	Набор - РегистрНакопленияНаборЗаписей, РегистрСведенийНаборЗаписей - 
// 	ТребуетсяСортировка - Булево - Требуется ли сортировать набор перед записью по измерениям.
//
Процедура СвернутьНаборЗаписей(Набор, ТребуетсяСортировка = Ложь) Экспорт
	
	ЗаписиРегистра = Набор.Выгрузить();
	
	ВсеКолонки = Новый Массив();
	Для Каждого Колонка Из ЗаписиРегистра.Колонки Цикл
		ВсеКолонки.Добавить(Колонка.Имя);
	КонецЦикла;
	
	Ресурсы = Новый Массив();
	
	Для Каждого Ресурс Из Набор.Метаданные().Ресурсы Цикл
		Ресурсы.Добавить(Ресурс.Имя);
	КонецЦикла;
	
	КолонкиГруппировки = ОбщегоНазначенияУТКлиентСервер.РазличияМассивов(ВсеКолонки, Ресурсы);
	КолонкиГруппировки.Удалить(КолонкиГруппировки.Найти("НомерСтроки"));
	
	КолонкиГруппировкиСтрокой = СтрСоединить(КолонкиГруппировки, ", ");
	КолонкиСуммированияСтрокой = СтрСоединить(Ресурсы, ", ");
	
	ЗаписиРегистра.Свернуть(КолонкиГруппировкиСтрокой, КолонкиСуммированияСтрокой);
	
	Если ТребуетсяСортировка Тогда
		ОбъектСравнения = Новый СравнениеЗначений;
		ЗаписиРегистра.Сортировать(КолонкиГруппировкиСтрокой, ОбъектСравнения);
	КонецЕсли;
	Набор.Загрузить(ЗаписиРегистра);
	
КонецПроцедуры

#КонецОбласти

#Область ДобавлениеУдалениеКнопокСозданияВЖурналахДокументов

Процедура СформироватьКомандыСоздания(СтруктураПараметров) 
	
	Форма = СтруктураПараметров.Форма;
	
	СтруктураИменГрупп = Новый Структура;
	СтруктураИменГрупп.Вставить(СтруктураПараметров.ИмяГруппыСоздать, Ложь); // Ложь, т.к. группа не контекстная
	Если ЗначениеЗаполнено(СтруктураПараметров.ИмяГруппыСоздатьКонтекст) Тогда
		СтруктураИменГрупп.Вставить(СтруктураПараметров.ИмяГруппыСоздатьКонтекст, Истина); // Истина, т.к. контекстная группа
	КонецЕсли;
	
	Запрос = Новый Запрос;
	Запрос.Текст =
	"ВЫБРАТЬ
	|	ВЫРАЗИТЬ(Таблица.Порядок КАК ЧИСЛО(10, 0)) КАК Порядок,
	|	ВЫРАЗИТЬ(Таблица.ИдентификаторОбъектаМетаданных КАК Справочник.ИдентификаторыОбъектовМетаданных) КАК ИдентификаторОбъектаМетаданных,
	|	ВЫРАЗИТЬ(Таблица.ХозяйственнаяОперация КАК Перечисление.ХозяйственныеОперации) КАК ХозяйственнаяОперация,
	|	ВЫРАЗИТЬ(Таблица.ДокументПредставление КАК СТРОКА(250)) КАК ДокументПредставление,
	|	ВЫРАЗИТЬ(Таблица.ГруппаКнопок КАК СТРОКА(100)) КАК ГруппаКнопок,
	|	ВЫРАЗИТЬ(Таблица.РазместитьВПодменю КАК БУЛЕВО) КАК РазместитьВПодменю
	|ПОМЕСТИТЬ Таблица
	|ИЗ
	|	&Таблица КАК Таблица
	|ГДЕ
	|	Таблица.Отбор
	|	И Таблица.ДобавитьКнопкуСоздать
	|	И Таблица.ПравоДоступаДобавление
	|;
	|
	|////////////////////////////////////////////////////////////////////////////////
	|ВЫБРАТЬ
	|	Таблица.Порядок 								КАК Порядок,
	|	Таблица.ИдентификаторОбъектаМетаданных 			КАК ИдентификаторОбъектаМетаданных,
	|	Таблица.ХозяйственнаяОперация 					КАК ХозяйственнаяОперация,
	|	ПРЕДСТАВЛЕНИЕ(Таблица.ХозяйственнаяОперация) 	КАК ХозОперацияСиноним,
	|	Таблица.ДокументПредставление 					КАК ДокументПредставление,
	|	Таблица.ГруппаКнопок 							КАК ГруппаКнопок,
	|	Таблица.РазместитьВПодменю 						КАК РазместитьВПодменю
	|ИЗ
	|	Таблица КАК Таблица";
	
	ТаблицаХозОперацийИДокументов = Форма[СтруктураПараметров.ИмяТаблицыХозяйственныхОперацийИДокументов].Выгрузить(); // ТаблицаЗначений - 
	
	Если ТаблицаХозОперацийИДокументов.Колонки.Найти("Порядок") = Неопределено Тогда
		ТаблицаХозОперацийИДокументов.Колонки.Добавить("Порядок",
			Новый ОписаниеТипов("Число", Новый КвалификаторыЧисла(10, 0)));
	КонецЕсли;
	Если ТаблицаХозОперацийИДокументов.Колонки.Найти("ГруппаКнопок") = Неопределено Тогда
		ТаблицаХозОперацийИДокументов.Колонки.Добавить("ГруппаКнопок",
			Новый ОписаниеТипов("Строка", , Новый КвалификаторыСтроки(100)));
	КонецЕсли;
	Если ТаблицаХозОперацийИДокументов.Колонки.Найти("РазместитьВПодменю") = Неопределено Тогда
		ТаблицаХозОперацийИДокументов.Колонки.Добавить("РазместитьВПодменю",
			Новый ОписаниеТипов("Булево"));
		ТаблицаХозОперацийИДокументов.ЗаполнитьЗначения(Истина, "РазместитьВПодменю");
	КонецЕсли;
	
	Запрос.УстановитьПараметр("Таблица", ТаблицаХозОперацийИДокументов);
	
	ТаблицаДокументов = Запрос.Выполнить().Выгрузить();
	
	Запрос = Новый Запрос;
	Запрос.Текст = 
	"ВЫБРАТЬ
	|	ВЫРАЗИТЬ(Таблица.ИдентификаторОбъектаМетаданных КАК Справочник.ИдентификаторыОбъектовМетаданных) КАК ИдентификаторОбъектаМетаданных,
	|	ВЫРАЗИТЬ(Таблица.ХозяйственнаяОперация КАК Перечисление.ХозяйственныеОперации) КАК ХозяйственнаяОперация,
	|	ВЫРАЗИТЬ(Таблица.ДокументПредставление КАК СТРОКА(250)) КАК ДокументПредставление,
	|	ВЫРАЗИТЬ(Таблица.ХозОперацияСиноним КАК СТРОКА(500)) КАК ХозОперацияСиноним,
	|	ВЫРАЗИТЬ(Таблица.ГруппаКнопок КАК СТРОКА(100)) КАК ГруппаКнопок,
	|	ВЫРАЗИТЬ(Таблица.РазместитьВПодменю КАК БУЛЕВО) КАК РазместитьВПодменю,
	|	ВЫРАЗИТЬ(Таблица.Порядок КАК ЧИСЛО(10, 0)) КАК Порядок
	|ПОМЕСТИТЬ Таблица
	|ИЗ
	|	&Таблица КАК Таблица
	|;
	|
	|////////////////////////////////////////////////////////////////////////////////
	|ВЫБРАТЬ
	|	КОЛИЧЕСТВО(КоличествоДокументов.ИдентификаторОбъектаМетаданных) КАК Количество
	|ИЗ
	|	(ВЫБРАТЬ РАЗЛИЧНЫЕ
	|		Таблица.ИдентификаторОбъектаМетаданных КАК ИдентификаторОбъектаМетаданных
	|	ИЗ
	|		Таблица КАК Таблица) КАК КоличествоДокументов
	|;
	|
	|////////////////////////////////////////////////////////////////////////////////
	|ВЫБРАТЬ
	|	КОЛИЧЕСТВО(КоличествоХозяйственныхОпераций.ХозяйственнаяОперация) КАК Количество
	|ИЗ
	|	(ВЫБРАТЬ РАЗЛИЧНЫЕ
	|		Таблица.ХозяйственнаяОперация КАК ХозяйственнаяОперация
	|	ИЗ
	|		Таблица КАК Таблица) КАК КоличествоХозяйственныхОпераций
	|;
	|
	|////////////////////////////////////////////////////////////////////////////////
	|ВЫБРАТЬ
	|	Таблица.ИдентификаторОбъектаМетаданных КАК ИдентификаторОбъектаМетаданных,
	|	Таблица.ХозяйственнаяОперация КАК ХозяйственнаяОперация,
	|	Таблица.ИдентификаторОбъектаМетаданных.Синоним КАК Синоним,
	|	ВЫБОР 
	|		КОГДА Таблица.ДокументПредставление <> """"
	|			ТОГДА Таблица.ДокументПредставление
	|		ИНАЧЕ Таблица.ИдентификаторОбъектаМетаданных.Синоним
	|	КОНЕЦ КАК ДокументПредставление,
	|	Таблица.ИдентификаторОбъектаМетаданных.Имя КАК Имя,
	|	Таблица.ИдентификаторОбъектаМетаданных.ПолноеИмя КАК ПолноеИмяДокумента,
	|	Таблица.ГруппаКнопок КАК ГруппаКнопок,
	|	Таблица.РазместитьВПодменю КАК РазместитьВПодменю
	|ИЗ
	|	Таблица КАК Таблица
	|
	|УПОРЯДОЧИТЬ ПО
	|	Порядок,
	|	Синоним,
	|	ХозОперацияСиноним
	|;
	|
	|////////////////////////////////////////////////////////////////////////////////
	|ВЫБРАТЬ
	|	Таблица.ИдентификаторОбъектаМетаданных КАК ИдентификаторОбъектаМетаданных,
	|	Таблица.ХозяйственнаяОперация КАК ХозяйственнаяОперация,
	|	Таблица.Порядок КАК Порядок,
	|	Таблица.ИдентификаторОбъектаМетаданных.Синоним КАК Синоним,
	|	ВЫБОР 
	|		КОГДА Таблица.ДокументПредставление <> """"
	|			ТОГДА Таблица.ДокументПредставление
	|		ИНАЧЕ Таблица.ИдентификаторОбъектаМетаданных.Синоним
	|	КОНЕЦ КАК ДокументПредставление,
	|	Таблица.ИдентификаторОбъектаМетаданных.Имя КАК ИмяДокумента,
	|	Таблица.ИдентификаторОбъектаМетаданных.ПолноеИмя КАК ПолноеИмяДокумента,
	|	Таблица.ГруппаКнопок КАК ГруппаКнопок,
	|	Таблица.РазместитьВПодменю КАК РазместитьВПодменю
	|ИЗ
	|	Таблица КАК Таблица
	|
	|УПОРЯДОЧИТЬ ПО
	|	Порядок,
	|	Синоним,
	|	ХозОперацияСиноним
	|
	|ИТОГИ 
	|	МАКСИМУМ(Синоним),
	|	МАКСИМУМ(ДокументПредставление),
	|	МАКСИМУМ(ГруппаКнопок),
	|	МАКСИМУМ(Порядок),
	|	МАКСИМУМ(РазместитьВПодменю)
	|ПО
	|	ИдентификаторОбъектаМетаданных";
	
	Запрос.УстановитьПараметр("Таблица", ТаблицаДокументов);
	МассивРезультатов = Запрос.ВыполнитьПакет();
	
	КоличествоДокументов = 0;
	ВыборкаКоличествоДокументов = МассивРезультатов[1].Выбрать();
	Если ВыборкаКоличествоДокументов.Следующий() Тогда 
		КоличествоДокументов = ВыборкаКоличествоДокументов.Количество;
	КонецЕсли;
	
	КоличествоХозОпераций = 0;
	ВыборкаКоличествоХозОпераций = МассивРезультатов[2].Выбрать();
	Если ВыборкаКоличествоХозОпераций.Следующий() Тогда 
		КоличествоХозОпераций = ВыборкаКоличествоХозОпераций.Количество;
	КонецЕсли;
	
	Если КоличествоДокументов = 0 Или КоличествоХозОпераций = 0 Тогда
		Возврат;
	КонецЕсли;
	
	Для Каждого ИмяКонтекстГруппы Из СтруктураИменГрупп Цикл
		
		ИмяГруппыСоздать 			= ИмяКонтекстГруппы.Ключ;
		ДобавлениеВКонтекстноеМеню 	= ИмяКонтекстГруппы.Значение;
		
		Префикс = СтруктураПараметров.ПрефиксЭлементов + ?(ДобавлениеВКонтекстноеМеню, "Контекст", "");
		
		ГруппаСоздать = Форма.Элементы[ИмяГруппыСоздать];
	
		УдалитьКомандыСоздания(Форма, ГруппаСоздать, ИмяГруппыСоздать);
		
		СоответствиеГруппКоманды = Новый Соответствие;
		СоответствиеГруппКоманды.Вставить("", ГруппаСоздать);
		
		Если КоличествоДокументов = 1 И КоличествоХозОпераций = 1 Тогда
			
			Выборка = МассивРезультатов[3].Выбрать();
			Если Выборка.Следующий() Тогда   
				МестоРазмещенияКнопки = МестоРазмещенияКнопки("", Форма, ИмяГруппыСоздать, Префикс, СоответствиеГруппКоманды);
				ДобавитьКомандуСКнопкой(Форма, ИмяГруппыСоздать, МестоРазмещенияКнопки, НСтр("ru = 'Создать';
																							|en = 'Create'"), Выборка, Префикс, ГруппаСоздать.ПодчиненныеЭлементы.Количество() = 0);
			КонецЕсли;
					
		ИначеЕсли КоличествоДокументов = 1 И КоличествоХозОпераций > 1 Тогда
			
			Выборка = МассивРезультатов[3].Выбрать();
			Пока Выборка.Следующий() Цикл
				МестоРазмещенияКнопки = МестоРазмещенияКнопки(Выборка.ГруппаКнопок, Форма, ИмяГруппыСоздать, Префикс, СоответствиеГруппКоманды);
				ДобавитьКомандуСКнопкой(Форма, ИмяГруппыСоздать, МестоРазмещенияКнопки, Выборка.ХозяйственнаяОперация, Выборка, Префикс);			
			КонецЦикла;
			
		ИначеЕсли КоличествоДокументов <= СтруктураПараметров.МаксимальноеКоличествоКомандВПодменю
		 	И КоличествоХозОпераций = 1 Тогда
			
			Выборка = МассивРезультатов[3].Выбрать();
			Пока Выборка.Следующий() Цикл
				МестоРазмещенияКнопки = МестоРазмещенияКнопки(Выборка.ГруппаКнопок, Форма, ИмяГруппыСоздать, Префикс, СоответствиеГруппКоманды);
				ДобавитьКомандуСКнопкой(Форма, ИмяГруппыСоздать, МестоРазмещенияКнопки, Выборка.ДокументПредставление, Выборка, Префикс);
			КонецЦикла;
			
		ИначеЕсли КоличествоДокументов <= СтруктураПараметров.МаксимальноеКоличествоКомандВПодменю
		 	И КоличествоХозОпераций > 1 Тогда
			
			Дерево = МассивРезультатов[4].Выгрузить(ОбходРезультатаЗапроса.ПоГруппировкамСИерархией);
			
			Для Каждого СтрокаДокумент Из Дерево.Строки Цикл
				
				Если СтрокаДокумент.Строки.Количество() = 1 Тогда
					
					МестоРазмещенияКнопки = МестоРазмещенияКнопки(
						СтрокаДокумент.ГруппаКнопок, 
						Форма, 
						ИмяГруппыСоздать, 
						Префикс, 
						СоответствиеГруппКоманды);
					
					ДобавитьКомандуСКнопкой(
						Форма, 
						ИмяГруппыСоздать, 
						МестоРазмещенияКнопки, 
						СтрокаДокумент.ДокументПредставление, 
						СтрокаДокумент.Строки[0], 
						Префикс);
					
				Иначе
					
					Если СтрокаДокумент.РазместитьВПодменю Тогда
						
						МестоРазмещенияКнопки = ДобавитьГруппуКнопок(
							Форма, 
							ИмяГруппыСоздать, 
							СтрокаДокумент.ИмяДокумента, 
							СтрокаДокумент.ДокументПредставление, 
							Префикс);
					Иначе
						
						МестоРазмещенияКнопки = МестоРазмещенияКнопки(
							СтрокаДокумент.ГруппаКнопок, 
							Форма, 
							ИмяГруппыСоздать, 
							Префикс, 
							СоответствиеГруппКоманды);
							
					КонецЕсли;
					
					Для Каждого Строка Из СтрокаДокумент.Строки Цикл
						
						ДобавитьКомандуСКнопкой(
							Форма, 
							ИмяГруппыСоздать, 
							МестоРазмещенияКнопки, 
							?(Строка.РазместитьВПодменю, Строка.ХозяйственнаяОперация, Строка.ДокументПредставление), 
							Строка, 
							Префикс);
							
					КонецЦикла;
					
				КонецЕсли;
				
			КонецЦикла;
			
		ИначеЕсли Форма.ОтборТипыДокументов.Количество() > СтруктураПараметров.МаксимальноеКоличествоКомандВПодменю Тогда
			
			ДобавитьКомандуСКнопкойДляОткрытияФормыВыбора(Форма, ИмяГруппыСоздать, Префикс);
			
		КонецЕсли;
		
	КонецЦикла;
	
КонецПроцедуры

Функция ДобавитьГруппуКнопок(Форма, ИмяГруппыСоздать, ИмяНовойГруппы, ЗаголовокНовойГруппы, Префикс)
	
	Элемент = Форма.Элементы.Добавить(Префикс + "Группа" + "Создать_" + СокрЛП(ИмяНовойГруппы), Тип("ГруппаФормы"), Форма.Элементы[ИмяГруппыСоздать]);
	Элемент.Заголовок = СокрЛП(ЗаголовокНовойГруппы);
	Возврат Элемент;
	
КонецФункции

Функция ДобавитьКомандуСКнопкой(Форма, ИмяГруппыСоздать, Родитель, ЗаголовокКнопки, ТекущаяСтрокаТаблицы, Префикс, ОднаКнопка = Ложь)
	
	МетаданныеДокумента = Метаданные.НайтиПоПолномуИмени(ТекущаяСтрокаТаблицы.ПолноеИмяДокумента);
	
	ИмяЗначенияПеречисления = XMLСтрока(ТекущаяСтрокаТаблицы.ХозяйственнаяОперация);
	ИмяМетаданныхДокумента = МетаданныеДокумента.Имя;
	
	Если ОднаКнопка Тогда
		Форма.Элементы[ИмяГруппыСоздать].Вид = ВидГруппыФормы.ГруппаКнопок;
	Иначе
		Форма.Элементы[ИмяГруппыСоздать].Вид = ВидГруппыФормы.Подменю;
		Форма.Элементы[ИмяГруппыСоздать].Картинка = БиблиотекаКартинок.СоздатьЭлементСписка;
	КонецЕсли;
	
	ИмяКоманды = Префикс + "Создать___" + ИмяЗначенияПеречисления + "___" + ИмяМетаданныхДокумента;
	Команда = Форма.Команды.Добавить(ИмяКоманды);
	Команда.Действие = "Подключаемый_СоздатьДокумент";
	Команда.Заголовок = СокрЛП(ЗаголовокКнопки);
	Если ОднаКнопка Тогда 
		Команда.Отображение = ОтображениеКнопки.КартинкаИТекст;
		Команда.Картинка = БиблиотекаКартинок.СоздатьЭлементСписка;
	КонецЕсли;
	
	Элемент = Форма.Элементы.Добавить(ИмяКоманды, Тип("КнопкаФормы"), Родитель);
	Элемент.ИмяКоманды = ИмяКоманды;
	Возврат Элемент;
	
КонецФункции

Функция ДобавитьКомандуСКнопкойДляОткрытияФормыВыбора(Форма, ИмяГруппыСоздать, Префикс)
	
	Форма.Элементы[ИмяГруппыСоздать].Вид = ВидГруппыФормы.ГруппаКнопок;
	
	ИмяКоманды = Префикс + "Создать_" + "ДокументЧерезФормуВыбора";
	Команда = Форма.Команды.Добавить(ИмяКоманды);
	Команда.Действие = "Подключаемый_СоздатьДокументЧерезФормуВыбора";
	Команда.Заголовок = НСтр("ru = 'Создать...';
							|en = 'Create...'");
	Команда.Отображение = ОтображениеКнопки.КартинкаИТекст;
	Команда.Картинка = БиблиотекаКартинок.СоздатьЭлементСписка;
	
	Элемент = Форма.Элементы.Добавить(ИмяКоманды, Тип("КнопкаФормы"), Форма.Элементы[ИмяГруппыСоздать]);
	Элемент.ИмяКоманды = ИмяКоманды;
	Возврат Элемент;
	
КонецФункции

Процедура УдалитьКомандыСоздания(Форма, Родитель, ИмяГруппыСоздать)
	
	// Если родитель - не корневая группа и он не создан программно, то удалять ничего не нужно.
	Если Родитель <> Форма.Элементы[ИмяГруппыСоздать] 
		И СтрНайти(Родитель.Имя, "Создать_") = 0 Тогда
		Возврат;
	КонецЕсли;
	
	Если ТипЗнч(Родитель) = Тип("ГруппаФормы") Тогда 
		
		Количество = Родитель.ПодчиненныеЭлементы.Количество();
		
		Для Индекс = 1 По Количество Цикл
			УдалитьКомандыСоздания(Форма, Родитель.ПодчиненныеЭлементы.Получить(0), ИмяГруппыСоздать);
		КонецЦикла;
		
	ИначеЕсли ТипЗнч(Родитель) = Тип("КнопкаФормы") Тогда 
		Форма.Команды.Удалить(Форма.Команды.Найти(Родитель.Имя));
	КонецЕсли;
	
	Если СтрНайти(Родитель.Имя, "Создать_") <> 0 Тогда 
		Форма.Элементы.Удалить(Родитель);
	КонецЕсли;
	
КонецПроцедуры

Функция МестоРазмещенияКнопки(ИмяГруппыКнопок, Форма, ИмяГруппыСоздать, Префикс, СоответствиеГруппКоманды)
	
	ГруппаКнопок = СоответствиеГруппКоманды.Получить(СокрЛП(ИмяГруппыКнопок));
	Если ГруппаКнопок = Неопределено Тогда
		ГруппаКнопок = ДобавитьГруппуКнопок(Форма, ИмяГруппыСоздать, ИмяГруппыКнопок, ИмяГруппыСоздать, Префикс);	
		ГруппаКнопок.Вид = ВидГруппыФормы.ГруппаКнопок;
		СоответствиеГруппКоманды.Вставить(СокрЛП(ИмяГруппыКнопок), ГруппаКнопок);
	КонецЕсли;
	
	Возврат ГруппаКнопок;
	
КонецФункции

#КонецОбласти

#Область ПоискВТаблице

Функция УпорядочитьПронумерованныеСтроки(Таблица, МассивСтрок)
	
	СтрокиУпорядочены = МассивПронумерованныхСтрокУпорядочен(МассивСтрок);
	
	Если СтрокиУпорядочены Тогда
		
		Результат = МассивСтрок;
		
	Иначе
		
		ТаблицаСортировки = Новый ТаблицаЗначений;
		ТаблицаСортировки.Колонки.Добавить("Строка", Новый ОписаниеТипов("СтрокаТаблицыЗначений"));
		ТаблицаСортировки.Колонки.Добавить("ПорядковыйНомер", Новый ОписаниеТипов("Число", Новый КвалификаторыЧисла));
		
		Для Индекс = 0 По МассивСтрок.ВГраница() Цикл
			
			Строка = МассивСтрок[Индекс];
			
			НоваяСтрока = ТаблицаСортировки.Добавить();
			НоваяСтрока.Строка = Строка;
			НоваяСтрока.ПорядковыйНомер = Строка.ПорядковыйНомер;
			
		КонецЦикла;
		
		ТаблицаСортировки.Сортировать("ПорядковыйНомер ВОЗР");
		
		Результат = Новый Массив;
		Для Индекс = 0 По ТаблицаСортировки.Количество()-1 Цикл
			
			Результат.Добавить(ТаблицаСортировки[Индекс].Строка);
			
		КонецЦикла;
		
	КонецЕсли;
	
	Возврат Результат;
	
КонецФункции

Функция МассивПронумерованныхСтрокУпорядочен(МассивСтрок)
	
	Результат = Истина;
	
	МаксИндекс = МассивСтрок.ВГраница();
	
	ПредыдущаяСтрока = МассивСтрок[МаксИндекс];
	Для Сч = 1 По МаксИндекс Цикл
		
		ТекущаяСтрока = МассивСтрок[МаксИндекс-сч];
		Если ТекущаяСтрока.ПорядковыйНомер > ПредыдущаяСтрока.ПорядковыйНомер Тогда
			Результат = Ложь;
			Прервать;
		КонецЕсли;
		
		ПредыдущаяСтрока = ТекущаяСтрока;
		
	КонецЦикла;
	
	Возврат Результат;
	
КонецФункции

Функция УпорядочитьНеПронумерованныеСтроки(Таблица, МассивСтрок)
	
	ТаблицаИндексов = ИндексыНеПронумерованныхСтрок(Таблица, МассивСтрок);
	СтрокиУпорядочены = ТаблицаИндексовУпорядочена(ТаблицаИндексов);
	
	Если СтрокиУпорядочены Тогда
		
		Результат = МассивСтрок;
		
	Иначе
		
		ТаблицаИндексов.Сортировать("ИндексТаблицы ВОЗР");
		
		Результат = Новый Массив;
		Для Индекс = 0 По ТаблицаИндексов.Количество()-1 Цикл
			
			Результат.Добавить(ТаблицаИндексов[Индекс].Строка);
			
		КонецЦикла;
		
	КонецЕсли;
	
	Возврат Результат;
	
КонецФункции

Функция ИндексыНеПронумерованныхСтрок(Таблица, МассивСтрок)
	
	Результат = Новый ТаблицаЗначений;
	Результат.Колонки.Добавить("Строка", Новый ОписаниеТипов("СтрокаТаблицыЗначений"));
	Результат.Колонки.Добавить("ИндексТаблицы", Новый ОписаниеТипов("Число", Новый КвалификаторыЧисла));
	
	Для Индекс = 0 По МассивСтрок.ВГраница() Цикл
		
		Строка = МассивСтрок[Индекс];
		
		НоваяСтрока = Результат.Добавить();
		НоваяСтрока.Строка = Строка;
		НоваяСтрока.ИндексТаблицы = Таблица.Индекс(Строка);
		
	КонецЦикла;
	
	Возврат Результат;
	
КонецФункции

Функция ТаблицаИндексовУпорядочена(ТаблицаИндексов)
	
	Результат = Истина;
	
	ПредыдущаяСтрока = ТаблицаИндексов[0];
	Для Индекс = 1 По ТаблицаИндексов.Количество()-1 Цикл
		
		ТекущаяСтрока = ТаблицаИндексов[Индекс];
		Если ТекущаяСтрока.ИндексТаблицы < ПредыдущаяСтрока.ИндексТаблицы Тогда
			Результат = Ложь;
			Прервать;
		КонецЕсли;
		
		ПредыдущаяСтрока = ТекущаяСтрока;
		
	КонецЦикла;
	
	Возврат Результат;
	
КонецФункции

#КонецОбласти

#Область КопированиеЭлементовФормы

Функция КопируемыеСвойстваЭлементовФормы()
	
	Результат = Новый Соответствие;
	
	СвойстваПоляФормы = Новый Массив;
	СвойстваПоляФормы.Добавить("Вид");
	СвойстваПоляФормы.Добавить("ВидФлажка");
	СвойстваПоляФормы.Добавить("Заголовок");
	СвойстваПоляФормы.Добавить("ПоложениеЗаголовка");
	СвойстваПоляФормы.Добавить("АвтоМаксимальнаяВысота");
	СвойстваПоляФормы.Добавить("АвтоМаксимальнаяШирина");
	СвойстваПоляФормы.Добавить("АвтоОтметкаНезаполненного");
	СвойстваПоляФормы.Добавить("ВертикальноеПоложение");
	СвойстваПоляФормы.Добавить("ВертикальноеПоложениеВГруппе");
	СвойстваПоляФормы.Добавить("Видимость");
	СвойстваПоляФормы.Добавить("ВыбиратьТип");
	СвойстваПоляФормы.Добавить("ВыборГруппИЭлементов");
	СвойстваПоляФормы.Добавить("ВыделятьОтрицательные");
	СвойстваПоляФормы.Добавить("Высота");
	СвойстваПоляФормы.Добавить("ВысотаЗаголовка");
	СвойстваПоляФормы.Добавить("ВысотаСпискаВыбора");
	СвойстваПоляФормы.Добавить("ГиперссылкаЯчейки");
	СвойстваПоляФормы.Добавить("ГоризонтальноеПоложение");
	СвойстваПоляФормы.Добавить("ГоризонтальноеПоложениеВГруппе");
	СвойстваПоляФормы.Добавить("ГоризонтальноеПоложениеВПодвале");
	СвойстваПоляФормы.Добавить("ГоризонтальноеПоложениеВШапке");
	СвойстваПоляФормы.Добавить("ВертикальноеПоложение");
	СвойстваПоляФормы.Добавить("ВертикальноеПоложениеВГруппе");
	СвойстваПоляФормы.Добавить("РастягиватьПоВертикали");
	СвойстваПоляФормы.Добавить("Доступность");
	СвойстваПоляФормы.Добавить("МногострочныйРежим");
	СвойстваПоляФормы.Добавить("АвтоПереносСтрок");
	СвойстваПоляФормы.Добавить("ТолькоПросмотр");
	СвойстваПоляФормы.Добавить("Ширина");
	СвойстваПоляФормы.Добавить("Шрифт");
	СвойстваПоляФормы.Добавить("ШрифтЗаголовка");
	СвойстваПоляФормы.Добавить("ШрифтПодвала");
	СвойстваПоляФормы.Добавить("Ширина");
	СвойстваПоляФормы.Добавить("ШрифтЗаголовка");
	СвойстваПоляФормы.Добавить("ШрифтПодвала");
	СвойстваПоляФормы.Добавить("ОтображатьВПодвале");
	СвойстваПоляФормы.Добавить("ОтображатьВШапке");
	СвойстваПоляФормы.Добавить("ПутьКДанным");
	СвойстваПоляФормы.Добавить("ПутьКДаннымПодвала");
	СвойстваПоляФормы.Добавить("ПараметрыВыбора");
	СвойстваПоляФормы.Добавить("СвязиПараметровВыбора");
	СвойстваПоляФормы.Добавить("АвтоМаксимальнаяВысота");
	СвойстваПоляФормы.Добавить("МаксимальнаяШирина");
	СвойстваПоляФормы.Добавить("АвтоМаксимальнаяШирина");
	СвойстваПоляФормы.Добавить("МаксимальнаяВысота");
	Результат.Вставить(Тип("ПолеФормы"), СвойстваПоляФормы);
	
	СвойстваГруппыФормы = Новый Массив();
	СвойстваГруппыФормы.Добавить("Вид");
	СвойстваГруппыФормы.Добавить("Заголовок");
	СвойстваГруппыФормы.Добавить("ПутьКДаннымЗаголовка");
	СвойстваГруппыФормы.Добавить("ОтображатьЗаголовок");
	СвойстваГруппыФормы.Добавить("Видимость");
	СвойстваГруппыФормы.Добавить("Доступность");
	СвойстваГруппыФормы.Добавить("ТолькоПросмотр");
	СвойстваГруппыФормы.Добавить("Объединенная");
	СвойстваГруппыФормы.Добавить("Поведение");
	СвойстваГруппыФормы.Добавить("Отображение");
	СвойстваГруппыФормы.Добавить("СквозноеВыравнивание");
	СвойстваГруппыФормы.Добавить("Группировка");
	СвойстваГруппыФормы.Добавить("ОтображатьВШапке");
	СвойстваГруппыФормы.Добавить("ГоризонтальноеПоложениеВГруппе");
	СвойстваГруппыФормы.Добавить("ГоризонтальноеПоложениеВШапке");
	СвойстваГруппыФормы.Добавить("Ширина");
	СвойстваГруппыФормы.Добавить("Высота");
	СвойстваГруппыФормы.Добавить("РастягиватьПоВертикали");
	СвойстваГруппыФормы.Добавить("РастягиватьПоГоризонтали");
	СвойстваГруппыФормы.Добавить("ВыравниваниеЭлементовИЗаголовков");
	СвойстваГруппыФормы.Добавить("Картинка");
	СвойстваГруппыФормы.Добавить("ИсточникКоманд");
	Результат.Вставить(Тип("ГруппаФормы"), СвойстваГруппыФормы);
	
	СвойстваТаблицаФормы = Новый Массив();
	СвойстваТаблицаФормы.Добавить("Заголовок");
	СвойстваТаблицаФормы.Добавить("ПутьКДанным");
	СвойстваТаблицаФормы.Добавить("ПоложениеЗаголовка");
	СвойстваТаблицаФормы.Добавить("Видимость");
	СвойстваТаблицаФормы.Добавить("Доступность");
	СвойстваТаблицаФормы.Добавить("ТолькоПросмотр");
	СвойстваТаблицаФормы.Добавить("АктивизироватьПоУмолчанию");
	СвойстваТаблицаФормы.Добавить("РежимВыбора");
	СвойстваТаблицаФормы.Добавить("МножественныйВыбор");
	СвойстваТаблицаФормы.Добавить("ИзменятьСоставСтрок");
	СвойстваТаблицаФормы.Добавить("ИзменятьПорядокСтрок");
	СвойстваТаблицаФормы.Добавить("Шапка");
	СвойстваТаблицаФормы.Добавить("Подвал");
	СвойстваТаблицаФормы.Добавить("ПутьКДаннымКартинкиСтроки");
	СвойстваТаблицаФормы.Добавить("КартинкаСтрок");
	СвойстваТаблицаФормы.Добавить("Ширина");
	СвойстваТаблицаФормы.Добавить("Высота");
	СвойстваТаблицаФормы.Добавить("АвтоМаксимальнаяВысота");
	СвойстваТаблицаФормы.Добавить("МаксимальнаяШирина");
	СвойстваТаблицаФормы.Добавить("АвтоМаксимальнаяШирина");
	СвойстваТаблицаФормы.Добавить("МаксимальнаяВысота");
	СвойстваТаблицаФормы.Добавить("РастягиватьПоГоризонтали");
	СвойстваТаблицаФормы.Добавить("РастягиватьПоВертикали");
	Результат.Вставить(Тип("ТаблицаФормы"), СвойстваТаблицаФормы);
	
	СвойстваКомандыФормы = Новый Массив();
	СвойстваКомандыФормы.Добавить("Вид");
	СвойстваКомандыФормы.Добавить("Заголовок");
	СвойстваКомандыФормы.Добавить("Видимость");
	СвойстваКомандыФормы.Добавить("Доступность");
	СвойстваКомандыФормы.Добавить("ТолькоВоВсехДействиях");
	СвойстваКомандыФормы.Добавить("Отображение");
	СвойстваКомандыФормы.Добавить("КнопкаПоУмолчанию");
	СвойстваКомандыФормы.Добавить("АктивизироватьПоУмолчанию");
	СвойстваКомандыФормы.Добавить("Пометка");
	СвойстваКомандыФормы.Добавить("Ширина");
	СвойстваКомандыФормы.Добавить("Высота");
	СвойстваКомандыФормы.Добавить("АвтоМаксимальнаяВысота");
	СвойстваКомандыФормы.Добавить("МаксимальнаяШирина");
	СвойстваКомандыФормы.Добавить("АвтоМаксимальнаяШирина");
	СвойстваКомандыФормы.Добавить("МаксимальнаяВысота");
	СвойстваКомандыФормы.Добавить("ГоризонтальноеПоложениеВГруппе");
	СвойстваКомандыФормы.Добавить("ВертикальноеПоложениеВГруппе");
	СвойстваКомандыФормы.Добавить("РастягиватьПоГоризонтали");
	СвойстваКомандыФормы.Добавить("РастягиватьПоВертикали");
	СвойстваКомандыФормы.Добавить("ИмяКоманды");
	СвойстваКомандыФормы.Добавить("КоманднаяПанель");
	Результат.Вставить(Тип("КнопкаФормы"), СвойстваКомандыФормы);
	
	Возврат Результат;
	
КонецФункции

Функция КопируемыеОбработчикиЭлементовФормы()
	
	Результат = Новый Соответствие;
	
	СвойстваПоляФормы = Новый Массив;
	СвойстваПоляФормы.Добавить("ПриИзменении");
	СвойстваПоляФормы.Добавить("НачалоВыбораИзСписка");
	СвойстваПоляФормы.Добавить("Очистка");
	СвойстваПоляФормы.Добавить("Регулирование");
	СвойстваПоляФормы.Добавить("Открытие");
	СвойстваПоляФормы.Добавить("ОбработкаВыбора");
	СвойстваПоляФормы.Добавить("АвтоПодбор");
	СвойстваПоляФормы.Добавить("ОкончаниеВводаТекста");
	СвойстваПоляФормы.Добавить("НачалоВыбора");
	СвойстваПоляФормы.Добавить("ИзменениеТекстаРедактирования");
	СвойстваПоляФормы.Добавить("Создание");
	Результат.Вставить(Тип("ПолеФормы"), СвойстваПоляФормы);
	
	СвойстваГруппыФормы = Новый Массив();
	СвойстваГруппыФормы.Добавить("ПриСменеСтраницы");
	Результат.Вставить(Тип("ГруппаФормы"), СвойстваГруппыФормы);
	
	СвойстваТаблицаФормы = Новый Массив();
	СвойстваТаблицаФормы.Добавить("Выбор");
	СвойстваТаблицаФормы.Добавить("ВыборЗначения");
	СвойстваТаблицаФормы.Добавить("ПриАктивизацииСтроки");
	СвойстваТаблицаФормы.Добавить("ПриАктивизацииПоля");
	СвойстваТаблицаФормы.Добавить("ПриАктивизацииЯчейки");
	СвойстваТаблицаФормы.Добавить("ПередНачаломДобавления");
	СвойстваТаблицаФормы.Добавить("ПередНачаломИзменения");
	СвойстваТаблицаФормы.Добавить("ПередУдалением");
	СвойстваТаблицаФормы.Добавить("ПриНачалеРедактирования");
	СвойстваТаблицаФормы.Добавить("ПередОкончаниемРедактирования");
	СвойстваТаблицаФормы.Добавить("ПриОкончанииРедактирования");
	СвойстваТаблицаФормы.Добавить("ОбработкаВыбора");
	СвойстваТаблицаФормы.Добавить("ПередРазворачиванием");
	СвойстваТаблицаФормы.Добавить("ПередСворачиванием");
	СвойстваТаблицаФормы.Добавить("ПослеУдаления");
	СвойстваТаблицаФормы.Добавить("ПриСменеТекущегоРодителя");
	СвойстваТаблицаФормы.Добавить("ПриИзменении");
	СвойстваТаблицаФормы.Добавить("ОбработкаЗаписиНового");
	СвойстваТаблицаФормы.Добавить("НачалоПеретаскивания");
	СвойстваТаблицаФормы.Добавить("ПроверкаПеретаскивания");
	СвойстваТаблицаФормы.Добавить("ОкончаниеПеретаскивания");
	СвойстваТаблицаФормы.Добавить("Перетаскивание");
	Результат.Вставить(Тип("ТаблицаФормы"), СвойстваТаблицаФормы);
	
	СвойстваКомандыФормы = Новый Массив();
	Результат.Вставить(Тип("КнопкаФормы"), СвойстваКомандыФормы);
	
	Возврат Результат;
	
КонецФункции

#КонецОбласти
